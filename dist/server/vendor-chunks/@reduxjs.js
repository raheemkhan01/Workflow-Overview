"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@reduxjs";
exports.ids = ["vendor-chunks/@reduxjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/cjs/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/cjs/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./redux-toolkit.development.cjs */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/cjs/redux-toolkit.development.cjs\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L2Nqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUlBLEtBQXlCLEVBQWMsRUFFMUMsTUFBTTtJQUNMQywySkFBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93b3JrZmxvdy8uL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L2Rpc3QvY2pzL2luZGV4LmpzPzc1NjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVkdXgtdG9vbGtpdC5wcm9kdWN0aW9uLm1pbi5janMnKVxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlZHV4LXRvb2xraXQuZGV2ZWxvcG1lbnQuY2pzJylcbn0iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/cjs/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/cjs/redux-toolkit.development.cjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/cjs/redux-toolkit.development.cjs ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __reExport = (target, mod, secondTarget)=>(__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\nvar __toCommonJS = (mod)=>__copyProps(__defProp({}, \"__esModule\", {\n        value: true\n    }), mod);\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n    ReducerType: ()=>ReducerType,\n    SHOULD_AUTOBATCH: ()=>SHOULD_AUTOBATCH,\n    TaskAbortError: ()=>TaskAbortError,\n    Tuple: ()=>Tuple,\n    addListener: ()=>addListener,\n    asyncThunkCreator: ()=>asyncThunkCreator,\n    autoBatchEnhancer: ()=>autoBatchEnhancer,\n    buildCreateSlice: ()=>buildCreateSlice,\n    clearAllListeners: ()=>clearAllListeners,\n    combineSlices: ()=>combineSlices,\n    configureStore: ()=>configureStore,\n    createAction: ()=>createAction,\n    createActionCreatorInvariantMiddleware: ()=>createActionCreatorInvariantMiddleware,\n    createAsyncThunk: ()=>createAsyncThunk,\n    createDraftSafeSelector: ()=>createDraftSafeSelector,\n    createDraftSafeSelectorCreator: ()=>createDraftSafeSelectorCreator,\n    createDynamicMiddleware: ()=>createDynamicMiddleware,\n    createEntityAdapter: ()=>createEntityAdapter,\n    createImmutableStateInvariantMiddleware: ()=>createImmutableStateInvariantMiddleware,\n    createListenerMiddleware: ()=>createListenerMiddleware,\n    createNextState: ()=>import_immer5.produce,\n    createReducer: ()=>createReducer,\n    createSelector: ()=>import_reselect2.createSelector,\n    createSelectorCreator: ()=>import_reselect2.createSelectorCreator,\n    createSerializableStateInvariantMiddleware: ()=>createSerializableStateInvariantMiddleware,\n    createSlice: ()=>createSlice,\n    current: ()=>import_immer5.current,\n    findNonSerializableValue: ()=>findNonSerializableValue,\n    formatProdErrorMessage: ()=>formatProdErrorMessage,\n    freeze: ()=>import_immer5.freeze,\n    isActionCreator: ()=>isActionCreator,\n    isAllOf: ()=>isAllOf,\n    isAnyOf: ()=>isAnyOf,\n    isAsyncThunkAction: ()=>isAsyncThunkAction,\n    isDraft: ()=>import_immer5.isDraft,\n    isFluxStandardAction: ()=>isFSA,\n    isFulfilled: ()=>isFulfilled,\n    isImmutableDefault: ()=>isImmutableDefault,\n    isPending: ()=>isPending,\n    isPlain: ()=>isPlain,\n    isRejected: ()=>isRejected,\n    isRejectedWithValue: ()=>isRejectedWithValue,\n    lruMemoize: ()=>import_reselect2.lruMemoize,\n    miniSerializeError: ()=>miniSerializeError,\n    nanoid: ()=>nanoid,\n    original: ()=>import_immer5.original,\n    prepareAutoBatched: ()=>prepareAutoBatched,\n    removeListener: ()=>removeListener,\n    unwrapResult: ()=>unwrapResult,\n    weakMapMemoize: ()=>import_reselect2.weakMapMemoize\n});\nmodule.exports = __toCommonJS(src_exports);\n__reExport(src_exports, __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/cjs/redux.cjs\"), module.exports);\nvar import_immer5 = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/cjs/index.js\");\nvar import_reselect2 = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/cjs/reselect.cjs\");\n// src/createDraftSafeSelector.ts\nvar import_immer = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/cjs/index.js\");\nvar import_reselect = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/cjs/reselect.cjs\");\nvar createDraftSafeSelectorCreator = (...args)=>{\n    const createSelector2 = (0, import_reselect.createSelectorCreator)(...args);\n    const createDraftSafeSelector2 = Object.assign((...args2)=>{\n        const selector = createSelector2(...args2);\n        const wrappedSelector = (value, ...rest)=>selector((0, import_immer.isDraft)(value) ? (0, import_immer.current)(value) : value, ...rest);\n        Object.assign(wrappedSelector, selector);\n        return wrappedSelector;\n    }, {\n        withTypes: ()=>createDraftSafeSelector2\n    });\n    return createDraftSafeSelector2;\n};\nvar createDraftSafeSelector = createDraftSafeSelectorCreator(import_reselect.weakMapMemoize);\n// src/configureStore.ts\nvar import_redux4 = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/cjs/redux.cjs\");\n// src/devtoolsExtension.ts\nvar import_redux = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/cjs/redux.cjs\");\nvar composeWithDevTools =  false ? 0 : function() {\n    if (arguments.length === 0) return void 0;\n    if (typeof arguments[0] === \"object\") return import_redux.compose;\n    return import_redux.compose.apply(null, arguments);\n};\nvar devToolsEnhancer =  false ? 0 : function() {\n    return function(noop3) {\n        return noop3;\n    };\n};\n// src/getDefaultMiddleware.ts\nvar import_redux_thunk = __webpack_require__(/*! redux-thunk */ \"(ssr)/./node_modules/redux-thunk/dist/cjs/redux-thunk.cjs\");\n// src/createAction.ts\nvar import_redux2 = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/cjs/redux.cjs\");\n// src/tsHelpers.ts\nvar hasMatchFunction = (v)=>{\n    return v && typeof v.match === \"function\";\n};\n// src/createAction.ts\nfunction createAction(type, prepareAction) {\n    function actionCreator(...args) {\n        if (prepareAction) {\n            let prepared = prepareAction(...args);\n            if (!prepared) {\n                throw new Error( false ? 0 : \"prepareAction did not return an object\");\n            }\n            return {\n                type,\n                payload: prepared.payload,\n                ...\"meta\" in prepared && {\n                    meta: prepared.meta\n                },\n                ...\"error\" in prepared && {\n                    error: prepared.error\n                }\n            };\n        }\n        return {\n            type,\n            payload: args[0]\n        };\n    }\n    actionCreator.toString = ()=>`${type}`;\n    actionCreator.type = type;\n    actionCreator.match = (action)=>(0, import_redux2.isAction)(action) && action.type === type;\n    return actionCreator;\n}\nfunction isActionCreator(action) {\n    return typeof action === \"function\" && \"type\" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it\n    hasMatchFunction(action);\n}\nfunction isFSA(action) {\n    return (0, import_redux2.isAction)(action) && Object.keys(action).every(isValidKey);\n}\nfunction isValidKey(key) {\n    return [\n        \"type\",\n        \"payload\",\n        \"error\",\n        \"meta\"\n    ].indexOf(key) > -1;\n}\n// src/actionCreatorInvariantMiddleware.ts\nfunction getMessage(type) {\n    const splitType = type ? `${type}`.split(\"/\") : [];\n    const actionName = splitType[splitType.length - 1] || \"actionCreator\";\n    return `Detected an action creator with type \"${type || \"unknown\"}\" being dispatched. \nMake sure you're calling the action creator before dispatching, i.e. \\`dispatch(${actionName}())\\` instead of \\`dispatch(${actionName})\\`. This is necessary even if the action has no payload.`;\n}\nfunction createActionCreatorInvariantMiddleware(options = {}) {\n    if (false) {}\n    const { isActionCreator: isActionCreator2 = isActionCreator } = options;\n    return ()=>(next)=>(action)=>{\n                if (isActionCreator2(action)) {\n                    console.warn(getMessage(action.type));\n                }\n                return next(action);\n            };\n}\n// src/utils.ts\nvar import_immer2 = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/cjs/index.js\");\nfunction getTimeMeasureUtils(maxDelay, fnName) {\n    let elapsed = 0;\n    return {\n        measureTime (fn) {\n            const started = Date.now();\n            try {\n                return fn();\n            } finally{\n                const finished = Date.now();\n                elapsed += finished - started;\n            }\n        },\n        warnIfExceeded () {\n            if (elapsed > maxDelay) {\n                console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that.`);\n            }\n        }\n    };\n}\nfunction find(iterable, comparator) {\n    for (const entry of iterable){\n        if (comparator(entry)) {\n            return entry;\n        }\n    }\n    return void 0;\n}\nvar Tuple = class _Tuple extends Array {\n    constructor(...items){\n        super(...items);\n        Object.setPrototypeOf(this, _Tuple.prototype);\n    }\n    static get [Symbol.species]() {\n        return _Tuple;\n    }\n    concat(...arr) {\n        return super.concat.apply(this, arr);\n    }\n    prepend(...arr) {\n        if (arr.length === 1 && Array.isArray(arr[0])) {\n            return new _Tuple(...arr[0].concat(this));\n        }\n        return new _Tuple(...arr.concat(this));\n    }\n};\nfunction freezeDraftable(val) {\n    return (0, import_immer2.isDraftable)(val) ? (0, import_immer2.produce)(val, ()=>{}) : val;\n}\nfunction emplace(map, key, handler) {\n    if (map.has(key)) {\n        let value = map.get(key);\n        if (handler.update) {\n            value = handler.update(value, key, map);\n            map.set(key, value);\n        }\n        return value;\n    }\n    if (!handler.insert) throw new Error( false ? 0 : \"No insert provided for key not already in map\");\n    const inserted = handler.insert(key, map);\n    map.set(key, inserted);\n    return inserted;\n}\n// src/immutableStateInvariantMiddleware.ts\nfunction isImmutableDefault(value) {\n    return typeof value !== \"object\" || value == null || Object.isFrozen(value);\n}\nfunction trackForMutations(isImmutable, ignorePaths, obj) {\n    const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);\n    return {\n        detectMutations () {\n            return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);\n        }\n    };\n}\nfunction trackProperties(isImmutable, ignorePaths = [], obj, path = \"\", checkedObjects = /* @__PURE__ */ new Set()) {\n    const tracked = {\n        value: obj\n    };\n    if (!isImmutable(obj) && !checkedObjects.has(obj)) {\n        checkedObjects.add(obj);\n        tracked.children = {};\n        for(const key in obj){\n            const childPath = path ? path + \".\" + key : key;\n            if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\n                continue;\n            }\n            tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);\n        }\n    }\n    return tracked;\n}\nfunction detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path = \"\") {\n    const prevObj = trackedProperty ? trackedProperty.value : void 0;\n    const sameRef = prevObj === obj;\n    if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\n        return {\n            wasMutated: true,\n            path\n        };\n    }\n    if (isImmutable(prevObj) || isImmutable(obj)) {\n        return {\n            wasMutated: false\n        };\n    }\n    const keysToDetect = {};\n    for(let key in trackedProperty.children){\n        keysToDetect[key] = true;\n    }\n    for(let key in obj){\n        keysToDetect[key] = true;\n    }\n    const hasIgnoredPaths = ignoredPaths.length > 0;\n    for(let key in keysToDetect){\n        const nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            const hasMatches = ignoredPaths.some((ignored)=>{\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                continue;\n            }\n        }\n        const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);\n        if (result.wasMutated) {\n            return result;\n        }\n    }\n    return {\n        wasMutated: false\n    };\n}\nfunction createImmutableStateInvariantMiddleware(options = {}) {\n    if (false) {} else {\n        let stringify2 = function(obj, serializer, indent, decycler) {\n            return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);\n        }, getSerialize2 = function(serializer, decycler) {\n            let stack = [], keys = [];\n            if (!decycler) decycler = function(_, value) {\n                if (stack[0] === value) return \"[Circular ~]\";\n                return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n            };\n            return function(key, value) {\n                if (stack.length > 0) {\n                    var thisPos = stack.indexOf(this);\n                    ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n                    ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n                    if (~stack.indexOf(value)) value = decycler.call(this, key, value);\n                } else stack.push(value);\n                return serializer == null ? value : serializer.call(this, key, value);\n            };\n        };\n        var stringify = stringify2, getSerialize = getSerialize2;\n        let { isImmutable = isImmutableDefault, ignoredPaths, warnAfter = 32 } = options;\n        const track = trackForMutations.bind(null, isImmutable, ignoredPaths);\n        return ({ getState })=>{\n            let state = getState();\n            let tracker = track(state);\n            let result;\n            return (next)=>(action)=>{\n                    const measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\n                    measureUtils.measureTime(()=>{\n                        state = getState();\n                        result = tracker.detectMutations();\n                        tracker = track(state);\n                        if (result.wasMutated) {\n                            throw new Error( false ? 0 : `A state mutation was detected between dispatches, in the path '${result.path || \"\"}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n                        }\n                    });\n                    const dispatchedAction = next(action);\n                    measureUtils.measureTime(()=>{\n                        state = getState();\n                        result = tracker.detectMutations();\n                        tracker = track(state);\n                        if (result.wasMutated) {\n                            throw new Error( false ? 0 : `A state mutation was detected inside a dispatch, in the path: ${result.path || \"\"}. Take a look at the reducer(s) handling the action ${stringify2(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n                        }\n                    });\n                    measureUtils.warnIfExceeded();\n                    return dispatchedAction;\n                };\n        };\n    }\n}\n// src/serializableStateInvariantMiddleware.ts\nvar import_redux3 = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/cjs/redux.cjs\");\nfunction isPlain(val) {\n    const type = typeof val;\n    return val == null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || (0, import_redux3.isPlainObject)(val);\n}\nfunction findNonSerializableValue(value, path = \"\", isSerializable = isPlain, getEntries, ignoredPaths = [], cache) {\n    let foundNestedSerializable;\n    if (!isSerializable(value)) {\n        return {\n            keyPath: path || \"<root>\",\n            value\n        };\n    }\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    if (cache?.has(value)) return false;\n    const entries = getEntries != null ? getEntries(value) : Object.entries(value);\n    const hasIgnoredPaths = ignoredPaths.length > 0;\n    for (const [key, nestedValue] of entries){\n        const nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            const hasMatches = ignoredPaths.some((ignored)=>{\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                continue;\n            }\n        }\n        if (!isSerializable(nestedValue)) {\n            return {\n                keyPath: nestedPath,\n                value: nestedValue\n            };\n        }\n        if (typeof nestedValue === \"object\") {\n            foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);\n            if (foundNestedSerializable) {\n                return foundNestedSerializable;\n            }\n        }\n    }\n    if (cache && isNestedFrozen(value)) cache.add(value);\n    return false;\n}\nfunction isNestedFrozen(value) {\n    if (!Object.isFrozen(value)) return false;\n    for (const nestedValue of Object.values(value)){\n        if (typeof nestedValue !== \"object\" || nestedValue === null) continue;\n        if (!isNestedFrozen(nestedValue)) return false;\n    }\n    return true;\n}\nfunction createSerializableStateInvariantMiddleware(options = {}) {\n    if (false) {} else {\n        const { isSerializable = isPlain, getEntries, ignoredActions = [], ignoredActionPaths = [\n            \"meta.arg\",\n            \"meta.baseQueryMeta\"\n        ], ignoredPaths = [], warnAfter = 32, ignoreState = false, ignoreActions = false, disableCache = false } = options;\n        const cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;\n        return (storeAPI)=>(next)=>(action)=>{\n                    if (!(0, import_redux3.isAction)(action)) {\n                        return next(action);\n                    }\n                    const result = next(action);\n                    const measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\n                    if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\n                        measureUtils.measureTime(()=>{\n                            const foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths, cache);\n                            if (foundActionNonSerializableValue) {\n                                const { keyPath, value } = foundActionNonSerializableValue;\n                                console.error(`A non-serializable value was detected in an action, in the path: \\`${keyPath}\\`. Value:`, value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\n                            }\n                        });\n                    }\n                    if (!ignoreState) {\n                        measureUtils.measureTime(()=>{\n                            const state = storeAPI.getState();\n                            const foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths, cache);\n                            if (foundStateNonSerializableValue) {\n                                const { keyPath, value } = foundStateNonSerializableValue;\n                                console.error(`A non-serializable value was detected in the state, in the path: \\`${keyPath}\\`. Value:`, value, `\nTake a look at the reducer(s) handling this action type: ${action.type}.\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);\n                            }\n                        });\n                        measureUtils.warnIfExceeded();\n                    }\n                    return result;\n                };\n    }\n}\n// src/getDefaultMiddleware.ts\nfunction isBoolean(x) {\n    return typeof x === \"boolean\";\n}\nvar buildGetDefaultMiddleware = ()=>function getDefaultMiddleware(options) {\n        const { thunk = true, immutableCheck = true, serializableCheck = true, actionCreatorCheck = true } = options ?? {};\n        let middlewareArray = new Tuple();\n        if (thunk) {\n            if (isBoolean(thunk)) {\n                middlewareArray.push(import_redux_thunk.thunk);\n            } else {\n                middlewareArray.push((0, import_redux_thunk.withExtraArgument)(thunk.extraArgument));\n            }\n        }\n        if (true) {\n            if (immutableCheck) {\n                let immutableOptions = {};\n                if (!isBoolean(immutableCheck)) {\n                    immutableOptions = immutableCheck;\n                }\n                middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));\n            }\n            if (serializableCheck) {\n                let serializableOptions = {};\n                if (!isBoolean(serializableCheck)) {\n                    serializableOptions = serializableCheck;\n                }\n                middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));\n            }\n            if (actionCreatorCheck) {\n                let actionCreatorOptions = {};\n                if (!isBoolean(actionCreatorCheck)) {\n                    actionCreatorOptions = actionCreatorCheck;\n                }\n                middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));\n            }\n        }\n        return middlewareArray;\n    };\n// src/autoBatchEnhancer.ts\nvar SHOULD_AUTOBATCH = \"RTK_autoBatch\";\nvar prepareAutoBatched = ()=>(payload)=>({\n            payload,\n            meta: {\n                [SHOULD_AUTOBATCH]: true\n            }\n        });\nvar createQueueWithTimer = (timeout)=>{\n    return (notify)=>{\n        setTimeout(notify, timeout);\n    };\n};\nvar rAF =  false ? 0 : createQueueWithTimer(10);\nvar autoBatchEnhancer = (options = {\n    type: \"raf\"\n})=>(next)=>(...args)=>{\n            const store = next(...args);\n            let notifying = true;\n            let shouldNotifyAtEndOfTick = false;\n            let notificationQueued = false;\n            const listeners = /* @__PURE__ */ new Set();\n            const queueCallback = options.type === \"tick\" ? queueMicrotask : options.type === \"raf\" ? rAF : options.type === \"callback\" ? options.queueNotification : createQueueWithTimer(options.timeout);\n            const notifyListeners = ()=>{\n                notificationQueued = false;\n                if (shouldNotifyAtEndOfTick) {\n                    shouldNotifyAtEndOfTick = false;\n                    listeners.forEach((l)=>l());\n                }\n            };\n            return Object.assign({}, store, {\n                // Override the base `store.subscribe` method to keep original listeners\n                // from running if we're delaying notifications\n                subscribe (listener2) {\n                    const wrappedListener = ()=>notifying && listener2();\n                    const unsubscribe = store.subscribe(wrappedListener);\n                    listeners.add(listener2);\n                    return ()=>{\n                        unsubscribe();\n                        listeners.delete(listener2);\n                    };\n                },\n                // Override the base `store.dispatch` method so that we can check actions\n                // for the `shouldAutoBatch` flag and determine if batching is active\n                dispatch (action) {\n                    try {\n                        notifying = !action?.meta?.[SHOULD_AUTOBATCH];\n                        shouldNotifyAtEndOfTick = !notifying;\n                        if (shouldNotifyAtEndOfTick) {\n                            if (!notificationQueued) {\n                                notificationQueued = true;\n                                queueCallback(notifyListeners);\n                            }\n                        }\n                        return store.dispatch(action);\n                    } finally{\n                        notifying = true;\n                    }\n                }\n            });\n        };\n// src/getDefaultEnhancers.ts\nvar buildGetDefaultEnhancers = (middlewareEnhancer)=>function getDefaultEnhancers(options) {\n        const { autoBatch = true } = options ?? {};\n        let enhancerArray = new Tuple(middlewareEnhancer);\n        if (autoBatch) {\n            enhancerArray.push(autoBatchEnhancer(typeof autoBatch === \"object\" ? autoBatch : void 0));\n        }\n        return enhancerArray;\n    };\n// src/configureStore.ts\nvar IS_PRODUCTION = false;\nfunction configureStore(options) {\n    const getDefaultMiddleware = buildGetDefaultMiddleware();\n    const { reducer = void 0, middleware, devTools = true, preloadedState = void 0, enhancers = void 0 } = options || {};\n    let rootReducer;\n    if (typeof reducer === \"function\") {\n        rootReducer = reducer;\n    } else if ((0, import_redux4.isPlainObject)(reducer)) {\n        rootReducer = (0, import_redux4.combineReducers)(reducer);\n    } else {\n        throw new Error( false ? 0 : \"`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers\");\n    }\n    if (!IS_PRODUCTION && middleware && typeof middleware !== \"function\") {\n        throw new Error( false ? 0 : \"`middleware` field must be a callback\");\n    }\n    let finalMiddleware;\n    if (typeof middleware === \"function\") {\n        finalMiddleware = middleware(getDefaultMiddleware);\n        if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {\n            throw new Error( false ? 0 : \"when using a middleware builder function, an array of middleware must be returned\");\n        }\n    } else {\n        finalMiddleware = getDefaultMiddleware();\n    }\n    if (!IS_PRODUCTION && finalMiddleware.some((item)=>typeof item !== \"function\")) {\n        throw new Error( false ? 0 : \"each middleware provided to configureStore must be a function\");\n    }\n    let finalCompose = import_redux4.compose;\n    if (devTools) {\n        finalCompose = composeWithDevTools({\n            // Enable capture of stack traces for dispatched Redux actions\n            trace: !IS_PRODUCTION,\n            ...typeof devTools === \"object\" && devTools\n        });\n    }\n    const middlewareEnhancer = (0, import_redux4.applyMiddleware)(...finalMiddleware);\n    const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);\n    if (!IS_PRODUCTION && enhancers && typeof enhancers !== \"function\") {\n        throw new Error( false ? 0 : \"`enhancers` field must be a callback\");\n    }\n    let storeEnhancers = typeof enhancers === \"function\" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();\n    if (!IS_PRODUCTION && !Array.isArray(storeEnhancers)) {\n        throw new Error( false ? 0 : \"`enhancers` callback must return an array\");\n    }\n    if (!IS_PRODUCTION && storeEnhancers.some((item)=>typeof item !== \"function\")) {\n        throw new Error( false ? 0 : \"each enhancer provided to configureStore must be a function\");\n    }\n    if (!IS_PRODUCTION && finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {\n        console.error(\"middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`\");\n    }\n    const composedEnhancer = finalCompose(...storeEnhancers);\n    return (0, import_redux4.createStore)(rootReducer, preloadedState, composedEnhancer);\n}\n// src/createReducer.ts\nvar import_immer3 = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/cjs/index.js\");\n// src/mapBuilders.ts\nfunction executeReducerBuilderCallback(builderCallback) {\n    const actionsMap = {};\n    const actionMatchers = [];\n    let defaultCaseReducer;\n    const builder = {\n        addCase (typeOrActionCreator, reducer) {\n            if (true) {\n                if (actionMatchers.length > 0) {\n                    throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addMatcher`\");\n                }\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n            if (!type) {\n                throw new Error( false ? 0 : \"`builder.addCase` cannot be called with an empty action type\");\n            }\n            if (type in actionsMap) {\n                throw new Error( false ? 0 : `\\`builder.addCase\\` cannot be called with two reducers for the same action type '${type}'`);\n            }\n            actionsMap[type] = reducer;\n            return builder;\n        },\n        addMatcher (matcher, reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addMatcher` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            actionMatchers.push({\n                matcher,\n                reducer\n            });\n            return builder;\n        },\n        addDefaultCase (reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addDefaultCase` can only be called once\");\n                }\n            }\n            defaultCaseReducer = reducer;\n            return builder;\n        }\n    };\n    builderCallback(builder);\n    return [\n        actionsMap,\n        actionMatchers,\n        defaultCaseReducer\n    ];\n}\n// src/createReducer.ts\nfunction isStateFunction(x) {\n    return typeof x === \"function\";\n}\nfunction createReducer(initialState, mapOrBuilderCallback) {\n    if (true) {\n        if (typeof mapOrBuilderCallback === \"object\") {\n            throw new Error( false ? 0 : \"The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer\");\n        }\n    }\n    let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);\n    let getInitialState;\n    if (isStateFunction(initialState)) {\n        getInitialState = ()=>freezeDraftable(initialState());\n    } else {\n        const frozenInitialState = freezeDraftable(initialState);\n        getInitialState = ()=>frozenInitialState;\n    }\n    function reducer(state = getInitialState(), action) {\n        let caseReducers = [\n            actionsMap[action.type],\n            ...finalActionMatchers.filter(({ matcher })=>matcher(action)).map(({ reducer: reducer2 })=>reducer2)\n        ];\n        if (caseReducers.filter((cr)=>!!cr).length === 0) {\n            caseReducers = [\n                finalDefaultCaseReducer\n            ];\n        }\n        return caseReducers.reduce((previousState, caseReducer)=>{\n            if (caseReducer) {\n                if ((0, import_immer3.isDraft)(previousState)) {\n                    const draft = previousState;\n                    const result = caseReducer(draft, action);\n                    if (result === void 0) {\n                        return previousState;\n                    }\n                    return result;\n                } else if (!(0, import_immer3.isDraftable)(previousState)) {\n                    const result = caseReducer(previousState, action);\n                    if (result === void 0) {\n                        if (previousState === null) {\n                            return previousState;\n                        }\n                        throw new Error( false ? 0 : \"A case reducer on a non-draftable value must not return undefined\");\n                    }\n                    return result;\n                } else {\n                    return (0, import_immer3.produce)(previousState, (draft)=>{\n                        return caseReducer(draft, action);\n                    });\n                }\n            }\n            return previousState;\n        }, state);\n    }\n    reducer.getInitialState = getInitialState;\n    return reducer;\n}\n// src/nanoid.ts\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\nvar nanoid = (size = 21)=>{\n    let id = \"\";\n    let i = size;\n    while(i--){\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\n// src/matchers.ts\nvar matches = (matcher, action)=>{\n    if (hasMatchFunction(matcher)) {\n        return matcher.match(action);\n    } else {\n        return matcher(action);\n    }\n};\nfunction isAnyOf(...matchers) {\n    return (action)=>{\n        return matchers.some((matcher)=>matches(matcher, action));\n    };\n}\nfunction isAllOf(...matchers) {\n    return (action)=>{\n        return matchers.every((matcher)=>matches(matcher, action));\n    };\n}\nfunction hasExpectedRequestMetadata(action, validStatus) {\n    if (!action || !action.meta) return false;\n    const hasValidRequestId = typeof action.meta.requestId === \"string\";\n    const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\n    return hasValidRequestId && hasValidRequestStatus;\n}\nfunction isAsyncThunkArray(a) {\n    return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\n}\nfunction isPending(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"pending\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isPending()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.pending);\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejected(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"rejected\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejected()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.rejected);\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejectedWithValue(...asyncThunks) {\n    const hasFlag = (action)=>{\n        return action && action.meta && action.meta.rejectedWithValue;\n    };\n    if (asyncThunks.length === 0) {\n        return (action)=>{\n            const combinedMatcher = isAllOf(isRejected(...asyncThunks), hasFlag);\n            return combinedMatcher(action);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejectedWithValue()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const combinedMatcher = isAllOf(isRejected(...asyncThunks), hasFlag);\n        return combinedMatcher(action);\n    };\n}\nfunction isFulfilled(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"fulfilled\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isFulfilled()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.fulfilled);\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isAsyncThunkAction(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"pending\",\n                \"fulfilled\",\n                \"rejected\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isAsyncThunkAction()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = [];\n        for (const asyncThunk of asyncThunks){\n            matchers.push(asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled);\n        }\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\n// src/createAsyncThunk.ts\nvar commonProperties = [\n    \"name\",\n    \"message\",\n    \"stack\",\n    \"code\"\n];\nvar RejectWithValue = class {\n    constructor(payload, meta){\n        this.payload = payload;\n        this.meta = meta;\n    }\n};\nvar FulfillWithMeta = class {\n    constructor(payload, meta){\n        this.payload = payload;\n        this.meta = meta;\n    }\n};\nvar miniSerializeError = (value)=>{\n    if (typeof value === \"object\" && value !== null) {\n        const simpleError = {};\n        for (const property of commonProperties){\n            if (typeof value[property] === \"string\") {\n                simpleError[property] = value[property];\n            }\n        }\n        return simpleError;\n    }\n    return {\n        message: String(value)\n    };\n};\nvar createAsyncThunk = /* @__PURE__ */ (()=>{\n    function createAsyncThunk2(typePrefix, payloadCreator, options) {\n        const fulfilled = createAction(typePrefix + \"/fulfilled\", (payload, requestId, arg, meta)=>({\n                payload,\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    requestStatus: \"fulfilled\"\n                }\n            }));\n        const pending = createAction(typePrefix + \"/pending\", (requestId, arg, meta)=>({\n                payload: void 0,\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    requestStatus: \"pending\"\n                }\n            }));\n        const rejected = createAction(typePrefix + \"/rejected\", (error, requestId, arg, payload, meta)=>({\n                payload,\n                error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    rejectedWithValue: !!payload,\n                    requestStatus: \"rejected\",\n                    aborted: error?.name === \"AbortError\",\n                    condition: error?.name === \"ConditionError\"\n                }\n            }));\n        function actionCreator(arg) {\n            return (dispatch, getState, extra)=>{\n                const requestId = options?.idGenerator ? options.idGenerator(arg) : nanoid();\n                const abortController = new AbortController();\n                let abortHandler;\n                let abortReason;\n                function abort(reason) {\n                    abortReason = reason;\n                    abortController.abort();\n                }\n                const promise = async function() {\n                    let finalAction;\n                    try {\n                        let conditionResult = options?.condition?.(arg, {\n                            getState,\n                            extra\n                        });\n                        if (isThenable(conditionResult)) {\n                            conditionResult = await conditionResult;\n                        }\n                        if (conditionResult === false || abortController.signal.aborted) {\n                            throw {\n                                name: \"ConditionError\",\n                                message: \"Aborted due to condition callback returning false.\"\n                            };\n                        }\n                        const abortedPromise = new Promise((_, reject)=>{\n                            abortHandler = ()=>{\n                                reject({\n                                    name: \"AbortError\",\n                                    message: abortReason || \"Aborted\"\n                                });\n                            };\n                            abortController.signal.addEventListener(\"abort\", abortHandler);\n                        });\n                        dispatch(pending(requestId, arg, options?.getPendingMeta?.({\n                            requestId,\n                            arg\n                        }, {\n                            getState,\n                            extra\n                        })));\n                        finalAction = await Promise.race([\n                            abortedPromise,\n                            Promise.resolve(payloadCreator(arg, {\n                                dispatch,\n                                getState,\n                                extra,\n                                requestId,\n                                signal: abortController.signal,\n                                abort,\n                                rejectWithValue: (value, meta)=>{\n                                    return new RejectWithValue(value, meta);\n                                },\n                                fulfillWithValue: (value, meta)=>{\n                                    return new FulfillWithMeta(value, meta);\n                                }\n                            })).then((result)=>{\n                                if (result instanceof RejectWithValue) {\n                                    throw result;\n                                }\n                                if (result instanceof FulfillWithMeta) {\n                                    return fulfilled(result.payload, requestId, arg, result.meta);\n                                }\n                                return fulfilled(result, requestId, arg);\n                            })\n                        ]);\n                    } catch (err) {\n                        finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);\n                    } finally{\n                        if (abortHandler) {\n                            abortController.signal.removeEventListener(\"abort\", abortHandler);\n                        }\n                    }\n                    const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\n                    if (!skipDispatch) {\n                        dispatch(finalAction);\n                    }\n                    return finalAction;\n                }();\n                return Object.assign(promise, {\n                    abort,\n                    requestId,\n                    arg,\n                    unwrap () {\n                        return promise.then(unwrapResult);\n                    }\n                });\n            };\n        }\n        return Object.assign(actionCreator, {\n            pending,\n            rejected,\n            fulfilled,\n            settled: isAnyOf(rejected, fulfilled),\n            typePrefix\n        });\n    }\n    createAsyncThunk2.withTypes = ()=>createAsyncThunk2;\n    return createAsyncThunk2;\n})();\nfunction unwrapResult(action) {\n    if (action.meta && action.meta.rejectedWithValue) {\n        throw action.payload;\n    }\n    if (action.error) {\n        throw action.error;\n    }\n    return action.payload;\n}\nfunction isThenable(value) {\n    return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\n}\n// src/createSlice.ts\nvar asyncThunkSymbol = /* @__PURE__ */ Symbol.for(\"rtk-slice-createasyncthunk\");\nvar asyncThunkCreator = {\n    [asyncThunkSymbol]: createAsyncThunk\n};\nvar ReducerType = /* @__PURE__ */ ((ReducerType2)=>{\n    ReducerType2[\"reducer\"] = \"reducer\";\n    ReducerType2[\"reducerWithPrepare\"] = \"reducerWithPrepare\";\n    ReducerType2[\"asyncThunk\"] = \"asyncThunk\";\n    return ReducerType2;\n})(ReducerType || {});\nfunction getType(slice, actionKey) {\n    return `${slice}/${actionKey}`;\n}\nfunction buildCreateSlice({ creators } = {}) {\n    const cAT = creators?.asyncThunk?.[asyncThunkSymbol];\n    return function createSlice2(options) {\n        const { name, reducerPath = name } = options;\n        if (!name) {\n            throw new Error( false ? 0 : \"`name` is a required option for createSlice\");\n        }\n        if (typeof process !== \"undefined\" && true) {\n            if (options.initialState === void 0) {\n                console.error(\"You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`\");\n            }\n        }\n        const reducers = (typeof options.reducers === \"function\" ? options.reducers(buildReducerCreators()) : options.reducers) || {};\n        const reducerNames = Object.keys(reducers);\n        const context = {\n            sliceCaseReducersByName: {},\n            sliceCaseReducersByType: {},\n            actionCreators: {},\n            sliceMatchers: []\n        };\n        const contextMethods = {\n            addCase (typeOrActionCreator, reducer2) {\n                const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n                if (!type) {\n                    throw new Error( false ? 0 : \"`context.addCase` cannot be called with an empty action type\");\n                }\n                if (type in context.sliceCaseReducersByType) {\n                    throw new Error( false ? 0 : \"`context.addCase` cannot be called with two reducers for the same action type: \" + type);\n                }\n                context.sliceCaseReducersByType[type] = reducer2;\n                return contextMethods;\n            },\n            addMatcher (matcher, reducer2) {\n                context.sliceMatchers.push({\n                    matcher,\n                    reducer: reducer2\n                });\n                return contextMethods;\n            },\n            exposeAction (name2, actionCreator) {\n                context.actionCreators[name2] = actionCreator;\n                return contextMethods;\n            },\n            exposeCaseReducer (name2, reducer2) {\n                context.sliceCaseReducersByName[name2] = reducer2;\n                return contextMethods;\n            }\n        };\n        reducerNames.forEach((reducerName)=>{\n            const reducerDefinition = reducers[reducerName];\n            const reducerDetails = {\n                reducerName,\n                type: getType(name, reducerName),\n                createNotation: typeof options.reducers === \"function\"\n            };\n            if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {\n                handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);\n            } else {\n                handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);\n            }\n        });\n        function buildReducer() {\n            if (true) {\n                if (typeof options.extraReducers === \"object\") {\n                    throw new Error( false ? 0 : \"The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice\");\n                }\n            }\n            const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [\n                options.extraReducers\n            ];\n            const finalCaseReducers = {\n                ...extraReducers,\n                ...context.sliceCaseReducersByType\n            };\n            return createReducer(options.initialState, (builder)=>{\n                for(let key in finalCaseReducers){\n                    builder.addCase(key, finalCaseReducers[key]);\n                }\n                for (let sM of context.sliceMatchers){\n                    builder.addMatcher(sM.matcher, sM.reducer);\n                }\n                for (let m of actionMatchers){\n                    builder.addMatcher(m.matcher, m.reducer);\n                }\n                if (defaultCaseReducer) {\n                    builder.addDefaultCase(defaultCaseReducer);\n                }\n            });\n        }\n        const selectSelf = (state)=>state;\n        const injectedSelectorCache = /* @__PURE__ */ new Map();\n        let _reducer;\n        function reducer(state, action) {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer(state, action);\n        }\n        function getInitialState() {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer.getInitialState();\n        }\n        function makeSelectorProps(reducerPath2, injected = false) {\n            function selectSlice(state) {\n                let sliceState = state[reducerPath2];\n                if (typeof sliceState === \"undefined\") {\n                    if (injected) {\n                        sliceState = getInitialState();\n                    } else if (true) {\n                        throw new Error( false ? 0 : \"selectSlice returned undefined for an uninjected slice reducer\");\n                    }\n                }\n                return sliceState;\n            }\n            function getSelectors(selectState = selectSelf) {\n                const selectorCache = emplace(injectedSelectorCache, injected, {\n                    insert: ()=>/* @__PURE__ */ new WeakMap()\n                });\n                return emplace(selectorCache, selectState, {\n                    insert: ()=>{\n                        const map = {};\n                        for (const [name2, selector] of Object.entries(options.selectors ?? {})){\n                            map[name2] = wrapSelector(selector, selectState, getInitialState, injected);\n                        }\n                        return map;\n                    }\n                });\n            }\n            return {\n                reducerPath: reducerPath2,\n                getSelectors,\n                get selectors () {\n                    return getSelectors(selectSlice);\n                },\n                selectSlice\n            };\n        }\n        const slice = {\n            name,\n            reducer,\n            actions: context.actionCreators,\n            caseReducers: context.sliceCaseReducersByName,\n            getInitialState,\n            ...makeSelectorProps(reducerPath),\n            injectInto (injectable, { reducerPath: pathOpt, ...config } = {}) {\n                const newReducerPath = pathOpt ?? reducerPath;\n                injectable.inject({\n                    reducerPath: newReducerPath,\n                    reducer\n                }, config);\n                return {\n                    ...slice,\n                    ...makeSelectorProps(newReducerPath, true)\n                };\n            }\n        };\n        return slice;\n    };\n}\nfunction wrapSelector(selector, selectState, getInitialState, injected) {\n    function wrapper(rootState, ...args) {\n        let sliceState = selectState(rootState);\n        if (typeof sliceState === \"undefined\") {\n            if (injected) {\n                sliceState = getInitialState();\n            } else if (true) {\n                throw new Error( false ? 0 : \"selectState returned undefined for an uninjected slice reducer\");\n            }\n        }\n        return selector(sliceState, ...args);\n    }\n    wrapper.unwrapped = selector;\n    return wrapper;\n}\nvar createSlice = /* @__PURE__ */ buildCreateSlice();\nfunction buildReducerCreators() {\n    function asyncThunk(payloadCreator, config) {\n        return {\n            _reducerDefinitionType: \"asyncThunk\" /* asyncThunk */ ,\n            payloadCreator,\n            ...config\n        };\n    }\n    asyncThunk.withTypes = ()=>asyncThunk;\n    return {\n        reducer (caseReducer) {\n            return Object.assign({\n                // hack so the wrapping function has the same name as the original\n                // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original\n                [caseReducer.name] (...args) {\n                    return caseReducer(...args);\n                }\n            }[caseReducer.name], {\n                _reducerDefinitionType: \"reducer\" /* reducer */ \n            });\n        },\n        preparedReducer (prepare, reducer) {\n            return {\n                _reducerDefinitionType: \"reducerWithPrepare\" /* reducerWithPrepare */ ,\n                prepare,\n                reducer\n            };\n        },\n        asyncThunk\n    };\n}\nfunction handleNormalReducerDefinition({ type, reducerName, createNotation }, maybeReducerWithPrepare, context) {\n    let caseReducer;\n    let prepareCallback;\n    if (\"reducer\" in maybeReducerWithPrepare) {\n        if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {\n            throw new Error( false ? 0 : \"Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.\");\n        }\n        caseReducer = maybeReducerWithPrepare.reducer;\n        prepareCallback = maybeReducerWithPrepare.prepare;\n    } else {\n        caseReducer = maybeReducerWithPrepare;\n    }\n    context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));\n}\nfunction isAsyncThunkSliceReducerDefinition(reducerDefinition) {\n    return reducerDefinition._reducerDefinitionType === \"asyncThunk\" /* asyncThunk */ ;\n}\nfunction isCaseReducerWithPrepareDefinition(reducerDefinition) {\n    return reducerDefinition._reducerDefinitionType === \"reducerWithPrepare\" /* reducerWithPrepare */ ;\n}\nfunction handleThunkCaseReducerDefinition({ type, reducerName }, reducerDefinition, context, cAT) {\n    if (!cAT) {\n        throw new Error( false ? 0 : \"Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.\");\n    }\n    const { payloadCreator, fulfilled, pending, rejected, settled, options } = reducerDefinition;\n    const thunk = cAT(type, payloadCreator, options);\n    context.exposeAction(reducerName, thunk);\n    if (fulfilled) {\n        context.addCase(thunk.fulfilled, fulfilled);\n    }\n    if (pending) {\n        context.addCase(thunk.pending, pending);\n    }\n    if (rejected) {\n        context.addCase(thunk.rejected, rejected);\n    }\n    if (settled) {\n        context.addMatcher(thunk.settled, settled);\n    }\n    context.exposeCaseReducer(reducerName, {\n        fulfilled: fulfilled || noop,\n        pending: pending || noop,\n        rejected: rejected || noop,\n        settled: settled || noop\n    });\n}\nfunction noop() {}\n// src/entities/entity_state.ts\nfunction getInitialEntityState() {\n    return {\n        ids: [],\n        entities: {}\n    };\n}\nfunction createInitialStateFactory(stateAdapter) {\n    function getInitialState(additionalState = {}, entities) {\n        const state = Object.assign(getInitialEntityState(), additionalState);\n        return entities ? stateAdapter.setAll(state, entities) : state;\n    }\n    return {\n        getInitialState\n    };\n}\n// src/entities/state_selectors.ts\nfunction createSelectorsFactory() {\n    function getSelectors(selectState, options = {}) {\n        const { createSelector: createSelector2 = createDraftSafeSelector } = options;\n        const selectIds = (state)=>state.ids;\n        const selectEntities = (state)=>state.entities;\n        const selectAll = createSelector2(selectIds, selectEntities, (ids, entities)=>ids.map((id)=>entities[id]));\n        const selectId = (_, id)=>id;\n        const selectById = (entities, id)=>entities[id];\n        const selectTotal = createSelector2(selectIds, (ids)=>ids.length);\n        if (!selectState) {\n            return {\n                selectIds,\n                selectEntities,\n                selectAll,\n                selectTotal,\n                selectById: createSelector2(selectEntities, selectId, selectById)\n            };\n        }\n        const selectGlobalizedEntities = createSelector2(selectState, selectEntities);\n        return {\n            selectIds: createSelector2(selectState, selectIds),\n            selectEntities: selectGlobalizedEntities,\n            selectAll: createSelector2(selectState, selectAll),\n            selectTotal: createSelector2(selectState, selectTotal),\n            selectById: createSelector2(selectGlobalizedEntities, selectId, selectById)\n        };\n    }\n    return {\n        getSelectors\n    };\n}\n// src/entities/state_adapter.ts\nvar import_immer4 = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/cjs/index.js\");\nvar isDraftTyped = import_immer4.isDraft;\nfunction createSingleArgumentStateOperator(mutator) {\n    const operator = createStateOperator((_, state)=>mutator(state));\n    return function operation(state) {\n        return operator(state, void 0);\n    };\n}\nfunction createStateOperator(mutator) {\n    return function operation(state, arg) {\n        function isPayloadActionArgument(arg2) {\n            return isFSA(arg2);\n        }\n        const runMutator = (draft)=>{\n            if (isPayloadActionArgument(arg)) {\n                mutator(arg.payload, draft);\n            } else {\n                mutator(arg, draft);\n            }\n        };\n        if (isDraftTyped(state)) {\n            runMutator(state);\n            return state;\n        }\n        return (0, import_immer4.produce)(state, runMutator);\n    };\n}\n// src/entities/utils.ts\nfunction selectIdValue(entity, selectId) {\n    const key = selectId(entity);\n    if (key === void 0) {\n        console.warn(\"The entity passed to the `selectId` implementation returned undefined.\", \"You should probably provide your own `selectId` implementation.\", \"The entity that was passed:\", entity, \"The `selectId` implementation:\", selectId.toString());\n    }\n    return key;\n}\nfunction ensureEntitiesArray(entities) {\n    if (!Array.isArray(entities)) {\n        entities = Object.values(entities);\n    }\n    return entities;\n}\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    const added = [];\n    const updated = [];\n    for (const entity of newEntities){\n        const id = selectIdValue(entity, selectId);\n        if (id in state.entities) {\n            updated.push({\n                id,\n                changes: entity\n            });\n        } else {\n            added.push(entity);\n        }\n    }\n    return [\n        added,\n        updated\n    ];\n}\n// src/entities/unsorted_state_adapter.ts\nfunction createUnsortedStateAdapter(selectId) {\n    function addOneMutably(entity, state) {\n        const key = selectIdValue(entity, selectId);\n        if (key in state.entities) {\n            return;\n        }\n        state.ids.push(key);\n        state.entities[key] = entity;\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for (const entity of newEntities){\n            addOneMutably(entity, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        const key = selectIdValue(entity, selectId);\n        if (!(key in state.entities)) {\n            state.ids.push(key);\n        }\n        ;\n        state.entities[key] = entity;\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for (const entity of newEntities){\n            setOneMutably(entity, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.ids = [];\n        state.entities = {};\n        addManyMutably(newEntities, state);\n    }\n    function removeOneMutably(key, state) {\n        return removeManyMutably([\n            key\n        ], state);\n    }\n    function removeManyMutably(keys, state) {\n        let didMutate = false;\n        keys.forEach((key)=>{\n            if (key in state.entities) {\n                delete state.entities[key];\n                didMutate = true;\n            }\n        });\n        if (didMutate) {\n            state.ids = state.ids.filter((id)=>id in state.entities);\n        }\n    }\n    function removeAllMutably(state) {\n        Object.assign(state, {\n            ids: [],\n            entities: {}\n        });\n    }\n    function takeNewKey(keys, update, state) {\n        const original3 = state.entities[update.id];\n        if (original3 === void 0) {\n            return false;\n        }\n        const updated = Object.assign({}, original3, update.changes);\n        const newKey = selectIdValue(updated, selectId);\n        const hasNewKey = newKey !== update.id;\n        if (hasNewKey) {\n            keys[update.id] = newKey;\n            delete state.entities[update.id];\n        }\n        ;\n        state.entities[newKey] = updated;\n        return hasNewKey;\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        const newKeys = {};\n        const updatesPerEntity = {};\n        updates.forEach((update)=>{\n            if (update.id in state.entities) {\n                updatesPerEntity[update.id] = {\n                    id: update.id,\n                    // Spreads ignore falsy values, so this works even if there isn't\n                    // an existing update already at this key\n                    changes: {\n                        ...updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null,\n                        ...update.changes\n                    }\n                };\n            }\n        });\n        updates = Object.values(updatesPerEntity);\n        const didMutateEntities = updates.length > 0;\n        if (didMutateEntities) {\n            const didMutateIds = updates.filter((update)=>takeNewKey(newKeys, update, state)).length > 0;\n            if (didMutateIds) {\n                state.ids = Object.values(state.entities).map((e)=>selectIdValue(e, selectId));\n            }\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    return {\n        removeAll: createSingleArgumentStateOperator(removeAllMutably),\n        addOne: createStateOperator(addOneMutably),\n        addMany: createStateOperator(addManyMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        upsertMany: createStateOperator(upsertManyMutably),\n        removeOne: createStateOperator(removeOneMutably),\n        removeMany: createStateOperator(removeManyMutably)\n    };\n}\n// src/entities/sorted_state_adapter.ts\nfunction createSortedStateAdapter(selectId, sort) {\n    const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(selectId);\n    function addOneMutably(entity, state) {\n        return addManyMutably([\n            entity\n        ], state);\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        const models = newEntities.filter((model)=>!(selectIdValue(model, selectId) in state.entities));\n        if (models.length !== 0) {\n            merge(models, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        return setManyMutably([\n            entity\n        ], state);\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        if (newEntities.length !== 0) {\n            merge(newEntities, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.entities = {};\n        state.ids = [];\n        addManyMutably(newEntities, state);\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        let appliedUpdates = false;\n        for (let update of updates){\n            const entity = state.entities[update.id];\n            if (!entity) {\n                continue;\n            }\n            appliedUpdates = true;\n            Object.assign(entity, update.changes);\n            const newId = selectId(entity);\n            if (update.id !== newId) {\n                delete state.entities[update.id];\n                state.entities[newId] = entity;\n            }\n        }\n        if (appliedUpdates) {\n            resortEntities(state);\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    function areArraysEqual(a, b) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(let i = 0; i < a.length && i < b.length; i++){\n            if (a[i] === b[i]) {\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    function merge(models, state) {\n        models.forEach((model)=>{\n            ;\n            state.entities[selectId(model)] = model;\n        });\n        resortEntities(state);\n    }\n    function resortEntities(state) {\n        const allEntities = Object.values(state.entities);\n        allEntities.sort(sort);\n        const newSortedIds = allEntities.map(selectId);\n        const { ids } = state;\n        if (!areArraysEqual(ids, newSortedIds)) {\n            state.ids = newSortedIds;\n        }\n    }\n    return {\n        removeOne,\n        removeMany,\n        removeAll,\n        addOne: createStateOperator(addOneMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        addMany: createStateOperator(addManyMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertMany: createStateOperator(upsertManyMutably)\n    };\n}\n// src/entities/create_adapter.ts\nfunction createEntityAdapter(options = {}) {\n    const { selectId, sortComparer } = {\n        sortComparer: false,\n        selectId: (instance)=>instance.id,\n        ...options\n    };\n    const stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n    const stateFactory = createInitialStateFactory(stateAdapter);\n    const selectorsFactory = createSelectorsFactory();\n    return {\n        selectId,\n        sortComparer,\n        ...stateFactory,\n        ...selectorsFactory,\n        ...stateAdapter\n    };\n}\n// src/listenerMiddleware/index.ts\nvar import_redux5 = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/cjs/redux.cjs\");\n// src/listenerMiddleware/exceptions.ts\nvar task = \"task\";\nvar listener = \"listener\";\nvar completed = \"completed\";\nvar cancelled = \"cancelled\";\nvar taskCancelled = `task-${cancelled}`;\nvar taskCompleted = `task-${completed}`;\nvar listenerCancelled = `${listener}-${cancelled}`;\nvar listenerCompleted = `${listener}-${completed}`;\nvar TaskAbortError = class {\n    constructor(code){\n        this.name = \"TaskAbortError\";\n        this.code = code;\n        this.message = `${task} ${cancelled} (reason: ${code})`;\n    }\n};\n// src/listenerMiddleware/utils.ts\nvar assertFunction = (func, expected)=>{\n    if (typeof func !== \"function\") {\n        throw new Error( false ? 0 : `${expected} is not a function`);\n    }\n};\nvar noop2 = ()=>{};\nvar catchRejection = (promise, onError = noop2)=>{\n    promise.catch(onError);\n    return promise;\n};\nvar addAbortSignalListener = (abortSignal, callback)=>{\n    abortSignal.addEventListener(\"abort\", callback, {\n        once: true\n    });\n    return ()=>abortSignal.removeEventListener(\"abort\", callback);\n};\nvar abortControllerWithReason = (abortController, reason)=>{\n    const signal = abortController.signal;\n    if (signal.aborted) {\n        return;\n    }\n    if (!(\"reason\" in signal)) {\n        Object.defineProperty(signal, \"reason\", {\n            enumerable: true,\n            value: reason,\n            configurable: true,\n            writable: true\n        });\n    }\n    ;\n    abortController.abort(reason);\n};\n// src/listenerMiddleware/task.ts\nvar validateActive = (signal)=>{\n    if (signal.aborted) {\n        const { reason } = signal;\n        throw new TaskAbortError(reason);\n    }\n};\nfunction raceWithSignal(signal, promise) {\n    let cleanup = noop2;\n    return new Promise((resolve, reject)=>{\n        const notifyRejection = ()=>reject(new TaskAbortError(signal.reason));\n        if (signal.aborted) {\n            notifyRejection();\n            return;\n        }\n        cleanup = addAbortSignalListener(signal, notifyRejection);\n        promise.finally(()=>cleanup()).then(resolve, reject);\n    }).finally(()=>{\n        cleanup = noop2;\n    });\n}\nvar runTask = async (task2, cleanUp)=>{\n    try {\n        await Promise.resolve();\n        const value = await task2();\n        return {\n            status: \"ok\",\n            value\n        };\n    } catch (error) {\n        return {\n            status: error instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\n            error\n        };\n    } finally{\n        cleanUp?.();\n    }\n};\nvar createPause = (signal)=>{\n    return (promise)=>{\n        return catchRejection(raceWithSignal(signal, promise).then((output)=>{\n            validateActive(signal);\n            return output;\n        }));\n    };\n};\nvar createDelay = (signal)=>{\n    const pause = createPause(signal);\n    return (timeoutMs)=>{\n        return pause(new Promise((resolve)=>setTimeout(resolve, timeoutMs)));\n    };\n};\n// src/listenerMiddleware/index.ts\nvar { assign } = Object;\nvar INTERNAL_NIL_TOKEN = {};\nvar alm = \"listenerMiddleware\";\nvar createFork = (parentAbortSignal, parentBlockingPromises)=>{\n    const linkControllers = (controller)=>addAbortSignalListener(parentAbortSignal, ()=>abortControllerWithReason(controller, parentAbortSignal.reason));\n    return (taskExecutor, opts)=>{\n        assertFunction(taskExecutor, \"taskExecutor\");\n        const childAbortController = new AbortController();\n        linkControllers(childAbortController);\n        const result = runTask(async ()=>{\n            validateActive(parentAbortSignal);\n            validateActive(childAbortController.signal);\n            const result2 = await taskExecutor({\n                pause: createPause(childAbortController.signal),\n                delay: createDelay(childAbortController.signal),\n                signal: childAbortController.signal\n            });\n            validateActive(childAbortController.signal);\n            return result2;\n        }, ()=>abortControllerWithReason(childAbortController, taskCompleted));\n        if (opts?.autoJoin) {\n            parentBlockingPromises.push(result.catch(noop2));\n        }\n        return {\n            result: createPause(parentAbortSignal)(result),\n            cancel () {\n                abortControllerWithReason(childAbortController, taskCancelled);\n            }\n        };\n    };\n};\nvar createTakePattern = (startListening, signal)=>{\n    const take = async (predicate, timeout)=>{\n        validateActive(signal);\n        let unsubscribe = ()=>{};\n        const tuplePromise = new Promise((resolve, reject)=>{\n            let stopListening = startListening({\n                predicate,\n                effect: (action, listenerApi)=>{\n                    listenerApi.unsubscribe();\n                    resolve([\n                        action,\n                        listenerApi.getState(),\n                        listenerApi.getOriginalState()\n                    ]);\n                }\n            });\n            unsubscribe = ()=>{\n                stopListening();\n                reject();\n            };\n        });\n        const promises = [\n            tuplePromise\n        ];\n        if (timeout != null) {\n            promises.push(new Promise((resolve)=>setTimeout(resolve, timeout, null)));\n        }\n        try {\n            const output = await raceWithSignal(signal, Promise.race(promises));\n            validateActive(signal);\n            return output;\n        } finally{\n            unsubscribe();\n        }\n    };\n    return (predicate, timeout)=>catchRejection(take(predicate, timeout));\n};\nvar getListenerEntryPropsFrom = (options)=>{\n    let { type, actionCreator, matcher, predicate, effect } = options;\n    if (type) {\n        predicate = createAction(type).match;\n    } else if (actionCreator) {\n        type = actionCreator.type;\n        predicate = actionCreator.match;\n    } else if (matcher) {\n        predicate = matcher;\n    } else if (predicate) {} else {\n        throw new Error( false ? 0 : \"Creating or removing a listener requires one of the known fields for matching an action\");\n    }\n    assertFunction(effect, \"options.listener\");\n    return {\n        predicate,\n        type,\n        effect\n    };\n};\nvar createListenerEntry = Object.assign((options)=>{\n    const { type, predicate, effect } = getListenerEntryPropsFrom(options);\n    const id = nanoid();\n    const entry = {\n        id,\n        effect,\n        type,\n        predicate,\n        pending: /* @__PURE__ */ new Set(),\n        unsubscribe: ()=>{\n            throw new Error( false ? 0 : \"Unsubscribe not initialized\");\n        }\n    };\n    return entry;\n}, {\n    withTypes: ()=>createListenerEntry\n});\nvar cancelActiveListeners = (entry)=>{\n    entry.pending.forEach((controller)=>{\n        abortControllerWithReason(controller, listenerCancelled);\n    });\n};\nvar createClearListenerMiddleware = (listenerMap)=>{\n    return ()=>{\n        listenerMap.forEach(cancelActiveListeners);\n        listenerMap.clear();\n    };\n};\nvar safelyNotifyError = (errorHandler, errorToNotify, errorInfo)=>{\n    try {\n        errorHandler(errorToNotify, errorInfo);\n    } catch (errorHandlerError) {\n        setTimeout(()=>{\n            throw errorHandlerError;\n        }, 0);\n    }\n};\nvar addListener = Object.assign(createAction(`${alm}/add`), {\n    withTypes: ()=>addListener\n});\nvar clearAllListeners = createAction(`${alm}/removeAll`);\nvar removeListener = Object.assign(createAction(`${alm}/remove`), {\n    withTypes: ()=>removeListener\n});\nvar defaultErrorHandler = (...args)=>{\n    console.error(`${alm}/error`, ...args);\n};\nvar createListenerMiddleware = (middlewareOptions = {})=>{\n    const listenerMap = /* @__PURE__ */ new Map();\n    const { extra, onError = defaultErrorHandler } = middlewareOptions;\n    assertFunction(onError, \"onError\");\n    const insertEntry = (entry)=>{\n        entry.unsubscribe = ()=>listenerMap.delete(entry.id);\n        listenerMap.set(entry.id, entry);\n        return (cancelOptions)=>{\n            entry.unsubscribe();\n            if (cancelOptions?.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        };\n    };\n    const startListening = (options)=>{\n        let entry = find(Array.from(listenerMap.values()), (existingEntry)=>existingEntry.effect === options.effect);\n        if (!entry) {\n            entry = createListenerEntry(options);\n        }\n        return insertEntry(entry);\n    };\n    Object.assign(startListening, {\n        withTypes: ()=>startListening\n    });\n    const stopListening = (options)=>{\n        const { type, effect, predicate } = getListenerEntryPropsFrom(options);\n        const entry = find(Array.from(listenerMap.values()), (entry2)=>{\n            const matchPredicateOrType = typeof type === \"string\" ? entry2.type === type : entry2.predicate === predicate;\n            return matchPredicateOrType && entry2.effect === effect;\n        });\n        if (entry) {\n            entry.unsubscribe();\n            if (options.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        }\n        return !!entry;\n    };\n    Object.assign(stopListening, {\n        withTypes: ()=>stopListening\n    });\n    const notifyListener = async (entry, action, api, getOriginalState)=>{\n        const internalTaskController = new AbortController();\n        const take = createTakePattern(startListening, internalTaskController.signal);\n        const autoJoinPromises = [];\n        try {\n            entry.pending.add(internalTaskController);\n            await Promise.resolve(entry.effect(action, // Use assign() rather than ... to avoid extra helper functions added to bundle\n            assign({}, api, {\n                getOriginalState,\n                condition: (predicate, timeout)=>take(predicate, timeout).then(Boolean),\n                take,\n                delay: createDelay(internalTaskController.signal),\n                pause: createPause(internalTaskController.signal),\n                extra,\n                signal: internalTaskController.signal,\n                fork: createFork(internalTaskController.signal, autoJoinPromises),\n                unsubscribe: entry.unsubscribe,\n                subscribe: ()=>{\n                    listenerMap.set(entry.id, entry);\n                },\n                cancelActiveListeners: ()=>{\n                    entry.pending.forEach((controller, _, set)=>{\n                        if (controller !== internalTaskController) {\n                            abortControllerWithReason(controller, listenerCancelled);\n                            set.delete(controller);\n                        }\n                    });\n                },\n                cancel: ()=>{\n                    abortControllerWithReason(internalTaskController, listenerCancelled);\n                    entry.pending.delete(internalTaskController);\n                },\n                throwIfCancelled: ()=>{\n                    validateActive(internalTaskController.signal);\n                }\n            })));\n        } catch (listenerError) {\n            if (!(listenerError instanceof TaskAbortError)) {\n                safelyNotifyError(onError, listenerError, {\n                    raisedBy: \"effect\"\n                });\n            }\n        } finally{\n            await Promise.all(autoJoinPromises);\n            abortControllerWithReason(internalTaskController, listenerCompleted);\n            entry.pending.delete(internalTaskController);\n        }\n    };\n    const clearListenerMiddleware = createClearListenerMiddleware(listenerMap);\n    const middleware = (api)=>(next)=>(action)=>{\n                if (!(0, import_redux5.isAction)(action)) {\n                    return next(action);\n                }\n                if (addListener.match(action)) {\n                    return startListening(action.payload);\n                }\n                if (clearAllListeners.match(action)) {\n                    clearListenerMiddleware();\n                    return;\n                }\n                if (removeListener.match(action)) {\n                    return stopListening(action.payload);\n                }\n                let originalState = api.getState();\n                const getOriginalState = ()=>{\n                    if (originalState === INTERNAL_NIL_TOKEN) {\n                        throw new Error( false ? 0 : `${alm}: getOriginalState can only be called synchronously`);\n                    }\n                    return originalState;\n                };\n                let result;\n                try {\n                    result = next(action);\n                    if (listenerMap.size > 0) {\n                        const currentState = api.getState();\n                        const listenerEntries = Array.from(listenerMap.values());\n                        for (const entry of listenerEntries){\n                            let runListener = false;\n                            try {\n                                runListener = entry.predicate(action, currentState, originalState);\n                            } catch (predicateError) {\n                                runListener = false;\n                                safelyNotifyError(onError, predicateError, {\n                                    raisedBy: \"predicate\"\n                                });\n                            }\n                            if (!runListener) {\n                                continue;\n                            }\n                            notifyListener(entry, action, api, getOriginalState);\n                        }\n                    }\n                } finally{\n                    originalState = INTERNAL_NIL_TOKEN;\n                }\n                return result;\n            };\n    return {\n        middleware,\n        startListening,\n        stopListening,\n        clearListeners: clearListenerMiddleware\n    };\n};\n// src/dynamicMiddleware/index.ts\nvar import_redux6 = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/cjs/redux.cjs\");\nvar createMiddlewareEntry = (middleware)=>({\n        id: nanoid(),\n        middleware,\n        applied: /* @__PURE__ */ new Map()\n    });\nvar matchInstance = (instanceId)=>(action)=>action?.meta?.instanceId === instanceId;\nvar createDynamicMiddleware = ()=>{\n    const instanceId = nanoid();\n    const middlewareMap = /* @__PURE__ */ new Map();\n    const withMiddleware = Object.assign(createAction(\"dynamicMiddleware/add\", (...middlewares)=>({\n            payload: middlewares,\n            meta: {\n                instanceId\n            }\n        })), {\n        withTypes: ()=>withMiddleware\n    });\n    const addMiddleware = Object.assign(function addMiddleware2(...middlewares) {\n        middlewares.forEach((middleware2)=>{\n            let entry = find(Array.from(middlewareMap.values()), (entry2)=>entry2.middleware === middleware2);\n            if (!entry) {\n                entry = createMiddlewareEntry(middleware2);\n            }\n            middlewareMap.set(entry.id, entry);\n        });\n    }, {\n        withTypes: ()=>addMiddleware\n    });\n    const getFinalMiddleware = (api)=>{\n        const appliedMiddleware = Array.from(middlewareMap.values()).map((entry)=>emplace(entry.applied, api, {\n                insert: ()=>entry.middleware(api)\n            }));\n        return (0, import_redux6.compose)(...appliedMiddleware);\n    };\n    const isWithMiddleware = isAllOf(withMiddleware, matchInstance(instanceId));\n    const middleware = (api)=>(next)=>(action)=>{\n                if (isWithMiddleware(action)) {\n                    addMiddleware(...action.payload);\n                    return api.dispatch;\n                }\n                return getFinalMiddleware(api)(next)(action);\n            };\n    return {\n        middleware,\n        addMiddleware,\n        withMiddleware,\n        instanceId\n    };\n};\n// src/combineSlices.ts\nvar import_redux7 = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/cjs/redux.cjs\");\nvar isSliceLike = (maybeSliceLike)=>\"reducerPath\" in maybeSliceLike && typeof maybeSliceLike.reducerPath === \"string\";\nvar getReducers = (slices)=>slices.flatMap((sliceOrMap)=>isSliceLike(sliceOrMap) ? [\n            [\n                sliceOrMap.reducerPath,\n                sliceOrMap.reducer\n            ]\n        ] : Object.entries(sliceOrMap));\nvar ORIGINAL_STATE = Symbol.for(\"rtk-state-proxy-original\");\nvar isStateProxy = (value)=>!!value && !!value[ORIGINAL_STATE];\nvar stateProxyMap = /* @__PURE__ */ new WeakMap();\nvar createStateProxy = (state, reducerMap)=>emplace(stateProxyMap, state, {\n        insert: ()=>new Proxy(state, {\n                get: (target, prop, receiver)=>{\n                    if (prop === ORIGINAL_STATE) return target;\n                    const result = Reflect.get(target, prop, receiver);\n                    if (typeof result === \"undefined\") {\n                        const reducer = reducerMap[prop.toString()];\n                        if (reducer) {\n                            const reducerResult = reducer(void 0, {\n                                type: nanoid()\n                            });\n                            if (typeof reducerResult === \"undefined\") {\n                                throw new Error( false ? 0 : `The slice reducer for key \"${prop.toString()}\" returned undefined when called for selector(). If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);\n                            }\n                            return reducerResult;\n                        }\n                    }\n                    return result;\n                }\n            })\n    });\nvar original = (state)=>{\n    if (!isStateProxy(state)) {\n        throw new Error( false ? 0 : \"original must be used on state Proxy\");\n    }\n    return state[ORIGINAL_STATE];\n};\nvar noopReducer = (state = {})=>state;\nfunction combineSlices(...slices) {\n    const reducerMap = Object.fromEntries(getReducers(slices));\n    const getReducer = ()=>Object.keys(reducerMap).length ? (0, import_redux7.combineReducers)(reducerMap) : noopReducer;\n    let reducer = getReducer();\n    function combinedReducer(state, action) {\n        return reducer(state, action);\n    }\n    combinedReducer.withLazyLoadedSlices = ()=>combinedReducer;\n    const inject = (slice, config = {})=>{\n        const { reducerPath, reducer: reducerToInject } = slice;\n        const currentReducer = reducerMap[reducerPath];\n        if (!config.overrideExisting && currentReducer && currentReducer !== reducerToInject) {\n            if (typeof process !== \"undefined\" && true) {\n                console.error(`called \\`inject\\` to override already-existing reducer ${reducerPath} without specifying \\`overrideExisting: true\\``);\n            }\n            return combinedReducer;\n        }\n        reducerMap[reducerPath] = reducerToInject;\n        reducer = getReducer();\n        return combinedReducer;\n    };\n    const selector = Object.assign(function makeSelector(selectorFn, selectState) {\n        return function selector2(state, ...args) {\n            return selectorFn(createStateProxy(selectState ? selectState(state, ...args) : state, reducerMap), ...args);\n        };\n    }, {\n        original\n    });\n    return Object.assign(combinedReducer, {\n        inject,\n        selector\n    });\n}\n// src/formatProdErrorMessage.ts\nfunction formatProdErrorMessage(code) {\n    return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;\n} //# sourceMappingURL=redux-toolkit.development.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L2Nqcy9yZWR1eC10b29sa2l0LmRldmVsb3BtZW50LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsbUJBQW1CRixPQUFPRyx3QkFBd0I7QUFDdEQsSUFBSUMsb0JBQW9CSixPQUFPSyxtQkFBbUI7QUFDbEQsSUFBSUMsZUFBZU4sT0FBT08sU0FBUyxDQUFDQyxjQUFjO0FBQ2xELElBQUlDLFdBQVcsQ0FBQ0MsUUFBUUM7SUFDdEIsSUFBSyxJQUFJQyxRQUFRRCxJQUNmWixVQUFVVyxRQUFRRSxNQUFNO1FBQUVDLEtBQUtGLEdBQUcsQ0FBQ0MsS0FBSztRQUFFRSxZQUFZO0lBQUs7QUFDL0Q7QUFDQSxJQUFJQyxjQUFjLENBQUNDLElBQUlDLE1BQU1DLFFBQVFDO0lBQ25DLElBQUlGLFFBQVEsT0FBT0EsU0FBUyxZQUFZLE9BQU9BLFNBQVMsWUFBWTtRQUNsRSxLQUFLLElBQUlHLE9BQU9oQixrQkFBa0JhLE1BQ2hDLElBQUksQ0FBQ1gsYUFBYWUsSUFBSSxDQUFDTCxJQUFJSSxRQUFRQSxRQUFRRixRQUN6Q25CLFVBQVVpQixJQUFJSSxLQUFLO1lBQUVQLEtBQUssSUFBTUksSUFBSSxDQUFDRyxJQUFJO1lBQUVOLFlBQVksQ0FBRUssQ0FBQUEsT0FBT2pCLGlCQUFpQmUsTUFBTUcsSUFBRyxLQUFNRCxLQUFLTCxVQUFVO1FBQUM7SUFDdEg7SUFDQSxPQUFPRTtBQUNUO0FBQ0EsSUFBSU0sYUFBYSxDQUFDWixRQUFRYSxLQUFLQyxlQUFrQlQsQ0FBQUEsWUFBWUwsUUFBUWEsS0FBSyxZQUFZQyxnQkFBZ0JULFlBQVlTLGNBQWNELEtBQUssVUFBUztBQUM5SSxJQUFJRSxlQUFlLENBQUNGLE1BQVFSLFlBQVloQixVQUFVLENBQUMsR0FBRyxjQUFjO1FBQUUyQixPQUFPO0lBQUssSUFBSUg7QUFFdEYsZUFBZTtBQUNmLElBQUlJ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Oi8vd29ya2Zsb3cvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L2Nqcy9yZWR1eC10b29sa2l0LmRldmVsb3BtZW50LmNqcz84MzEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZCwgc2Vjb25kVGFyZ2V0KSA9PiAoX19jb3B5UHJvcHModGFyZ2V0LCBtb2QsIFwiZGVmYXVsdFwiKSwgc2Vjb25kVGFyZ2V0ICYmIF9fY29weVByb3BzKHNlY29uZFRhcmdldCwgbW9kLCBcImRlZmF1bHRcIikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIHNyY19leHBvcnRzID0ge307XG5fX2V4cG9ydChzcmNfZXhwb3J0cywge1xuICBSZWR1Y2VyVHlwZTogKCkgPT4gUmVkdWNlclR5cGUsXG4gIFNIT1VMRF9BVVRPQkFUQ0g6ICgpID0+IFNIT1VMRF9BVVRPQkFUQ0gsXG4gIFRhc2tBYm9ydEVycm9yOiAoKSA9PiBUYXNrQWJvcnRFcnJvcixcbiAgVHVwbGU6ICgpID0+IFR1cGxlLFxuICBhZGRMaXN0ZW5lcjogKCkgPT4gYWRkTGlzdGVuZXIsXG4gIGFzeW5jVGh1bmtDcmVhdG9yOiAoKSA9PiBhc3luY1RodW5rQ3JlYXRvcixcbiAgYXV0b0JhdGNoRW5oYW5jZXI6ICgpID0+IGF1dG9CYXRjaEVuaGFuY2VyLFxuICBidWlsZENyZWF0ZVNsaWNlOiAoKSA9PiBidWlsZENyZWF0ZVNsaWNlLFxuICBjbGVhckFsbExpc3RlbmVyczogKCkgPT4gY2xlYXJBbGxMaXN0ZW5lcnMsXG4gIGNvbWJpbmVTbGljZXM6ICgpID0+IGNvbWJpbmVTbGljZXMsXG4gIGNvbmZpZ3VyZVN0b3JlOiAoKSA9PiBjb25maWd1cmVTdG9yZSxcbiAgY3JlYXRlQWN0aW9uOiAoKSA9PiBjcmVhdGVBY3Rpb24sXG4gIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlOiAoKSA9PiBjcmVhdGVBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZSxcbiAgY3JlYXRlQXN5bmNUaHVuazogKCkgPT4gY3JlYXRlQXN5bmNUaHVuayxcbiAgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3I6ICgpID0+IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yLFxuICBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3I6ICgpID0+IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvcixcbiAgY3JlYXRlRHluYW1pY01pZGRsZXdhcmU6ICgpID0+IGNyZWF0ZUR5bmFtaWNNaWRkbGV3YXJlLFxuICBjcmVhdGVFbnRpdHlBZGFwdGVyOiAoKSA9PiBjcmVhdGVFbnRpdHlBZGFwdGVyLFxuICBjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmU6ICgpID0+IGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSxcbiAgY3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlOiAoKSA9PiBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUsXG4gIGNyZWF0ZU5leHRTdGF0ZTogKCkgPT4gaW1wb3J0X2ltbWVyNS5wcm9kdWNlLFxuICBjcmVhdGVSZWR1Y2VyOiAoKSA9PiBjcmVhdGVSZWR1Y2VyLFxuICBjcmVhdGVTZWxlY3RvcjogKCkgPT4gaW1wb3J0X3Jlc2VsZWN0Mi5jcmVhdGVTZWxlY3RvcixcbiAgY3JlYXRlU2VsZWN0b3JDcmVhdG9yOiAoKSA9PiBpbXBvcnRfcmVzZWxlY3QyLmNyZWF0ZVNlbGVjdG9yQ3JlYXRvcixcbiAgY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlOiAoKSA9PiBjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUsXG4gIGNyZWF0ZVNsaWNlOiAoKSA9PiBjcmVhdGVTbGljZSxcbiAgY3VycmVudDogKCkgPT4gaW1wb3J0X2ltbWVyNS5jdXJyZW50LFxuICBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWU6ICgpID0+IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSxcbiAgZm9ybWF0UHJvZEVycm9yTWVzc2FnZTogKCkgPT4gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSxcbiAgZnJlZXplOiAoKSA9PiBpbXBvcnRfaW1tZXI1LmZyZWV6ZSxcbiAgaXNBY3Rpb25DcmVhdG9yOiAoKSA9PiBpc0FjdGlvbkNyZWF0b3IsXG4gIGlzQWxsT2Y6ICgpID0+IGlzQWxsT2YsXG4gIGlzQW55T2Y6ICgpID0+IGlzQW55T2YsXG4gIGlzQXN5bmNUaHVua0FjdGlvbjogKCkgPT4gaXNBc3luY1RodW5rQWN0aW9uLFxuICBpc0RyYWZ0OiAoKSA9PiBpbXBvcnRfaW1tZXI1LmlzRHJhZnQsXG4gIGlzRmx1eFN0YW5kYXJkQWN0aW9uOiAoKSA9PiBpc0ZTQSxcbiAgaXNGdWxmaWxsZWQ6ICgpID0+IGlzRnVsZmlsbGVkLFxuICBpc0ltbXV0YWJsZURlZmF1bHQ6ICgpID0+IGlzSW1tdXRhYmxlRGVmYXVsdCxcbiAgaXNQZW5kaW5nOiAoKSA9PiBpc1BlbmRpbmcsXG4gIGlzUGxhaW46ICgpID0+IGlzUGxhaW4sXG4gIGlzUmVqZWN0ZWQ6ICgpID0+IGlzUmVqZWN0ZWQsXG4gIGlzUmVqZWN0ZWRXaXRoVmFsdWU6ICgpID0+IGlzUmVqZWN0ZWRXaXRoVmFsdWUsXG4gIGxydU1lbW9pemU6ICgpID0+IGltcG9ydF9yZXNlbGVjdDIubHJ1TWVtb2l6ZSxcbiAgbWluaVNlcmlhbGl6ZUVycm9yOiAoKSA9PiBtaW5pU2VyaWFsaXplRXJyb3IsXG4gIG5hbm9pZDogKCkgPT4gbmFub2lkLFxuICBvcmlnaW5hbDogKCkgPT4gaW1wb3J0X2ltbWVyNS5vcmlnaW5hbCxcbiAgcHJlcGFyZUF1dG9CYXRjaGVkOiAoKSA9PiBwcmVwYXJlQXV0b0JhdGNoZWQsXG4gIHJlbW92ZUxpc3RlbmVyOiAoKSA9PiByZW1vdmVMaXN0ZW5lcixcbiAgdW53cmFwUmVzdWx0OiAoKSA9PiB1bndyYXBSZXN1bHQsXG4gIHdlYWtNYXBNZW1vaXplOiAoKSA9PiBpbXBvcnRfcmVzZWxlY3QyLndlYWtNYXBNZW1vaXplXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHNyY19leHBvcnRzKTtcbl9fcmVFeHBvcnQoc3JjX2V4cG9ydHMsIHJlcXVpcmUoXCJyZWR1eFwiKSwgbW9kdWxlLmV4cG9ydHMpO1xudmFyIGltcG9ydF9pbW1lcjUgPSByZXF1aXJlKFwiaW1tZXJcIik7XG52YXIgaW1wb3J0X3Jlc2VsZWN0MiA9IHJlcXVpcmUoXCJyZXNlbGVjdFwiKTtcblxuLy8gc3JjL2NyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yLnRzXG52YXIgaW1wb3J0X2ltbWVyID0gcmVxdWlyZShcImltbWVyXCIpO1xudmFyIGltcG9ydF9yZXNlbGVjdCA9IHJlcXVpcmUoXCJyZXNlbGVjdFwiKTtcbnZhciBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3IgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBjcmVhdGVTZWxlY3RvcjIgPSAoMCwgaW1wb3J0X3Jlc2VsZWN0LmNyZWF0ZVNlbGVjdG9yQ3JlYXRvcikoLi4uYXJncyk7XG4gIGNvbnN0IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yMiA9IE9iamVjdC5hc3NpZ24oKC4uLmFyZ3MyKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBjcmVhdGVTZWxlY3RvcjIoLi4uYXJnczIpO1xuICAgIGNvbnN0IHdyYXBwZWRTZWxlY3RvciA9ICh2YWx1ZSwgLi4ucmVzdCkgPT4gc2VsZWN0b3IoKDAsIGltcG9ydF9pbW1lci5pc0RyYWZ0KSh2YWx1ZSkgPyAoMCwgaW1wb3J0X2ltbWVyLmN1cnJlbnQpKHZhbHVlKSA6IHZhbHVlLCAuLi5yZXN0KTtcbiAgICBPYmplY3QuYXNzaWduKHdyYXBwZWRTZWxlY3Rvciwgc2VsZWN0b3IpO1xuICAgIHJldHVybiB3cmFwcGVkU2VsZWN0b3I7XG4gIH0sIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yMlxuICB9KTtcbiAgcmV0dXJuIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yMjtcbn07XG52YXIgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IgPSBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3IoaW1wb3J0X3Jlc2VsZWN0LndlYWtNYXBNZW1vaXplKTtcblxuLy8gc3JjL2NvbmZpZ3VyZVN0b3JlLnRzXG52YXIgaW1wb3J0X3JlZHV4NCA9IHJlcXVpcmUoXCJyZWR1eFwiKTtcblxuLy8gc3JjL2RldnRvb2xzRXh0ZW5zaW9uLnRzXG52YXIgaW1wb3J0X3JlZHV4ID0gcmVxdWlyZShcInJlZHV4XCIpO1xudmFyIGNvbXBvc2VXaXRoRGV2VG9vbHMgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIDogZnVuY3Rpb24oKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBpbXBvcnRfcmVkdXguY29tcG9zZTtcbiAgcmV0dXJuIGltcG9ydF9yZWR1eC5jb21wb3NlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xudmFyIGRldlRvb2xzRW5oYW5jZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fID8gd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18gOiBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG5vb3AzKSB7XG4gICAgcmV0dXJuIG5vb3AzO1xuICB9O1xufTtcblxuLy8gc3JjL2dldERlZmF1bHRNaWRkbGV3YXJlLnRzXG52YXIgaW1wb3J0X3JlZHV4X3RodW5rID0gcmVxdWlyZShcInJlZHV4LXRodW5rXCIpO1xuXG4vLyBzcmMvY3JlYXRlQWN0aW9uLnRzXG52YXIgaW1wb3J0X3JlZHV4MiA9IHJlcXVpcmUoXCJyZWR1eFwiKTtcblxuLy8gc3JjL3RzSGVscGVycy50c1xudmFyIGhhc01hdGNoRnVuY3Rpb24gPSAodikgPT4ge1xuICByZXR1cm4gdiAmJiB0eXBlb2Ygdi5tYXRjaCA9PT0gXCJmdW5jdGlvblwiO1xufTtcblxuLy8gc3JjL2NyZWF0ZUFjdGlvbi50c1xuZnVuY3Rpb24gY3JlYXRlQWN0aW9uKHR5cGUsIHByZXBhcmVBY3Rpb24pIHtcbiAgZnVuY3Rpb24gYWN0aW9uQ3JlYXRvciguLi5hcmdzKSB7XG4gICAgaWYgKHByZXBhcmVBY3Rpb24pIHtcbiAgICAgIGxldCBwcmVwYXJlZCA9IHByZXBhcmVBY3Rpb24oLi4uYXJncyk7XG4gICAgICBpZiAoIXByZXBhcmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmYWxzZSA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDApIDogXCJwcmVwYXJlQWN0aW9uIGRpZCBub3QgcmV0dXJuIGFuIG9iamVjdFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHBheWxvYWQ6IHByZXBhcmVkLnBheWxvYWQsXG4gICAgICAgIC4uLlwibWV0YVwiIGluIHByZXBhcmVkICYmIHtcbiAgICAgICAgICBtZXRhOiBwcmVwYXJlZC5tZXRhXG4gICAgICAgIH0sXG4gICAgICAgIC4uLlwiZXJyb3JcIiBpbiBwcmVwYXJlZCAmJiB7XG4gICAgICAgICAgZXJyb3I6IHByZXBhcmVkLmVycm9yXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlLFxuICAgICAgcGF5bG9hZDogYXJnc1swXVxuICAgIH07XG4gIH1cbiAgYWN0aW9uQ3JlYXRvci50b1N0cmluZyA9ICgpID0+IGAke3R5cGV9YDtcbiAgYWN0aW9uQ3JlYXRvci50eXBlID0gdHlwZTtcbiAgYWN0aW9uQ3JlYXRvci5tYXRjaCA9IChhY3Rpb24pID0+ICgwLCBpbXBvcnRfcmVkdXgyLmlzQWN0aW9uKShhY3Rpb24pICYmIGFjdGlvbi50eXBlID09PSB0eXBlO1xuICByZXR1cm4gYWN0aW9uQ3JlYXRvcjtcbn1cbmZ1bmN0aW9uIGlzQWN0aW9uQ3JlYXRvcihhY3Rpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiBhY3Rpb24gPT09IFwiZnVuY3Rpb25cIiAmJiBcInR5cGVcIiBpbiBhY3Rpb24gJiYgLy8gaGFzTWF0Y2hGdW5jdGlvbiBvbmx5IHdhbnRzIE1hdGNoZXJzIGJ1dCBJIGRvbid0IHNlZSB0aGUgcG9pbnQgaW4gcmV3cml0aW5nIGl0XG4gIGhhc01hdGNoRnVuY3Rpb24oYWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGlzRlNBKGFjdGlvbikge1xuICByZXR1cm4gKDAsIGltcG9ydF9yZWR1eDIuaXNBY3Rpb24pKGFjdGlvbikgJiYgT2JqZWN0LmtleXMoYWN0aW9uKS5ldmVyeShpc1ZhbGlkS2V5KTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XG4gIHJldHVybiBbXCJ0eXBlXCIsIFwicGF5bG9hZFwiLCBcImVycm9yXCIsIFwibWV0YVwiXS5pbmRleE9mKGtleSkgPiAtMTtcbn1cblxuLy8gc3JjL2FjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBnZXRNZXNzYWdlKHR5cGUpIHtcbiAgY29uc3Qgc3BsaXRUeXBlID0gdHlwZSA/IGAke3R5cGV9YC5zcGxpdChcIi9cIikgOiBbXTtcbiAgY29uc3QgYWN0aW9uTmFtZSA9IHNwbGl0VHlwZVtzcGxpdFR5cGUubGVuZ3RoIC0gMV0gfHwgXCJhY3Rpb25DcmVhdG9yXCI7XG4gIHJldHVybiBgRGV0ZWN0ZWQgYW4gYWN0aW9uIGNyZWF0b3Igd2l0aCB0eXBlIFwiJHt0eXBlIHx8IFwidW5rbm93blwifVwiIGJlaW5nIGRpc3BhdGNoZWQuIFxuTWFrZSBzdXJlIHlvdSdyZSBjYWxsaW5nIHRoZSBhY3Rpb24gY3JlYXRvciBiZWZvcmUgZGlzcGF0Y2hpbmcsIGkuZS4gXFxgZGlzcGF0Y2goJHthY3Rpb25OYW1lfSgpKVxcYCBpbnN0ZWFkIG9mIFxcYGRpc3BhdGNoKCR7YWN0aW9uTmFtZX0pXFxgLiBUaGlzIGlzIG5lY2Vzc2FyeSBldmVuIGlmIHRoZSBhY3Rpb24gaGFzIG5vIHBheWxvYWQuYDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAoZmFsc2UpIHtcbiAgICByZXR1cm4gKCkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IG5leHQoYWN0aW9uKTtcbiAgfVxuICBjb25zdCB7XG4gICAgaXNBY3Rpb25DcmVhdG9yOiBpc0FjdGlvbkNyZWF0b3IyID0gaXNBY3Rpb25DcmVhdG9yXG4gIH0gPSBvcHRpb25zO1xuICByZXR1cm4gKCkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICBpZiAoaXNBY3Rpb25DcmVhdG9yMihhY3Rpb24pKSB7XG4gICAgICBjb25zb2xlLndhcm4oZ2V0TWVzc2FnZShhY3Rpb24udHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICB9O1xufVxuXG4vLyBzcmMvdXRpbHMudHNcbnZhciBpbXBvcnRfaW1tZXIyID0gcmVxdWlyZShcImltbWVyXCIpO1xuZnVuY3Rpb24gZ2V0VGltZU1lYXN1cmVVdGlscyhtYXhEZWxheSwgZm5OYW1lKSB7XG4gIGxldCBlbGFwc2VkID0gMDtcbiAgcmV0dXJuIHtcbiAgICBtZWFzdXJlVGltZShmbikge1xuICAgICAgY29uc3Qgc3RhcnRlZCA9IERhdGUubm93KCk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbnN0IGZpbmlzaGVkID0gRGF0ZS5ub3coKTtcbiAgICAgICAgZWxhcHNlZCArPSBmaW5pc2hlZCAtIHN0YXJ0ZWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXJuSWZFeGNlZWRlZCgpIHtcbiAgICAgIGlmIChlbGFwc2VkID4gbWF4RGVsYXkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGAke2ZuTmFtZX0gdG9vayAke2VsYXBzZWR9bXMsIHdoaWNoIGlzIG1vcmUgdGhhbiB0aGUgd2FybmluZyB0aHJlc2hvbGQgb2YgJHttYXhEZWxheX1tcy4gXG5JZiB5b3VyIHN0YXRlIG9yIGFjdGlvbnMgYXJlIHZlcnkgbGFyZ2UsIHlvdSBtYXkgd2FudCB0byBkaXNhYmxlIHRoZSBtaWRkbGV3YXJlIGFzIGl0IG1pZ2h0IGNhdXNlIHRvbyBtdWNoIG9mIGEgc2xvd2Rvd24gaW4gZGV2ZWxvcG1lbnQgbW9kZS4gU2VlIGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2dldERlZmF1bHRNaWRkbGV3YXJlIGZvciBpbnN0cnVjdGlvbnMuXG5JdCBpcyBkaXNhYmxlZCBpbiBwcm9kdWN0aW9uIGJ1aWxkcywgc28geW91IGRvbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgdGhhdC5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBmaW5kKGl0ZXJhYmxlLCBjb21wYXJhdG9yKSB7XG4gIGZvciAoY29uc3QgZW50cnkgb2YgaXRlcmFibGUpIHtcbiAgICBpZiAoY29tcGFyYXRvcihlbnRyeSkpIHtcbiAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbnZhciBUdXBsZSA9IGNsYXNzIF9UdXBsZSBleHRlbmRzIEFycmF5IHtcbiAgY29uc3RydWN0b3IoLi4uaXRlbXMpIHtcbiAgICBzdXBlciguLi5pdGVtcyk7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIF9UdXBsZS5wcm90b3R5cGUpO1xuICB9XG4gIHN0YXRpYyBnZXQgW1N5bWJvbC5zcGVjaWVzXSgpIHtcbiAgICByZXR1cm4gX1R1cGxlO1xuICB9XG4gIGNvbmNhdCguLi5hcnIpIHtcbiAgICByZXR1cm4gc3VwZXIuY29uY2F0LmFwcGx5KHRoaXMsIGFycik7XG4gIH1cbiAgcHJlcGVuZCguLi5hcnIpIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyclswXSkpIHtcbiAgICAgIHJldHVybiBuZXcgX1R1cGxlKC4uLmFyclswXS5jb25jYXQodGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9UdXBsZSguLi5hcnIuY29uY2F0KHRoaXMpKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGZyZWV6ZURyYWZ0YWJsZSh2YWwpIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfaW1tZXIyLmlzRHJhZnRhYmxlKSh2YWwpID8gKDAsIGltcG9ydF9pbW1lcjIucHJvZHVjZSkodmFsLCAoKSA9PiB7XG4gIH0pIDogdmFsO1xufVxuZnVuY3Rpb24gZW1wbGFjZShtYXAsIGtleSwgaGFuZGxlcikge1xuICBpZiAobWFwLmhhcyhrZXkpKSB7XG4gICAgbGV0IHZhbHVlID0gbWFwLmdldChrZXkpO1xuICAgIGlmIChoYW5kbGVyLnVwZGF0ZSkge1xuICAgICAgdmFsdWUgPSBoYW5kbGVyLnVwZGF0ZSh2YWx1ZSwga2V5LCBtYXApO1xuICAgICAgbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICghaGFuZGxlci5pbnNlcnQpXG4gICAgdGhyb3cgbmV3IEVycm9yKGZhbHNlID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTApIDogXCJObyBpbnNlcnQgcHJvdmlkZWQgZm9yIGtleSBub3QgYWxyZWFkeSBpbiBtYXBcIik7XG4gIGNvbnN0IGluc2VydGVkID0gaGFuZGxlci5pbnNlcnQoa2V5LCBtYXApO1xuICBtYXAuc2V0KGtleSwgaW5zZXJ0ZWQpO1xuICByZXR1cm4gaW5zZXJ0ZWQ7XG59XG5cbi8vIHNyYy9pbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGlzSW1tdXRhYmxlRGVmYXVsdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09IG51bGwgfHwgT2JqZWN0LmlzRnJvemVuKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHRyYWNrRm9yTXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqKSB7XG4gIGNvbnN0IHRyYWNrZWRQcm9wZXJ0aWVzID0gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqKTtcbiAgcmV0dXJuIHtcbiAgICBkZXRlY3RNdXRhdGlvbnMoKSB7XG4gICAgICByZXR1cm4gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgdHJhY2tlZFByb3BlcnRpZXMsIG9iaik7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocyA9IFtdLCBvYmosIHBhdGggPSBcIlwiLCBjaGVja2VkT2JqZWN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpIHtcbiAgY29uc3QgdHJhY2tlZCA9IHtcbiAgICB2YWx1ZTogb2JqXG4gIH07XG4gIGlmICghaXNJbW11dGFibGUob2JqKSAmJiAhY2hlY2tlZE9iamVjdHMuaGFzKG9iaikpIHtcbiAgICBjaGVja2VkT2JqZWN0cy5hZGQob2JqKTtcbiAgICB0cmFja2VkLmNoaWxkcmVuID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xuICAgICAgaWYgKGlnbm9yZVBhdGhzLmxlbmd0aCAmJiBpZ25vcmVQYXRocy5pbmRleE9mKGNoaWxkUGF0aCkgIT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdHJhY2tlZC5jaGlsZHJlbltrZXldID0gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqW2tleV0sIGNoaWxkUGF0aCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmFja2VkO1xufVxuZnVuY3Rpb24gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMgPSBbXSwgdHJhY2tlZFByb3BlcnR5LCBvYmosIHNhbWVQYXJlbnRSZWYgPSBmYWxzZSwgcGF0aCA9IFwiXCIpIHtcbiAgY29uc3QgcHJldk9iaiA9IHRyYWNrZWRQcm9wZXJ0eSA/IHRyYWNrZWRQcm9wZXJ0eS52YWx1ZSA6IHZvaWQgMDtcbiAgY29uc3Qgc2FtZVJlZiA9IHByZXZPYmogPT09IG9iajtcbiAgaWYgKHNhbWVQYXJlbnRSZWYgJiYgIXNhbWVSZWYgJiYgIU51bWJlci5pc05hTihvYmopKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdhc011dGF0ZWQ6IHRydWUsXG4gICAgICBwYXRoXG4gICAgfTtcbiAgfVxuICBpZiAoaXNJbW11dGFibGUocHJldk9iaikgfHwgaXNJbW11dGFibGUob2JqKSkge1xuICAgIHJldHVybiB7XG4gICAgICB3YXNNdXRhdGVkOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY29uc3Qga2V5c1RvRGV0ZWN0ID0ge307XG4gIGZvciAobGV0IGtleSBpbiB0cmFja2VkUHJvcGVydHkuY2hpbGRyZW4pIHtcbiAgICBrZXlzVG9EZXRlY3Rba2V5XSA9IHRydWU7XG4gIH1cbiAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgIGtleXNUb0RldGVjdFtrZXldID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBoYXNJZ25vcmVkUGF0aHMgPSBpZ25vcmVkUGF0aHMubGVuZ3RoID4gMDtcbiAgZm9yIChsZXQga2V5IGluIGtleXNUb0RldGVjdCkge1xuICAgIGNvbnN0IG5lc3RlZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xuICAgIGlmIChoYXNJZ25vcmVkUGF0aHMpIHtcbiAgICAgIGNvbnN0IGhhc01hdGNoZXMgPSBpZ25vcmVkUGF0aHMuc29tZSgoaWdub3JlZCkgPT4ge1xuICAgICAgICBpZiAoaWdub3JlZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgIHJldHVybiBpZ25vcmVkLnRlc3QobmVzdGVkUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5lc3RlZFBhdGggPT09IGlnbm9yZWQ7XG4gICAgICB9KTtcbiAgICAgIGlmIChoYXNNYXRjaGVzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZWRQYXRocywgdHJhY2tlZFByb3BlcnR5LmNoaWxkcmVuW2tleV0sIG9ialtrZXldLCBzYW1lUmVmLCBuZXN0ZWRQYXRoKTtcbiAgICBpZiAocmVzdWx0Lndhc011dGF0ZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2FzTXV0YXRlZDogZmFsc2VcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zID0ge30pIHtcbiAgaWYgKGZhbHNlKSB7XG4gICAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiBuZXh0KGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHN0cmluZ2lmeTIgPSBmdW5jdGlvbihvYmosIHNlcmlhbGl6ZXIsIGluZGVudCwgZGVjeWNsZXIpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIGdldFNlcmlhbGl6ZTIoc2VyaWFsaXplciwgZGVjeWNsZXIpLCBpbmRlbnQpO1xuICAgIH0sIGdldFNlcmlhbGl6ZTIgPSBmdW5jdGlvbihzZXJpYWxpemVyLCBkZWN5Y2xlcikge1xuICAgICAgbGV0IHN0YWNrID0gW10sIGtleXMgPSBbXTtcbiAgICAgIGlmICghZGVjeWNsZXIpXG4gICAgICAgIGRlY3ljbGVyID0gZnVuY3Rpb24oXywgdmFsdWUpIHtcbiAgICAgICAgICBpZiAoc3RhY2tbMF0gPT09IHZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIFwiW0NpcmN1bGFyIH5dXCI7XG4gICAgICAgICAgcmV0dXJuIFwiW0NpcmN1bGFyIH4uXCIgKyBrZXlzLnNsaWNlKDAsIHN0YWNrLmluZGV4T2YodmFsdWUpKS5qb2luKFwiLlwiKSArIFwiXVwiO1xuICAgICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgdGhpc1BvcyA9IHN0YWNrLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgfnRoaXNQb3MgPyBzdGFjay5zcGxpY2UodGhpc1BvcyArIDEpIDogc3RhY2sucHVzaCh0aGlzKTtcbiAgICAgICAgICB+dGhpc1BvcyA/IGtleXMuc3BsaWNlKHRoaXNQb3MsIEluZmluaXR5LCBrZXkpIDoga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgaWYgKH5zdGFjay5pbmRleE9mKHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gZGVjeWNsZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyID09IG51bGwgPyB2YWx1ZSA6IHNlcmlhbGl6ZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgc3RyaW5naWZ5ID0gc3RyaW5naWZ5MiwgZ2V0U2VyaWFsaXplID0gZ2V0U2VyaWFsaXplMjtcbiAgICBsZXQge1xuICAgICAgaXNJbW11dGFibGUgPSBpc0ltbXV0YWJsZURlZmF1bHQsXG4gICAgICBpZ25vcmVkUGF0aHMsXG4gICAgICB3YXJuQWZ0ZXIgPSAzMlxuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHRyYWNrID0gdHJhY2tGb3JNdXRhdGlvbnMuYmluZChudWxsLCBpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzKTtcbiAgICByZXR1cm4gKHtcbiAgICAgIGdldFN0YXRlXG4gICAgfSkgPT4ge1xuICAgICAgbGV0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgIGxldCB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIHJldHVybiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XG4gICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZSgoKSA9PiB7XG4gICAgICAgICAgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgICAgIHJlc3VsdCA9IHRyYWNrZXIuZGV0ZWN0TXV0YXRpb25zKCk7XG4gICAgICAgICAgdHJhY2tlciA9IHRyYWNrKHN0YXRlKTtcbiAgICAgICAgICBpZiAocmVzdWx0Lndhc011dGF0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmYWxzZSA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE5KSA6IGBBIHN0YXRlIG11dGF0aW9uIHdhcyBkZXRlY3RlZCBiZXR3ZWVuIGRpc3BhdGNoZXMsIGluIHRoZSBwYXRoICcke3Jlc3VsdC5wYXRoIHx8IFwiXCJ9Jy4gIFRoaXMgbWF5IGNhdXNlIGluY29ycmVjdCBiZWhhdmlvci4gKGh0dHBzOi8vcmVkdXguanMub3JnL3N0eWxlLWd1aWRlL3N0eWxlLWd1aWRlI2RvLW5vdC1tdXRhdGUtc3RhdGUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGlzcGF0Y2hlZEFjdGlvbiA9IG5leHQoYWN0aW9uKTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICAgICAgcmVzdWx0ID0gdHJhY2tlci5kZXRlY3RNdXRhdGlvbnMoKTtcbiAgICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZhbHNlID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyKDIwKSA6IGBBIHN0YXRlIG11dGF0aW9uIHdhcyBkZXRlY3RlZCBpbnNpZGUgYSBkaXNwYXRjaCwgaW4gdGhlIHBhdGg6ICR7cmVzdWx0LnBhdGggfHwgXCJcIn0uIFRha2UgYSBsb29rIGF0IHRoZSByZWR1Y2VyKHMpIGhhbmRsaW5nIHRoZSBhY3Rpb24gJHtzdHJpbmdpZnkyKGFjdGlvbil9LiAoaHR0cHM6Ly9yZWR1eC5qcy5vcmcvc3R5bGUtZ3VpZGUvc3R5bGUtZ3VpZGUjZG8tbm90LW11dGF0ZS1zdGF0ZSlgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZWFzdXJlVXRpbHMud2FybklmRXhjZWVkZWQoKTtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoZWRBY3Rpb247XG4gICAgICB9O1xuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL3NlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZS50c1xudmFyIGltcG9ydF9yZWR1eDMgPSByZXF1aXJlKFwicmVkdXhcIik7XG5mdW5jdGlvbiBpc1BsYWluKHZhbCkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbDtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgfHwgdHlwZSA9PT0gXCJudW1iZXJcIiB8fCBBcnJheS5pc0FycmF5KHZhbCkgfHwgKDAsIGltcG9ydF9yZWR1eDMuaXNQbGFpbk9iamVjdCkodmFsKTtcbn1cbmZ1bmN0aW9uIGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSh2YWx1ZSwgcGF0aCA9IFwiXCIsIGlzU2VyaWFsaXphYmxlID0gaXNQbGFpbiwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzID0gW10sIGNhY2hlKSB7XG4gIGxldCBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZTtcbiAgaWYgKCFpc1NlcmlhbGl6YWJsZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5UGF0aDogcGF0aCB8fCBcIjxyb290PlwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNhY2hlPy5oYXModmFsdWUpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgZW50cmllcyA9IGdldEVudHJpZXMgIT0gbnVsbCA/IGdldEVudHJpZXModmFsdWUpIDogT2JqZWN0LmVudHJpZXModmFsdWUpO1xuICBjb25zdCBoYXNJZ25vcmVkUGF0aHMgPSBpZ25vcmVkUGF0aHMubGVuZ3RoID4gMDtcbiAgZm9yIChjb25zdCBba2V5LCBuZXN0ZWRWYWx1ZV0gb2YgZW50cmllcykge1xuICAgIGNvbnN0IG5lc3RlZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xuICAgIGlmIChoYXNJZ25vcmVkUGF0aHMpIHtcbiAgICAgIGNvbnN0IGhhc01hdGNoZXMgPSBpZ25vcmVkUGF0aHMuc29tZSgoaWdub3JlZCkgPT4ge1xuICAgICAgICBpZiAoaWdub3JlZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgIHJldHVybiBpZ25vcmVkLnRlc3QobmVzdGVkUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5lc3RlZFBhdGggPT09IGlnbm9yZWQ7XG4gICAgICB9KTtcbiAgICAgIGlmIChoYXNNYXRjaGVzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzU2VyaWFsaXphYmxlKG5lc3RlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5UGF0aDogbmVzdGVkUGF0aCxcbiAgICAgICAgdmFsdWU6IG5lc3RlZFZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShuZXN0ZWRWYWx1ZSwgbmVzdGVkUGF0aCwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRQYXRocywgY2FjaGUpO1xuICAgICAgaWYgKGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlKSB7XG4gICAgICAgIHJldHVybiBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGNhY2hlICYmIGlzTmVzdGVkRnJvemVuKHZhbHVlKSlcbiAgICBjYWNoZS5hZGQodmFsdWUpO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc05lc3RlZEZyb3plbih2YWx1ZSkge1xuICBpZiAoIU9iamVjdC5pc0Zyb3plbih2YWx1ZSkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGNvbnN0IG5lc3RlZFZhbHVlIG9mIE9iamVjdC52YWx1ZXModmFsdWUpKSB7XG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSAhPT0gXCJvYmplY3RcIiB8fCBuZXN0ZWRWYWx1ZSA9PT0gbnVsbClcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmICghaXNOZXN0ZWRGcm96ZW4obmVzdGVkVmFsdWUpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAoZmFsc2UpIHtcbiAgICByZXR1cm4gKCkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IG5leHQoYWN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7XG4gICAgICBpc1NlcmlhbGl6YWJsZSA9IGlzUGxhaW4sXG4gICAgICBnZXRFbnRyaWVzLFxuICAgICAgaWdub3JlZEFjdGlvbnMgPSBbXSxcbiAgICAgIGlnbm9yZWRBY3Rpb25QYXRocyA9IFtcIm1ldGEuYXJnXCIsIFwibWV0YS5iYXNlUXVlcnlNZXRhXCJdLFxuICAgICAgaWdub3JlZFBhdGhzID0gW10sXG4gICAgICB3YXJuQWZ0ZXIgPSAzMixcbiAgICAgIGlnbm9yZVN0YXRlID0gZmFsc2UsXG4gICAgICBpZ25vcmVBY3Rpb25zID0gZmFsc2UsXG4gICAgICBkaXNhYmxlQ2FjaGUgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGNhY2hlID0gIWRpc2FibGVDYWNoZSAmJiBXZWFrU2V0ID8gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIChzdG9yZUFQSSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICAgIGlmICghKDAsIGltcG9ydF9yZWR1eDMuaXNBY3Rpb24pKGFjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5leHQoYWN0aW9uKTtcbiAgICAgIGNvbnN0IG1lYXN1cmVVdGlscyA9IGdldFRpbWVNZWFzdXJlVXRpbHMod2FybkFmdGVyLCBcIlNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZVwiKTtcbiAgICAgIGlmICghaWdub3JlQWN0aW9ucyAmJiAhKGlnbm9yZWRBY3Rpb25zLmxlbmd0aCAmJiBpZ25vcmVkQWN0aW9ucy5pbmRleE9mKGFjdGlvbi50eXBlKSAhPT0gLTEpKSB7XG4gICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZSgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShhY3Rpb24sIFwiXCIsIGlzU2VyaWFsaXphYmxlLCBnZXRFbnRyaWVzLCBpZ25vcmVkQWN0aW9uUGF0aHMsIGNhY2hlKTtcbiAgICAgICAgICBpZiAoZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSA9IGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWU7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBBIG5vbi1zZXJpYWxpemFibGUgdmFsdWUgd2FzIGRldGVjdGVkIGluIGFuIGFjdGlvbiwgaW4gdGhlIHBhdGg6IFxcYCR7a2V5UGF0aH1cXGAuIFZhbHVlOmAsIHZhbHVlLCBcIlxcblRha2UgYSBsb29rIGF0IHRoZSBsb2dpYyB0aGF0IGRpc3BhdGNoZWQgdGhpcyBhY3Rpb246IFwiLCBhY3Rpb24sIFwiXFxuKFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy9mYXEvYWN0aW9ucyN3aHktc2hvdWxkLXR5cGUtYmUtYS1zdHJpbmctb3ItYXQtbGVhc3Qtc2VyaWFsaXphYmxlLXdoeS1zaG91bGQtbXktYWN0aW9uLXR5cGVzLWJlLWNvbnN0YW50cylcIiwgXCJcXG4oVG8gYWxsb3cgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZXMgc2VlOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL3VzYWdlL3VzYWdlLWd1aWRlI3dvcmtpbmctd2l0aC1ub24tc2VyaWFsaXphYmxlLWRhdGEpXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlnbm9yZVN0YXRlKSB7XG4gICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZSgoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZUFQSS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIGNvbnN0IGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShzdGF0ZSwgXCJcIiwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRQYXRocywgY2FjaGUpO1xuICAgICAgICAgIGlmIChmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0gPSBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWU7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBBIG5vbi1zZXJpYWxpemFibGUgdmFsdWUgd2FzIGRldGVjdGVkIGluIHRoZSBzdGF0ZSwgaW4gdGhlIHBhdGg6IFxcYCR7a2V5UGF0aH1cXGAuIFZhbHVlOmAsIHZhbHVlLCBgXG5UYWtlIGEgbG9vayBhdCB0aGUgcmVkdWNlcihzKSBoYW5kbGluZyB0aGlzIGFjdGlvbiB0eXBlOiAke2FjdGlvbi50eXBlfS5cbihTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvZmFxL29yZ2FuaXppbmctc3RhdGUjY2FuLWktcHV0LWZ1bmN0aW9ucy1wcm9taXNlcy1vci1vdGhlci1ub24tc2VyaWFsaXphYmxlLWl0ZW1zLWluLW15LXN0b3JlLXN0YXRlKWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1lYXN1cmVVdGlscy53YXJuSWZFeGNlZWRlZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9nZXREZWZhdWx0TWlkZGxld2FyZS50c1xuZnVuY3Rpb24gaXNCb29sZWFuKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcImJvb2xlYW5cIjtcbn1cbnZhciBidWlsZEdldERlZmF1bHRNaWRkbGV3YXJlID0gKCkgPT4gZnVuY3Rpb24gZ2V0RGVmYXVsdE1pZGRsZXdhcmUob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgdGh1bmsgPSB0cnVlLFxuICAgIGltbXV0YWJsZUNoZWNrID0gdHJ1ZSxcbiAgICBzZXJpYWxpemFibGVDaGVjayA9IHRydWUsXG4gICAgYWN0aW9uQ3JlYXRvckNoZWNrID0gdHJ1ZVxuICB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgbGV0IG1pZGRsZXdhcmVBcnJheSA9IG5ldyBUdXBsZSgpO1xuICBpZiAodGh1bmspIHtcbiAgICBpZiAoaXNCb29sZWFuKHRodW5rKSkge1xuICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2goaW1wb3J0X3JlZHV4X3RodW5rLnRodW5rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2goKDAsIGltcG9ydF9yZWR1eF90aHVuay53aXRoRXh0cmFBcmd1bWVudCkodGh1bmsuZXh0cmFBcmd1bWVudCkpO1xuICAgIH1cbiAgfVxuICBpZiAodHJ1ZSkge1xuICAgIGlmIChpbW11dGFibGVDaGVjaykge1xuICAgICAgbGV0IGltbXV0YWJsZU9wdGlvbnMgPSB7fTtcbiAgICAgIGlmICghaXNCb29sZWFuKGltbXV0YWJsZUNoZWNrKSkge1xuICAgICAgICBpbW11dGFibGVPcHRpb25zID0gaW1tdXRhYmxlQ2hlY2s7XG4gICAgICB9XG4gICAgICBtaWRkbGV3YXJlQXJyYXkudW5zaGlmdChjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUoaW1tdXRhYmxlT3B0aW9ucykpO1xuICAgIH1cbiAgICBpZiAoc2VyaWFsaXphYmxlQ2hlY2spIHtcbiAgICAgIGxldCBzZXJpYWxpemFibGVPcHRpb25zID0ge307XG4gICAgICBpZiAoIWlzQm9vbGVhbihzZXJpYWxpemFibGVDaGVjaykpIHtcbiAgICAgICAgc2VyaWFsaXphYmxlT3B0aW9ucyA9IHNlcmlhbGl6YWJsZUNoZWNrO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2goY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKHNlcmlhbGl6YWJsZU9wdGlvbnMpKTtcbiAgICB9XG4gICAgaWYgKGFjdGlvbkNyZWF0b3JDaGVjaykge1xuICAgICAgbGV0IGFjdGlvbkNyZWF0b3JPcHRpb25zID0ge307XG4gICAgICBpZiAoIWlzQm9vbGVhbihhY3Rpb25DcmVhdG9yQ2hlY2spKSB7XG4gICAgICAgIGFjdGlvbkNyZWF0b3JPcHRpb25zID0gYWN0aW9uQ3JlYXRvckNoZWNrO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZUFycmF5LnVuc2hpZnQoY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUoYWN0aW9uQ3JlYXRvck9wdGlvbnMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pZGRsZXdhcmVBcnJheTtcbn07XG5cbi8vIHNyYy9hdXRvQmF0Y2hFbmhhbmNlci50c1xudmFyIFNIT1VMRF9BVVRPQkFUQ0ggPSBcIlJUS19hdXRvQmF0Y2hcIjtcbnZhciBwcmVwYXJlQXV0b0JhdGNoZWQgPSAoKSA9PiAocGF5bG9hZCkgPT4gKHtcbiAgcGF5bG9hZCxcbiAgbWV0YToge1xuICAgIFtTSE9VTERfQVVUT0JBVENIXTogdHJ1ZVxuICB9XG59KTtcbnZhciBjcmVhdGVRdWV1ZVdpdGhUaW1lciA9ICh0aW1lb3V0KSA9PiB7XG4gIHJldHVybiAobm90aWZ5KSA9PiB7XG4gICAgc2V0VGltZW91dChub3RpZnksIHRpbWVvdXQpO1xuICB9O1xufTtcbnZhciByQUYgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogY3JlYXRlUXVldWVXaXRoVGltZXIoMTApO1xudmFyIGF1dG9CYXRjaEVuaGFuY2VyID0gKG9wdGlvbnMgPSB7XG4gIHR5cGU6IFwicmFmXCJcbn0pID0+IChuZXh0KSA9PiAoLi4uYXJncykgPT4ge1xuICBjb25zdCBzdG9yZSA9IG5leHQoLi4uYXJncyk7XG4gIGxldCBub3RpZnlpbmcgPSB0cnVlO1xuICBsZXQgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSBmYWxzZTtcbiAgbGV0IG5vdGlmaWNhdGlvblF1ZXVlZCA9IGZhbHNlO1xuICBjb25zdCBsaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBxdWV1ZUNhbGxiYWNrID0gb3B0aW9ucy50eXBlID09PSBcInRpY2tcIiA/IHF1ZXVlTWljcm90YXNrIDogb3B0aW9ucy50eXBlID09PSBcInJhZlwiID8gckFGIDogb3B0aW9ucy50eXBlID09PSBcImNhbGxiYWNrXCIgPyBvcHRpb25zLnF1ZXVlTm90aWZpY2F0aW9uIDogY3JlYXRlUXVldWVXaXRoVGltZXIob3B0aW9ucy50aW1lb3V0KTtcbiAgY29uc3Qgbm90aWZ5TGlzdGVuZXJzID0gKCkgPT4ge1xuICAgIG5vdGlmaWNhdGlvblF1ZXVlZCA9IGZhbHNlO1xuICAgIGlmIChzaG91bGROb3RpZnlBdEVuZE9mVGljaykge1xuICAgICAgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSBmYWxzZTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChsKSA9PiBsKCkpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0b3JlLCB7XG4gICAgLy8gT3ZlcnJpZGUgdGhlIGJhc2UgYHN0b3JlLnN1YnNjcmliZWAgbWV0aG9kIHRvIGtlZXAgb3JpZ2luYWwgbGlzdGVuZXJzXG4gICAgLy8gZnJvbSBydW5uaW5nIGlmIHdlJ3JlIGRlbGF5aW5nIG5vdGlmaWNhdGlvbnNcbiAgICBzdWJzY3JpYmUobGlzdGVuZXIyKSB7XG4gICAgICBjb25zdCB3cmFwcGVkTGlzdGVuZXIgPSAoKSA9PiBub3RpZnlpbmcgJiYgbGlzdGVuZXIyKCk7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN0b3JlLnN1YnNjcmliZSh3cmFwcGVkTGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcjIpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcjIpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIE92ZXJyaWRlIHRoZSBiYXNlIGBzdG9yZS5kaXNwYXRjaGAgbWV0aG9kIHNvIHRoYXQgd2UgY2FuIGNoZWNrIGFjdGlvbnNcbiAgICAvLyBmb3IgdGhlIGBzaG91bGRBdXRvQmF0Y2hgIGZsYWcgYW5kIGRldGVybWluZSBpZiBiYXRjaGluZyBpcyBhY3RpdmVcbiAgICBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5vdGlmeWluZyA9ICFhY3Rpb24/Lm1ldGE/LltTSE9VTERfQVVUT0JBVENIXTtcbiAgICAgICAgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSAhbm90aWZ5aW5nO1xuICAgICAgICBpZiAoc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2spIHtcbiAgICAgICAgICBpZiAoIW5vdGlmaWNhdGlvblF1ZXVlZCkge1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uUXVldWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHF1ZXVlQ2FsbGJhY2sobm90aWZ5TGlzdGVuZXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBub3RpZnlpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBzcmMvZ2V0RGVmYXVsdEVuaGFuY2Vycy50c1xudmFyIGJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VycyA9IChtaWRkbGV3YXJlRW5oYW5jZXIpID0+IGZ1bmN0aW9uIGdldERlZmF1bHRFbmhhbmNlcnMob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgYXV0b0JhdGNoID0gdHJ1ZVxuICB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgbGV0IGVuaGFuY2VyQXJyYXkgPSBuZXcgVHVwbGUobWlkZGxld2FyZUVuaGFuY2VyKTtcbiAgaWYgKGF1dG9CYXRjaCkge1xuICAgIGVuaGFuY2VyQXJyYXkucHVzaChhdXRvQmF0Y2hFbmhhbmNlcih0eXBlb2YgYXV0b0JhdGNoID09PSBcIm9iamVjdFwiID8gYXV0b0JhdGNoIDogdm9pZCAwKSk7XG4gIH1cbiAgcmV0dXJuIGVuaGFuY2VyQXJyYXk7XG59O1xuXG4vLyBzcmMvY29uZmlndXJlU3RvcmUudHNcbnZhciBJU19QUk9EVUNUSU9OID0gZmFsc2U7XG5mdW5jdGlvbiBjb25maWd1cmVTdG9yZShvcHRpb25zKSB7XG4gIGNvbnN0IGdldERlZmF1bHRNaWRkbGV3YXJlID0gYnVpbGRHZXREZWZhdWx0TWlkZGxld2FyZSgpO1xuICBjb25zdCB7XG4gICAgcmVkdWNlciA9IHZvaWQgMCxcbiAgICBtaWRkbGV3YXJlLFxuICAgIGRldlRvb2xzID0gdHJ1ZSxcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHZvaWQgMCxcbiAgICBlbmhhbmNlcnMgPSB2b2lkIDBcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIGxldCByb290UmVkdWNlcjtcbiAgaWYgKHR5cGVvZiByZWR1Y2VyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByb290UmVkdWNlciA9IHJlZHVjZXI7XG4gIH0gZWxzZSBpZiAoKDAsIGltcG9ydF9yZWR1eDQuaXNQbGFpbk9iamVjdCkocmVkdWNlcikpIHtcbiAgICByb290UmVkdWNlciA9ICgwLCBpbXBvcnRfcmVkdXg0LmNvbWJpbmVSZWR1Y2VycykocmVkdWNlcik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGZhbHNlID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UoMSkgOiBcImByZWR1Y2VyYCBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LCBhbmQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCBvZiBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGNvbWJpbmVSZWR1Y2Vyc1wiKTtcbiAgfVxuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgbWlkZGxld2FyZSAmJiB0eXBlb2YgbWlkZGxld2FyZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGZhbHNlID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyKDIpIDogXCJgbWlkZGxld2FyZWAgZmllbGQgbXVzdCBiZSBhIGNhbGxiYWNrXCIpO1xuICB9XG4gIGxldCBmaW5hbE1pZGRsZXdhcmU7XG4gIGlmICh0eXBlb2YgbWlkZGxld2FyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZmluYWxNaWRkbGV3YXJlID0gbWlkZGxld2FyZShnZXREZWZhdWx0TWlkZGxld2FyZSk7XG4gICAgaWYgKCFJU19QUk9EVUNUSU9OICYmICFBcnJheS5pc0FycmF5KGZpbmFsTWlkZGxld2FyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihmYWxzZSA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMygzKSA6IFwid2hlbiB1c2luZyBhIG1pZGRsZXdhcmUgYnVpbGRlciBmdW5jdGlvbiwgYW4gYXJyYXkgb2YgbWlkZGxld2FyZSBtdXN0IGJlIHJldHVybmVkXCIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmaW5hbE1pZGRsZXdhcmUgPSBnZXREZWZhdWx0TWlkZGxld2FyZSgpO1xuICB9XG4gIGlmICghSVNfUFJPRFVDVElPTiAmJiBmaW5hbE1pZGRsZXdhcmUuc29tZSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gIT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTQoNCkgOiBcImVhY2ggbWlkZGxld2FyZSBwcm92aWRlZCB0byBjb25maWd1cmVTdG9yZSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgbGV0IGZpbmFsQ29tcG9zZSA9IGltcG9ydF9yZWR1eDQuY29tcG9zZTtcbiAgaWYgKGRldlRvb2xzKSB7XG4gICAgZmluYWxDb21wb3NlID0gY29tcG9zZVdpdGhEZXZUb29scyh7XG4gICAgICAvLyBFbmFibGUgY2FwdHVyZSBvZiBzdGFjayB0cmFjZXMgZm9yIGRpc3BhdGNoZWQgUmVkdXggYWN0aW9uc1xuICAgICAgdHJhY2U6ICFJU19QUk9EVUNUSU9OLFxuICAgICAgLi4udHlwZW9mIGRldlRvb2xzID09PSBcIm9iamVjdFwiICYmIGRldlRvb2xzXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbWlkZGxld2FyZUVuaGFuY2VyID0gKDAsIGltcG9ydF9yZWR1eDQuYXBwbHlNaWRkbGV3YXJlKSguLi5maW5hbE1pZGRsZXdhcmUpO1xuICBjb25zdCBnZXREZWZhdWx0RW5oYW5jZXJzID0gYnVpbGRHZXREZWZhdWx0RW5oYW5jZXJzKG1pZGRsZXdhcmVFbmhhbmNlcik7XG4gIGlmICghSVNfUFJPRFVDVElPTiAmJiBlbmhhbmNlcnMgJiYgdHlwZW9mIGVuaGFuY2VycyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGZhbHNlID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U1KDUpIDogXCJgZW5oYW5jZXJzYCBmaWVsZCBtdXN0IGJlIGEgY2FsbGJhY2tcIik7XG4gIH1cbiAgbGV0IHN0b3JlRW5oYW5jZXJzID0gdHlwZW9mIGVuaGFuY2VycyA9PT0gXCJmdW5jdGlvblwiID8gZW5oYW5jZXJzKGdldERlZmF1bHRFbmhhbmNlcnMpIDogZ2V0RGVmYXVsdEVuaGFuY2VycygpO1xuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgIUFycmF5LmlzQXJyYXkoc3RvcmVFbmhhbmNlcnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGZhbHNlID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U2KDYpIDogXCJgZW5oYW5jZXJzYCBjYWxsYmFjayBtdXN0IHJldHVybiBhbiBhcnJheVwiKTtcbiAgfVxuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgc3RvcmVFbmhhbmNlcnMuc29tZSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gIT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTcoNykgOiBcImVhY2ggZW5oYW5jZXIgcHJvdmlkZWQgdG8gY29uZmlndXJlU3RvcmUgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB9XG4gIGlmICghSVNfUFJPRFVDVElPTiAmJiBmaW5hbE1pZGRsZXdhcmUubGVuZ3RoICYmICFzdG9yZUVuaGFuY2Vycy5pbmNsdWRlcyhtaWRkbGV3YXJlRW5oYW5jZXIpKSB7XG4gICAgY29uc29sZS5lcnJvcihcIm1pZGRsZXdhcmVzIHdlcmUgcHJvdmlkZWQsIGJ1dCBtaWRkbGV3YXJlIGVuaGFuY2VyIHdhcyBub3QgaW5jbHVkZWQgaW4gZmluYWwgZW5oYW5jZXJzIC0gbWFrZSBzdXJlIHRvIGNhbGwgYGdldERlZmF1bHRFbmhhbmNlcnNgXCIpO1xuICB9XG4gIGNvbnN0IGNvbXBvc2VkRW5oYW5jZXIgPSBmaW5hbENvbXBvc2UoLi4uc3RvcmVFbmhhbmNlcnMpO1xuICByZXR1cm4gKDAsIGltcG9ydF9yZWR1eDQuY3JlYXRlU3RvcmUpKHJvb3RSZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgY29tcG9zZWRFbmhhbmNlcik7XG59XG5cbi8vIHNyYy9jcmVhdGVSZWR1Y2VyLnRzXG52YXIgaW1wb3J0X2ltbWVyMyA9IHJlcXVpcmUoXCJpbW1lclwiKTtcblxuLy8gc3JjL21hcEJ1aWxkZXJzLnRzXG5mdW5jdGlvbiBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhidWlsZGVyQ2FsbGJhY2spIHtcbiAgY29uc3QgYWN0aW9uc01hcCA9IHt9O1xuICBjb25zdCBhY3Rpb25NYXRjaGVycyA9IFtdO1xuICBsZXQgZGVmYXVsdENhc2VSZWR1Y2VyO1xuICBjb25zdCBidWlsZGVyID0ge1xuICAgIGFkZENhc2UodHlwZU9yQWN0aW9uQ3JlYXRvciwgcmVkdWNlcikge1xuICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgaWYgKGFjdGlvbk1hdGNoZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNikgOiBcImBidWlsZGVyLmFkZENhc2VgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGRNYXRjaGVyYFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZhbHNlID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyKDI3KSA6IFwiYGJ1aWxkZXIuYWRkQ2FzZWAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZERlZmF1bHRDYXNlYFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB0eXBlT3JBY3Rpb25DcmVhdG9yID09PSBcInN0cmluZ1wiID8gdHlwZU9yQWN0aW9uQ3JlYXRvciA6IHR5cGVPckFjdGlvbkNyZWF0b3IudHlwZTtcbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMoMjgpIDogXCJgYnVpbGRlci5hZGRDYXNlYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggYW4gZW1wdHkgYWN0aW9uIHR5cGVcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSBpbiBhY3Rpb25zTWFwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmYWxzZSA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNCgyOSkgOiBgXFxgYnVpbGRlci5hZGRDYXNlXFxgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCB0d28gcmVkdWNlcnMgZm9yIHRoZSBzYW1lIGFjdGlvbiB0eXBlICcke3R5cGV9J2ApO1xuICAgICAgfVxuICAgICAgYWN0aW9uc01hcFt0eXBlXSA9IHJlZHVjZXI7XG4gICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9LFxuICAgIGFkZE1hdGNoZXIobWF0Y2hlciwgcmVkdWNlcikge1xuICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmYWxzZSA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNSgzMCkgOiBcImBidWlsZGVyLmFkZE1hdGNoZXJgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFjdGlvbk1hdGNoZXJzLnB1c2goe1xuICAgICAgICBtYXRjaGVyLFxuICAgICAgICByZWR1Y2VyXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH0sXG4gICAgYWRkRGVmYXVsdENhc2UocmVkdWNlcikge1xuICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmYWxzZSA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNigzMSkgOiBcImBidWlsZGVyLmFkZERlZmF1bHRDYXNlYCBjYW4gb25seSBiZSBjYWxsZWQgb25jZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVmYXVsdENhc2VSZWR1Y2VyID0gcmVkdWNlcjtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH1cbiAgfTtcbiAgYnVpbGRlckNhbGxiYWNrKGJ1aWxkZXIpO1xuICByZXR1cm4gW2FjdGlvbnNNYXAsIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXJdO1xufVxuXG4vLyBzcmMvY3JlYXRlUmVkdWNlci50c1xuZnVuY3Rpb24gaXNTdGF0ZUZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWR1Y2VyKGluaXRpYWxTdGF0ZSwgbWFwT3JCdWlsZGVyQ2FsbGJhY2spIHtcbiAgaWYgKHRydWUpIHtcbiAgICBpZiAodHlwZW9mIG1hcE9yQnVpbGRlckNhbGxiYWNrID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg4KSA6IFwiVGhlIG9iamVjdCBub3RhdGlvbiBmb3IgYGNyZWF0ZVJlZHVjZXJgIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSB1c2UgdGhlICdidWlsZGVyIGNhbGxiYWNrJyBub3RhdGlvbiBpbnN0ZWFkOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9jcmVhdGVSZWR1Y2VyXCIpO1xuICAgIH1cbiAgfVxuICBsZXQgW2FjdGlvbnNNYXAsIGZpbmFsQWN0aW9uTWF0Y2hlcnMsIGZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyXSA9IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKG1hcE9yQnVpbGRlckNhbGxiYWNrKTtcbiAgbGV0IGdldEluaXRpYWxTdGF0ZTtcbiAgaWYgKGlzU3RhdGVGdW5jdGlvbihpbml0aWFsU3RhdGUpKSB7XG4gICAgZ2V0SW5pdGlhbFN0YXRlID0gKCkgPT4gZnJlZXplRHJhZnRhYmxlKGluaXRpYWxTdGF0ZSgpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmcm96ZW5Jbml0aWFsU3RhdGUgPSBmcmVlemVEcmFmdGFibGUoaW5pdGlhbFN0YXRlKTtcbiAgICBnZXRJbml0aWFsU3RhdGUgPSAoKSA9PiBmcm96ZW5Jbml0aWFsU3RhdGU7XG4gIH1cbiAgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSA9IGdldEluaXRpYWxTdGF0ZSgpLCBhY3Rpb24pIHtcbiAgICBsZXQgY2FzZVJlZHVjZXJzID0gW2FjdGlvbnNNYXBbYWN0aW9uLnR5cGVdLCAuLi5maW5hbEFjdGlvbk1hdGNoZXJzLmZpbHRlcigoe1xuICAgICAgbWF0Y2hlclxuICAgIH0pID0+IG1hdGNoZXIoYWN0aW9uKSkubWFwKCh7XG4gICAgICByZWR1Y2VyOiByZWR1Y2VyMlxuICAgIH0pID0+IHJlZHVjZXIyKV07XG4gICAgaWYgKGNhc2VSZWR1Y2Vycy5maWx0ZXIoKGNyKSA9PiAhIWNyKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNhc2VSZWR1Y2VycyA9IFtmaW5hbERlZmF1bHRDYXNlUmVkdWNlcl07XG4gICAgfVxuICAgIHJldHVybiBjYXNlUmVkdWNlcnMucmVkdWNlKChwcmV2aW91c1N0YXRlLCBjYXNlUmVkdWNlcikgPT4ge1xuICAgICAgaWYgKGNhc2VSZWR1Y2VyKSB7XG4gICAgICAgIGlmICgoMCwgaW1wb3J0X2ltbWVyMy5pc0RyYWZ0KShwcmV2aW91c1N0YXRlKSkge1xuICAgICAgICAgIGNvbnN0IGRyYWZ0ID0gcHJldmlvdXNTdGF0ZTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1N0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKCEoMCwgaW1wb3J0X2ltbWVyMy5pc0RyYWZ0YWJsZSkocHJldmlvdXNTdGF0ZSkpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYXNlUmVkdWNlcihwcmV2aW91c1N0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzU3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIoOSkgOiBcIkEgY2FzZSByZWR1Y2VyIG9uIGEgbm9uLWRyYWZ0YWJsZSB2YWx1ZSBtdXN0IG5vdCByZXR1cm4gdW5kZWZpbmVkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAoMCwgaW1wb3J0X2ltbWVyMy5wcm9kdWNlKShwcmV2aW91c1N0YXRlLCAoZHJhZnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XG4gICAgfSwgc3RhdGUpO1xuICB9XG4gIHJlZHVjZXIuZ2V0SW5pdGlhbFN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlO1xuICByZXR1cm4gcmVkdWNlcjtcbn1cblxuLy8gc3JjL25hbm9pZC50c1xudmFyIHVybEFscGhhYmV0ID0gXCJNb2R1bGVTeW1iaGFzT3duUHItMDEyMzQ1Njc4OUFCQ0RFRkdITlJWZmdjdGlVdnpfS3FZVEprTHhwWlhJalFXXCI7XG52YXIgbmFub2lkID0gKHNpemUgPSAyMSkgPT4ge1xuICBsZXQgaWQgPSBcIlwiO1xuICBsZXQgaSA9IHNpemU7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZCArPSB1cmxBbHBoYWJldFtNYXRoLnJhbmRvbSgpICogNjQgfCAwXTtcbiAgfVxuICByZXR1cm4gaWQ7XG59O1xuXG4vLyBzcmMvbWF0Y2hlcnMudHNcbnZhciBtYXRjaGVzID0gKG1hdGNoZXIsIGFjdGlvbikgPT4ge1xuICBpZiAoaGFzTWF0Y2hGdW5jdGlvbihtYXRjaGVyKSkge1xuICAgIHJldHVybiBtYXRjaGVyLm1hdGNoKGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1hdGNoZXIoYWN0aW9uKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGlzQW55T2YoLi4ubWF0Y2hlcnMpIHtcbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gbWF0Y2hlcnMuc29tZSgobWF0Y2hlcikgPT4gbWF0Y2hlcyhtYXRjaGVyLCBhY3Rpb24pKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQWxsT2YoLi4ubWF0Y2hlcnMpIHtcbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gbWF0Y2hlcnMuZXZlcnkoKG1hdGNoZXIpID0+IG1hdGNoZXMobWF0Y2hlciwgYWN0aW9uKSk7XG4gIH07XG59XG5mdW5jdGlvbiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIHZhbGlkU3RhdHVzKSB7XG4gIGlmICghYWN0aW9uIHx8ICFhY3Rpb24ubWV0YSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGhhc1ZhbGlkUmVxdWVzdElkID0gdHlwZW9mIGFjdGlvbi5tZXRhLnJlcXVlc3RJZCA9PT0gXCJzdHJpbmdcIjtcbiAgY29uc3QgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzID0gdmFsaWRTdGF0dXMuaW5kZXhPZihhY3Rpb24ubWV0YS5yZXF1ZXN0U3RhdHVzKSA+IC0xO1xuICByZXR1cm4gaGFzVmFsaWRSZXF1ZXN0SWQgJiYgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzO1xufVxuZnVuY3Rpb24gaXNBc3luY1RodW5rQXJyYXkoYSkge1xuICByZXR1cm4gdHlwZW9mIGFbMF0gPT09IFwiZnVuY3Rpb25cIiAmJiBcInBlbmRpbmdcIiBpbiBhWzBdICYmIFwiZnVsZmlsbGVkXCIgaW4gYVswXSAmJiBcInJlamVjdGVkXCIgaW4gYVswXTtcbn1cbmZ1bmN0aW9uIGlzUGVuZGluZyguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicGVuZGluZ1wiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNQZW5kaW5nKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBhc3luY1RodW5rcy5tYXAoKGFzeW5jVGh1bmspID0+IGFzeW5jVGh1bmsucGVuZGluZyk7XG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZiguLi5tYXRjaGVycyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufVxuZnVuY3Rpb24gaXNSZWplY3RlZCguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicmVqZWN0ZWRcIl0pO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzUmVqZWN0ZWQoKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICBjb25zdCBtYXRjaGVycyA9IGFzeW5jVGh1bmtzLm1hcCgoYXN5bmNUaHVuaykgPT4gYXN5bmNUaHVuay5yZWplY3RlZCk7XG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZiguLi5tYXRjaGVycyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufVxuZnVuY3Rpb24gaXNSZWplY3RlZFdpdGhWYWx1ZSguLi5hc3luY1RodW5rcykge1xuICBjb25zdCBoYXNGbGFnID0gKGFjdGlvbikgPT4ge1xuICAgIHJldHVybiBhY3Rpb24gJiYgYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWU7XG4gIH07XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFjdGlvbikgPT4ge1xuICAgICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbGxPZihpc1JlamVjdGVkKC4uLmFzeW5jVGh1bmtzKSwgaGFzRmxhZyk7XG4gICAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XG4gICAgfTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc1JlamVjdGVkV2l0aFZhbHVlKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbGxPZihpc1JlamVjdGVkKC4uLmFzeW5jVGh1bmtzKSwgaGFzRmxhZyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufVxuZnVuY3Rpb24gaXNGdWxmaWxsZWQoLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcImZ1bGZpbGxlZFwiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNGdWxmaWxsZWQoKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICBjb25zdCBtYXRjaGVycyA9IGFzeW5jVGh1bmtzLm1hcCgoYXN5bmNUaHVuaykgPT4gYXN5bmNUaHVuay5mdWxmaWxsZWQpO1xuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YoLi4ubWF0Y2hlcnMpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua0FjdGlvbiguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicGVuZGluZ1wiLCBcImZ1bGZpbGxlZFwiLCBcInJlamVjdGVkXCJdKTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc0FzeW5jVGh1bmtBY3Rpb24oKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICBjb25zdCBtYXRjaGVycyA9IFtdO1xuICAgIGZvciAoY29uc3QgYXN5bmNUaHVuayBvZiBhc3luY1RodW5rcykge1xuICAgICAgbWF0Y2hlcnMucHVzaChhc3luY1RodW5rLnBlbmRpbmcsIGFzeW5jVGh1bmsucmVqZWN0ZWQsIGFzeW5jVGh1bmsuZnVsZmlsbGVkKTtcbiAgICB9XG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZiguLi5tYXRjaGVycyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufVxuXG4vLyBzcmMvY3JlYXRlQXN5bmNUaHVuay50c1xudmFyIGNvbW1vblByb3BlcnRpZXMgPSBbXCJuYW1lXCIsIFwibWVzc2FnZVwiLCBcInN0YWNrXCIsIFwiY29kZVwiXTtcbnZhciBSZWplY3RXaXRoVmFsdWUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHBheWxvYWQsIG1ldGEpIHtcbiAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gIH1cbiAgLypcbiAgdHlwZS1vbmx5IHByb3BlcnR5IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gUmVqZWN0V2l0aFZhbHVlIGFuZCBGdWxmaWxsV2l0aE1ldGFcbiAgZG9lcyBub3QgZXhpc3QgYXQgcnVudGltZVxuICAqL1xuICBfdHlwZTtcbn07XG52YXIgRnVsZmlsbFdpdGhNZXRhID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBtZXRhKSB7XG4gICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICB9XG4gIC8qXG4gIHR5cGUtb25seSBwcm9wZXJ0eSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIFJlamVjdFdpdGhWYWx1ZSBhbmQgRnVsZmlsbFdpdGhNZXRhXG4gIGRvZXMgbm90IGV4aXN0IGF0IHJ1bnRpbWVcbiAgKi9cbiAgX3R5cGU7XG59O1xudmFyIG1pbmlTZXJpYWxpemVFcnJvciA9ICh2YWx1ZSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgY29uc3Qgc2ltcGxlRXJyb3IgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIGNvbW1vblByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVbcHJvcGVydHldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHNpbXBsZUVycm9yW3Byb3BlcnR5XSA9IHZhbHVlW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpbXBsZUVycm9yO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogU3RyaW5nKHZhbHVlKVxuICB9O1xufTtcbnZhciBjcmVhdGVBc3luY1RodW5rID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUFzeW5jVGh1bmsyKHR5cGVQcmVmaXgsIHBheWxvYWRDcmVhdG9yLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZnVsZmlsbGVkID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9mdWxmaWxsZWRcIiwgKHBheWxvYWQsIHJlcXVlc3RJZCwgYXJnLCBtZXRhKSA9PiAoe1xuICAgICAgcGF5bG9hZCxcbiAgICAgIG1ldGE6IHtcbiAgICAgICAgLi4ubWV0YSB8fCB7fSxcbiAgICAgICAgYXJnLFxuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHJlcXVlc3RTdGF0dXM6IFwiZnVsZmlsbGVkXCJcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgY29uc3QgcGVuZGluZyA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvcGVuZGluZ1wiLCAocmVxdWVzdElkLCBhcmcsIG1ldGEpID0+ICh7XG4gICAgICBwYXlsb2FkOiB2b2lkIDAsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLm1ldGEgfHwge30sXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiBcInBlbmRpbmdcIlxuICAgICAgfVxuICAgIH0pKTtcbiAgICBjb25zdCByZWplY3RlZCA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvcmVqZWN0ZWRcIiwgKGVycm9yLCByZXF1ZXN0SWQsIGFyZywgcGF5bG9hZCwgbWV0YSkgPT4gKHtcbiAgICAgIHBheWxvYWQsXG4gICAgICBlcnJvcjogKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXJpYWxpemVFcnJvciB8fCBtaW5pU2VyaWFsaXplRXJyb3IpKGVycm9yIHx8IFwiUmVqZWN0ZWRcIiksXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLm1ldGEgfHwge30sXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZWplY3RlZFdpdGhWYWx1ZTogISFwYXlsb2FkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiBcInJlamVjdGVkXCIsXG4gICAgICAgIGFib3J0ZWQ6IGVycm9yPy5uYW1lID09PSBcIkFib3J0RXJyb3JcIixcbiAgICAgICAgY29uZGl0aW9uOiBlcnJvcj8ubmFtZSA9PT0gXCJDb25kaXRpb25FcnJvclwiXG4gICAgICB9XG4gICAgfSkpO1xuICAgIGZ1bmN0aW9uIGFjdGlvbkNyZWF0b3IoYXJnKSB7XG4gICAgICByZXR1cm4gKGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmEpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gb3B0aW9ucz8uaWRHZW5lcmF0b3IgPyBvcHRpb25zLmlkR2VuZXJhdG9yKGFyZykgOiBuYW5vaWQoKTtcbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBsZXQgYWJvcnRIYW5kbGVyO1xuICAgICAgICBsZXQgYWJvcnRSZWFzb247XG4gICAgICAgIGZ1bmN0aW9uIGFib3J0KHJlYXNvbikge1xuICAgICAgICAgIGFib3J0UmVhc29uID0gcmVhc29uO1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsZXQgZmluYWxBY3Rpb247XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBjb25kaXRpb25SZXN1bHQgPSBvcHRpb25zPy5jb25kaXRpb24/LihhcmcsIHtcbiAgICAgICAgICAgICAgZ2V0U3RhdGUsXG4gICAgICAgICAgICAgIGV4dHJhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpc1RoZW5hYmxlKGNvbmRpdGlvblJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gYXdhaXQgY29uZGl0aW9uUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmRpdGlvblJlc3VsdCA9PT0gZmFsc2UgfHwgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkNvbmRpdGlvbkVycm9yXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBYm9ydGVkIGR1ZSB0byBjb25kaXRpb24gY2FsbGJhY2sgcmV0dXJuaW5nIGZhbHNlLlwiXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhYm9ydGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgYWJvcnRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcIkFib3J0RXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGFib3J0UmVhc29uIHx8IFwiQWJvcnRlZFwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHBlbmRpbmcocmVxdWVzdElkLCBhcmcsIG9wdGlvbnM/LmdldFBlbmRpbmdNZXRhPy4oe1xuICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgIGFyZ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBnZXRTdGF0ZSxcbiAgICAgICAgICAgICAgZXh0cmFcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICBmaW5hbEFjdGlvbiA9IGF3YWl0IFByb21pc2UucmFjZShbYWJvcnRlZFByb21pc2UsIFByb21pc2UucmVzb2x2ZShwYXlsb2FkQ3JlYXRvcihhcmcsIHtcbiAgICAgICAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgICAgICAgIGdldFN0YXRlLFxuICAgICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICAgIGFib3J0LFxuICAgICAgICAgICAgICByZWplY3RXaXRoVmFsdWU6ICh2YWx1ZSwgbWV0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVqZWN0V2l0aFZhbHVlKHZhbHVlLCBtZXRhKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVsZmlsbFdpdGhWYWx1ZTogKHZhbHVlLCBtZXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGdWxmaWxsV2l0aE1ldGEodmFsdWUsIG1ldGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEZ1bGZpbGxXaXRoTWV0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWQocmVzdWx0LnBheWxvYWQsIHJlcXVlc3RJZCwgYXJnLCByZXN1bHQubWV0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZChyZXN1bHQsIHJlcXVlc3RJZCwgYXJnKTtcbiAgICAgICAgICAgIH0pXSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBmaW5hbEFjdGlvbiA9IGVyciBpbnN0YW5jZW9mIFJlamVjdFdpdGhWYWx1ZSA/IHJlamVjdGVkKG51bGwsIHJlcXVlc3RJZCwgYXJnLCBlcnIucGF5bG9hZCwgZXJyLm1ldGEpIDogcmVqZWN0ZWQoZXJyLCByZXF1ZXN0SWQsIGFyZyk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChhYm9ydEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2tpcERpc3BhdGNoID0gb3B0aW9ucyAmJiAhb3B0aW9ucy5kaXNwYXRjaENvbmRpdGlvblJlamVjdGlvbiAmJiByZWplY3RlZC5tYXRjaChmaW5hbEFjdGlvbikgJiYgZmluYWxBY3Rpb24ubWV0YS5jb25kaXRpb247XG4gICAgICAgICAgaWYgKCFza2lwRGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKGZpbmFsQWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZpbmFsQWN0aW9uO1xuICAgICAgICB9KCk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHByb21pc2UsIHtcbiAgICAgICAgICBhYm9ydCxcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgYXJnLFxuICAgICAgICAgIHVud3JhcCgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4odW53cmFwUmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWN0aW9uQ3JlYXRvciwge1xuICAgICAgcGVuZGluZyxcbiAgICAgIHJlamVjdGVkLFxuICAgICAgZnVsZmlsbGVkLFxuICAgICAgc2V0dGxlZDogaXNBbnlPZihyZWplY3RlZCwgZnVsZmlsbGVkKSxcbiAgICAgIHR5cGVQcmVmaXhcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVBc3luY1RodW5rMi53aXRoVHlwZXMgPSAoKSA9PiBjcmVhdGVBc3luY1RodW5rMjtcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jVGh1bmsyO1xufSkoKTtcbmZ1bmN0aW9uIHVud3JhcFJlc3VsdChhY3Rpb24pIHtcbiAgaWYgKGFjdGlvbi5tZXRhICYmIGFjdGlvbi5tZXRhLnJlamVjdGVkV2l0aFZhbHVlKSB7XG4gICAgdGhyb3cgYWN0aW9uLnBheWxvYWQ7XG4gIH1cbiAgaWYgKGFjdGlvbi5lcnJvcikge1xuICAgIHRocm93IGFjdGlvbi5lcnJvcjtcbiAgfVxuICByZXR1cm4gYWN0aW9uLnBheWxvYWQ7XG59XG5mdW5jdGlvbiBpc1RoZW5hYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLy8gc3JjL2NyZWF0ZVNsaWNlLnRzXG52YXIgYXN5bmNUaHVua1N5bWJvbCA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicnRrLXNsaWNlLWNyZWF0ZWFzeW5jdGh1bmtcIik7XG52YXIgYXN5bmNUaHVua0NyZWF0b3IgPSB7XG4gIFthc3luY1RodW5rU3ltYm9sXTogY3JlYXRlQXN5bmNUaHVua1xufTtcbnZhciBSZWR1Y2VyVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFJlZHVjZXJUeXBlMikgPT4ge1xuICBSZWR1Y2VyVHlwZTJbXCJyZWR1Y2VyXCJdID0gXCJyZWR1Y2VyXCI7XG4gIFJlZHVjZXJUeXBlMltcInJlZHVjZXJXaXRoUHJlcGFyZVwiXSA9IFwicmVkdWNlcldpdGhQcmVwYXJlXCI7XG4gIFJlZHVjZXJUeXBlMltcImFzeW5jVGh1bmtcIl0gPSBcImFzeW5jVGh1bmtcIjtcbiAgcmV0dXJuIFJlZHVjZXJUeXBlMjtcbn0pKFJlZHVjZXJUeXBlIHx8IHt9KTtcbmZ1bmN0aW9uIGdldFR5cGUoc2xpY2UsIGFjdGlvbktleSkge1xuICByZXR1cm4gYCR7c2xpY2V9LyR7YWN0aW9uS2V5fWA7XG59XG5mdW5jdGlvbiBidWlsZENyZWF0ZVNsaWNlKHtcbiAgY3JlYXRvcnNcbn0gPSB7fSkge1xuICBjb25zdCBjQVQgPSBjcmVhdG9ycz8uYXN5bmNUaHVuaz8uW2FzeW5jVGh1bmtTeW1ib2xdO1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlU2xpY2UyKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgcmVkdWNlclBhdGggPSBuYW1lXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMSkgOiBcImBuYW1lYCBpcyBhIHJlcXVpcmVkIG9wdGlvbiBmb3IgY3JlYXRlU2xpY2VcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0cnVlKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbml0aWFsU3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiWW91IG11c3QgcHJvdmlkZSBhbiBgaW5pdGlhbFN0YXRlYCB2YWx1ZSB0aGF0IGlzIG5vdCBgdW5kZWZpbmVkYC4gWW91IG1heSBoYXZlIG1pc3NwZWxsZWQgYGluaXRpYWxTdGF0ZWBcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlZHVjZXJzID0gKHR5cGVvZiBvcHRpb25zLnJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLnJlZHVjZXJzKGJ1aWxkUmVkdWNlckNyZWF0b3JzKCkpIDogb3B0aW9ucy5yZWR1Y2VycykgfHwge307XG4gICAgY29uc3QgcmVkdWNlck5hbWVzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZToge30sXG4gICAgICBzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZToge30sXG4gICAgICBhY3Rpb25DcmVhdG9yczoge30sXG4gICAgICBzbGljZU1hdGNoZXJzOiBbXVxuICAgIH07XG4gICAgY29uc3QgY29udGV4dE1ldGhvZHMgPSB7XG4gICAgICBhZGRDYXNlKHR5cGVPckFjdGlvbkNyZWF0b3IsIHJlZHVjZXIyKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPckFjdGlvbkNyZWF0b3IgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGU7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmYWxzZSA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMigxMikgOiBcImBjb250ZXh0LmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBhbiBlbXB0eSBhY3Rpb24gdHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSBpbiBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZhbHNlID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UzKDEzKSA6IFwiYGNvbnRleHQuYWRkQ2FzZWAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIHR3byByZWR1Y2VycyBmb3IgdGhlIHNhbWUgYWN0aW9uIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZVt0eXBlXSA9IHJlZHVjZXIyO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9LFxuICAgICAgYWRkTWF0Y2hlcihtYXRjaGVyLCByZWR1Y2VyMikge1xuICAgICAgICBjb250ZXh0LnNsaWNlTWF0Y2hlcnMucHVzaCh7XG4gICAgICAgICAgbWF0Y2hlcixcbiAgICAgICAgICByZWR1Y2VyOiByZWR1Y2VyMlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZXRob2RzO1xuICAgICAgfSxcbiAgICAgIGV4cG9zZUFjdGlvbihuYW1lMiwgYWN0aW9uQ3JlYXRvcikge1xuICAgICAgICBjb250ZXh0LmFjdGlvbkNyZWF0b3JzW25hbWUyXSA9IGFjdGlvbkNyZWF0b3I7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcbiAgICAgIH0sXG4gICAgICBleHBvc2VDYXNlUmVkdWNlcihuYW1lMiwgcmVkdWNlcjIpIHtcbiAgICAgICAgY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZVtuYW1lMl0gPSByZWR1Y2VyMjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZXRob2RzO1xuICAgICAgfVxuICAgIH07XG4gICAgcmVkdWNlck5hbWVzLmZvckVhY2goKHJlZHVjZXJOYW1lKSA9PiB7XG4gICAgICBjb25zdCByZWR1Y2VyRGVmaW5pdGlvbiA9IHJlZHVjZXJzW3JlZHVjZXJOYW1lXTtcbiAgICAgIGNvbnN0IHJlZHVjZXJEZXRhaWxzID0ge1xuICAgICAgICByZWR1Y2VyTmFtZSxcbiAgICAgICAgdHlwZTogZ2V0VHlwZShuYW1lLCByZWR1Y2VyTmFtZSksXG4gICAgICAgIGNyZWF0ZU5vdGF0aW9uOiB0eXBlb2Ygb3B0aW9ucy5yZWR1Y2VycyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICB9O1xuICAgICAgaWYgKGlzQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRlZmluaXRpb24pKSB7XG4gICAgICAgIGhhbmRsZVRodW5rQ2FzZVJlZHVjZXJEZWZpbml0aW9uKHJlZHVjZXJEZXRhaWxzLCByZWR1Y2VyRGVmaW5pdGlvbiwgY29udGV4dE1ldGhvZHMsIGNBVCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVOb3JtYWxSZWR1Y2VyRGVmaW5pdGlvbihyZWR1Y2VyRGV0YWlscywgcmVkdWNlckRlZmluaXRpb24sIGNvbnRleHRNZXRob2RzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBidWlsZFJlZHVjZXIoKSB7XG4gICAgICBpZiAodHJ1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZXh0cmFSZWR1Y2VycyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmYWxzZSA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNCgxNCkgOiBcIlRoZSBvYmplY3Qgbm90YXRpb24gZm9yIGBjcmVhdGVTbGljZS5leHRyYVJlZHVjZXJzYCBoYXMgYmVlbiByZW1vdmVkLiBQbGVhc2UgdXNlIHRoZSAnYnVpbGRlciBjYWxsYmFjaycgbm90YXRpb24gaW5zdGVhZDogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9hcGkvY3JlYXRlU2xpY2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IFtleHRyYVJlZHVjZXJzID0ge30sIGFjdGlvbk1hdGNoZXJzID0gW10sIGRlZmF1bHRDYXNlUmVkdWNlciA9IHZvaWQgMF0gPSB0eXBlb2Ygb3B0aW9ucy5leHRyYVJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCIgPyBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhvcHRpb25zLmV4dHJhUmVkdWNlcnMpIDogW29wdGlvbnMuZXh0cmFSZWR1Y2Vyc107XG4gICAgICBjb25zdCBmaW5hbENhc2VSZWR1Y2VycyA9IHtcbiAgICAgICAgLi4uZXh0cmFSZWR1Y2VycyxcbiAgICAgICAgLi4uY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZVxuICAgICAgfTtcbiAgICAgIHJldHVybiBjcmVhdGVSZWR1Y2VyKG9wdGlvbnMuaW5pdGlhbFN0YXRlLCAoYnVpbGRlcikgPT4ge1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gZmluYWxDYXNlUmVkdWNlcnMpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZENhc2Uoa2V5LCBmaW5hbENhc2VSZWR1Y2Vyc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBzTSBvZiBjb250ZXh0LnNsaWNlTWF0Y2hlcnMpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZE1hdGNoZXIoc00ubWF0Y2hlciwgc00ucmVkdWNlcik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbSBvZiBhY3Rpb25NYXRjaGVycykge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkTWF0Y2hlcihtLm1hdGNoZXIsIG0ucmVkdWNlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkRGVmYXVsdENhc2UoZGVmYXVsdENhc2VSZWR1Y2VyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdFNlbGYgPSAoc3RhdGUpID0+IHN0YXRlO1xuICAgIGNvbnN0IGluamVjdGVkU2VsZWN0b3JDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IF9yZWR1Y2VyO1xuICAgIGZ1bmN0aW9uIHJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgICAgaWYgKCFfcmVkdWNlcilcbiAgICAgICAgX3JlZHVjZXIgPSBidWlsZFJlZHVjZXIoKTtcbiAgICAgIHJldHVybiBfcmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgICAgaWYgKCFfcmVkdWNlcilcbiAgICAgICAgX3JlZHVjZXIgPSBidWlsZFJlZHVjZXIoKTtcbiAgICAgIHJldHVybiBfcmVkdWNlci5nZXRJbml0aWFsU3RhdGUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVNlbGVjdG9yUHJvcHMocmVkdWNlclBhdGgyLCBpbmplY3RlZCA9IGZhbHNlKSB7XG4gICAgICBmdW5jdGlvbiBzZWxlY3RTbGljZShzdGF0ZSkge1xuICAgICAgICBsZXQgc2xpY2VTdGF0ZSA9IHN0YXRlW3JlZHVjZXJQYXRoMl07XG4gICAgICAgIGlmICh0eXBlb2Ygc2xpY2VTdGF0ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGlmIChpbmplY3RlZCkge1xuICAgICAgICAgICAgc2xpY2VTdGF0ZSA9IGdldEluaXRpYWxTdGF0ZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZhbHNlID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U1KDE1KSA6IFwic2VsZWN0U2xpY2UgcmV0dXJuZWQgdW5kZWZpbmVkIGZvciBhbiB1bmluamVjdGVkIHNsaWNlIHJlZHVjZXJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzbGljZVN0YXRlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2V0U2VsZWN0b3JzKHNlbGVjdFN0YXRlID0gc2VsZWN0U2VsZikge1xuICAgICAgICBjb25zdCBzZWxlY3RvckNhY2hlID0gZW1wbGFjZShpbmplY3RlZFNlbGVjdG9yQ2FjaGUsIGluamVjdGVkLCB7XG4gICAgICAgICAgaW5zZXJ0OiAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVtcGxhY2Uoc2VsZWN0b3JDYWNoZSwgc2VsZWN0U3RhdGUsIHtcbiAgICAgICAgICBpbnNlcnQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZTIsIHNlbGVjdG9yXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zLnNlbGVjdG9ycyA/PyB7fSkpIHtcbiAgICAgICAgICAgICAgbWFwW25hbWUyXSA9IHdyYXBTZWxlY3RvcihzZWxlY3Rvciwgc2VsZWN0U3RhdGUsIGdldEluaXRpYWxTdGF0ZSwgaW5qZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVkdWNlclBhdGg6IHJlZHVjZXJQYXRoMixcbiAgICAgICAgZ2V0U2VsZWN0b3JzLFxuICAgICAgICBnZXQgc2VsZWN0b3JzKCkge1xuICAgICAgICAgIHJldHVybiBnZXRTZWxlY3RvcnMoc2VsZWN0U2xpY2UpO1xuICAgICAgICB9LFxuICAgICAgICBzZWxlY3RTbGljZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2xpY2UgPSB7XG4gICAgICBuYW1lLFxuICAgICAgcmVkdWNlcixcbiAgICAgIGFjdGlvbnM6IGNvbnRleHQuYWN0aW9uQ3JlYXRvcnMsXG4gICAgICBjYXNlUmVkdWNlcnM6IGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWUsXG4gICAgICBnZXRJbml0aWFsU3RhdGUsXG4gICAgICAuLi5tYWtlU2VsZWN0b3JQcm9wcyhyZWR1Y2VyUGF0aCksXG4gICAgICBpbmplY3RJbnRvKGluamVjdGFibGUsIHtcbiAgICAgICAgcmVkdWNlclBhdGg6IHBhdGhPcHQsXG4gICAgICAgIC4uLmNvbmZpZ1xuICAgICAgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG5ld1JlZHVjZXJQYXRoID0gcGF0aE9wdCA/PyByZWR1Y2VyUGF0aDtcbiAgICAgICAgaW5qZWN0YWJsZS5pbmplY3Qoe1xuICAgICAgICAgIHJlZHVjZXJQYXRoOiBuZXdSZWR1Y2VyUGF0aCxcbiAgICAgICAgICByZWR1Y2VyXG4gICAgICAgIH0sIGNvbmZpZyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc2xpY2UsXG4gICAgICAgICAgLi4ubWFrZVNlbGVjdG9yUHJvcHMobmV3UmVkdWNlclBhdGgsIHRydWUpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gc2xpY2U7XG4gIH07XG59XG5mdW5jdGlvbiB3cmFwU2VsZWN0b3Ioc2VsZWN0b3IsIHNlbGVjdFN0YXRlLCBnZXRJbml0aWFsU3RhdGUsIGluamVjdGVkKSB7XG4gIGZ1bmN0aW9uIHdyYXBwZXIocm9vdFN0YXRlLCAuLi5hcmdzKSB7XG4gICAgbGV0IHNsaWNlU3RhdGUgPSBzZWxlY3RTdGF0ZShyb290U3RhdGUpO1xuICAgIGlmICh0eXBlb2Ygc2xpY2VTdGF0ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKGluamVjdGVkKSB7XG4gICAgICAgIHNsaWNlU3RhdGUgPSBnZXRJbml0aWFsU3RhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAodHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTYoMTYpIDogXCJzZWxlY3RTdGF0ZSByZXR1cm5lZCB1bmRlZmluZWQgZm9yIGFuIHVuaW5qZWN0ZWQgc2xpY2UgcmVkdWNlclwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdG9yKHNsaWNlU3RhdGUsIC4uLmFyZ3MpO1xuICB9XG4gIHdyYXBwZXIudW53cmFwcGVkID0gc2VsZWN0b3I7XG4gIHJldHVybiB3cmFwcGVyO1xufVxudmFyIGNyZWF0ZVNsaWNlID0gLyogQF9fUFVSRV9fICovIGJ1aWxkQ3JlYXRlU2xpY2UoKTtcbmZ1bmN0aW9uIGJ1aWxkUmVkdWNlckNyZWF0b3JzKCkge1xuICBmdW5jdGlvbiBhc3luY1RodW5rKHBheWxvYWRDcmVhdG9yLCBjb25maWcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX3JlZHVjZXJEZWZpbml0aW9uVHlwZTogXCJhc3luY1RodW5rXCIgLyogYXN5bmNUaHVuayAqLyxcbiAgICAgIHBheWxvYWRDcmVhdG9yLFxuICAgICAgLi4uY29uZmlnXG4gICAgfTtcbiAgfVxuICBhc3luY1RodW5rLndpdGhUeXBlcyA9ICgpID0+IGFzeW5jVGh1bms7XG4gIHJldHVybiB7XG4gICAgcmVkdWNlcihjYXNlUmVkdWNlcikge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAvLyBoYWNrIHNvIHRoZSB3cmFwcGluZyBmdW5jdGlvbiBoYXMgdGhlIHNhbWUgbmFtZSBhcyB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gd2UgbmVlZCB0byBjcmVhdGUgYSB3cmFwcGVyIHNvIHRoZSBgcmVkdWNlckRlZmluaXRpb25UeXBlYCBpcyBub3QgYXNzaWduZWQgdG8gdGhlIG9yaWdpbmFsXG4gICAgICAgIFtjYXNlUmVkdWNlci5uYW1lXSguLi5hcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIGNhc2VSZWR1Y2VyKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9W2Nhc2VSZWR1Y2VyLm5hbWVdLCB7XG4gICAgICAgIF9yZWR1Y2VyRGVmaW5pdGlvblR5cGU6IFwicmVkdWNlclwiIC8qIHJlZHVjZXIgKi9cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcHJlcGFyZWRSZWR1Y2VyKHByZXBhcmUsIHJlZHVjZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9yZWR1Y2VyRGVmaW5pdGlvblR5cGU6IFwicmVkdWNlcldpdGhQcmVwYXJlXCIgLyogcmVkdWNlcldpdGhQcmVwYXJlICovLFxuICAgICAgICBwcmVwYXJlLFxuICAgICAgICByZWR1Y2VyXG4gICAgICB9O1xuICAgIH0sXG4gICAgYXN5bmNUaHVua1xuICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlTm9ybWFsUmVkdWNlckRlZmluaXRpb24oe1xuICB0eXBlLFxuICByZWR1Y2VyTmFtZSxcbiAgY3JlYXRlTm90YXRpb25cbn0sIG1heWJlUmVkdWNlcldpdGhQcmVwYXJlLCBjb250ZXh0KSB7XG4gIGxldCBjYXNlUmVkdWNlcjtcbiAgbGV0IHByZXBhcmVDYWxsYmFjaztcbiAgaWYgKFwicmVkdWNlclwiIGluIG1heWJlUmVkdWNlcldpdGhQcmVwYXJlKSB7XG4gICAgaWYgKGNyZWF0ZU5vdGF0aW9uICYmICFpc0Nhc2VSZWR1Y2VyV2l0aFByZXBhcmVEZWZpbml0aW9uKG1heWJlUmVkdWNlcldpdGhQcmVwYXJlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGZhbHNlID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U3KDE3KSA6IFwiUGxlYXNlIHVzZSB0aGUgYGNyZWF0ZS5wcmVwYXJlZFJlZHVjZXJgIG5vdGF0aW9uIGZvciBwcmVwYXJlZCBhY3Rpb24gY3JlYXRvcnMgd2l0aCB0aGUgYGNyZWF0ZWAgbm90YXRpb24uXCIpO1xuICAgIH1cbiAgICBjYXNlUmVkdWNlciA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlLnJlZHVjZXI7XG4gICAgcHJlcGFyZUNhbGxiYWNrID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUucHJlcGFyZTtcbiAgfSBlbHNlIHtcbiAgICBjYXNlUmVkdWNlciA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlO1xuICB9XG4gIGNvbnRleHQuYWRkQ2FzZSh0eXBlLCBjYXNlUmVkdWNlcikuZXhwb3NlQ2FzZVJlZHVjZXIocmVkdWNlck5hbWUsIGNhc2VSZWR1Y2VyKS5leHBvc2VBY3Rpb24ocmVkdWNlck5hbWUsIHByZXBhcmVDYWxsYmFjayA/IGNyZWF0ZUFjdGlvbih0eXBlLCBwcmVwYXJlQ2FsbGJhY2spIDogY3JlYXRlQWN0aW9uKHR5cGUpKTtcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRlZmluaXRpb24pIHtcbiAgcmV0dXJuIHJlZHVjZXJEZWZpbml0aW9uLl9yZWR1Y2VyRGVmaW5pdGlvblR5cGUgPT09IFwiYXN5bmNUaHVua1wiIC8qIGFzeW5jVGh1bmsgKi87XG59XG5mdW5jdGlvbiBpc0Nhc2VSZWR1Y2VyV2l0aFByZXBhcmVEZWZpbml0aW9uKHJlZHVjZXJEZWZpbml0aW9uKSB7XG4gIHJldHVybiByZWR1Y2VyRGVmaW5pdGlvbi5fcmVkdWNlckRlZmluaXRpb25UeXBlID09PSBcInJlZHVjZXJXaXRoUHJlcGFyZVwiIC8qIHJlZHVjZXJXaXRoUHJlcGFyZSAqLztcbn1cbmZ1bmN0aW9uIGhhbmRsZVRodW5rQ2FzZVJlZHVjZXJEZWZpbml0aW9uKHtcbiAgdHlwZSxcbiAgcmVkdWNlck5hbWVcbn0sIHJlZHVjZXJEZWZpbml0aW9uLCBjb250ZXh0LCBjQVQpIHtcbiAgaWYgKCFjQVQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTgoMTgpIDogXCJDYW5ub3QgdXNlIGBjcmVhdGUuYXN5bmNUaHVua2AgaW4gdGhlIGJ1aWx0LWluIGBjcmVhdGVTbGljZWAuIFVzZSBgYnVpbGRDcmVhdGVTbGljZSh7IGNyZWF0b3JzOiB7IGFzeW5jVGh1bms6IGFzeW5jVGh1bmtDcmVhdG9yIH0gfSlgIHRvIGNyZWF0ZSBhIGN1c3RvbWlzZWQgdmVyc2lvbiBvZiBgY3JlYXRlU2xpY2VgLlwiKTtcbiAgfVxuICBjb25zdCB7XG4gICAgcGF5bG9hZENyZWF0b3IsXG4gICAgZnVsZmlsbGVkLFxuICAgIHBlbmRpbmcsXG4gICAgcmVqZWN0ZWQsXG4gICAgc2V0dGxlZCxcbiAgICBvcHRpb25zXG4gIH0gPSByZWR1Y2VyRGVmaW5pdGlvbjtcbiAgY29uc3QgdGh1bmsgPSBjQVQodHlwZSwgcGF5bG9hZENyZWF0b3IsIG9wdGlvbnMpO1xuICBjb250ZXh0LmV4cG9zZUFjdGlvbihyZWR1Y2VyTmFtZSwgdGh1bmspO1xuICBpZiAoZnVsZmlsbGVkKSB7XG4gICAgY29udGV4dC5hZGRDYXNlKHRodW5rLmZ1bGZpbGxlZCwgZnVsZmlsbGVkKTtcbiAgfVxuICBpZiAocGVuZGluZykge1xuICAgIGNvbnRleHQuYWRkQ2FzZSh0aHVuay5wZW5kaW5nLCBwZW5kaW5nKTtcbiAgfVxuICBpZiAocmVqZWN0ZWQpIHtcbiAgICBjb250ZXh0LmFkZENhc2UodGh1bmsucmVqZWN0ZWQsIHJlamVjdGVkKTtcbiAgfVxuICBpZiAoc2V0dGxlZCkge1xuICAgIGNvbnRleHQuYWRkTWF0Y2hlcih0aHVuay5zZXR0bGVkLCBzZXR0bGVkKTtcbiAgfVxuICBjb250ZXh0LmV4cG9zZUNhc2VSZWR1Y2VyKHJlZHVjZXJOYW1lLCB7XG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQgfHwgbm9vcCxcbiAgICBwZW5kaW5nOiBwZW5kaW5nIHx8IG5vb3AsXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkIHx8IG5vb3AsXG4gICAgc2V0dGxlZDogc2V0dGxlZCB8fCBub29wXG4gIH0pO1xufVxuZnVuY3Rpb24gbm9vcCgpIHtcbn1cblxuLy8gc3JjL2VudGl0aWVzL2VudGl0eV9zdGF0ZS50c1xuZnVuY3Rpb24gZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCkge1xuICByZXR1cm4ge1xuICAgIGlkczogW10sXG4gICAgZW50aXRpZXM6IHt9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5KHN0YXRlQWRhcHRlcikge1xuICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoYWRkaXRpb25hbFN0YXRlID0ge30sIGVudGl0aWVzKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBPYmplY3QuYXNzaWduKGdldEluaXRpYWxFbnRpdHlTdGF0ZSgpLCBhZGRpdGlvbmFsU3RhdGUpO1xuICAgIHJldHVybiBlbnRpdGllcyA/IHN0YXRlQWRhcHRlci5zZXRBbGwoc3RhdGUsIGVudGl0aWVzKSA6IHN0YXRlO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0SW5pdGlhbFN0YXRlXG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy9zdGF0ZV9zZWxlY3RvcnMudHNcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkoKSB7XG4gIGZ1bmN0aW9uIGdldFNlbGVjdG9ycyhzZWxlY3RTdGF0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgY3JlYXRlU2VsZWN0b3I6IGNyZWF0ZVNlbGVjdG9yMiA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc2VsZWN0SWRzID0gKHN0YXRlKSA9PiBzdGF0ZS5pZHM7XG4gICAgY29uc3Qgc2VsZWN0RW50aXRpZXMgPSAoc3RhdGUpID0+IHN0YXRlLmVudGl0aWVzO1xuICAgIGNvbnN0IHNlbGVjdEFsbCA9IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RJZHMsIHNlbGVjdEVudGl0aWVzLCAoaWRzLCBlbnRpdGllcykgPT4gaWRzLm1hcCgoaWQpID0+IGVudGl0aWVzW2lkXSkpO1xuICAgIGNvbnN0IHNlbGVjdElkID0gKF8sIGlkKSA9PiBpZDtcbiAgICBjb25zdCBzZWxlY3RCeUlkID0gKGVudGl0aWVzLCBpZCkgPT4gZW50aXRpZXNbaWRdO1xuICAgIGNvbnN0IHNlbGVjdFRvdGFsID0gY3JlYXRlU2VsZWN0b3IyKHNlbGVjdElkcywgKGlkcykgPT4gaWRzLmxlbmd0aCk7XG4gICAgaWYgKCFzZWxlY3RTdGF0ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0SWRzLFxuICAgICAgICBzZWxlY3RFbnRpdGllcyxcbiAgICAgICAgc2VsZWN0QWxsLFxuICAgICAgICBzZWxlY3RUb3RhbCxcbiAgICAgICAgc2VsZWN0QnlJZDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdEVudGl0aWVzLCBzZWxlY3RJZCwgc2VsZWN0QnlJZClcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyA9IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0RW50aXRpZXMpO1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RJZHM6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0SWRzKSxcbiAgICAgIHNlbGVjdEVudGl0aWVzOiBzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMsXG4gICAgICBzZWxlY3RBbGw6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0QWxsKSxcbiAgICAgIHNlbGVjdFRvdGFsOiBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0U3RhdGUsIHNlbGVjdFRvdGFsKSxcbiAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMsIHNlbGVjdElkLCBzZWxlY3RCeUlkKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRTZWxlY3RvcnNcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3N0YXRlX2FkYXB0ZXIudHNcbnZhciBpbXBvcnRfaW1tZXI0ID0gcmVxdWlyZShcImltbWVyXCIpO1xudmFyIGlzRHJhZnRUeXBlZCA9IGltcG9ydF9pbW1lcjQuaXNEcmFmdDtcbmZ1bmN0aW9uIGNyZWF0ZVNpbmdsZUFyZ3VtZW50U3RhdGVPcGVyYXRvcihtdXRhdG9yKSB7XG4gIGNvbnN0IG9wZXJhdG9yID0gY3JlYXRlU3RhdGVPcGVyYXRvcigoXywgc3RhdGUpID0+IG11dGF0b3Ioc3RhdGUpKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9wZXJhdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiBvcGVyYXRvcihzdGF0ZSwgdm9pZCAwKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlT3BlcmF0b3IobXV0YXRvcikge1xuICByZXR1cm4gZnVuY3Rpb24gb3BlcmF0aW9uKHN0YXRlLCBhcmcpIHtcbiAgICBmdW5jdGlvbiBpc1BheWxvYWRBY3Rpb25Bcmd1bWVudChhcmcyKSB7XG4gICAgICByZXR1cm4gaXNGU0EoYXJnMik7XG4gICAgfVxuICAgIGNvbnN0IHJ1bk11dGF0b3IgPSAoZHJhZnQpID0+IHtcbiAgICAgIGlmIChpc1BheWxvYWRBY3Rpb25Bcmd1bWVudChhcmcpKSB7XG4gICAgICAgIG11dGF0b3IoYXJnLnBheWxvYWQsIGRyYWZ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG11dGF0b3IoYXJnLCBkcmFmdCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNEcmFmdFR5cGVkKHN0YXRlKSkge1xuICAgICAgcnVuTXV0YXRvcihzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIHJldHVybiAoMCwgaW1wb3J0X2ltbWVyNC5wcm9kdWNlKShzdGF0ZSwgcnVuTXV0YXRvcik7XG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy91dGlscy50c1xuZnVuY3Rpb24gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKSB7XG4gIGNvbnN0IGtleSA9IHNlbGVjdElkKGVudGl0eSk7XG4gIGlmIChrZXkgPT09IHZvaWQgMCkge1xuICAgIGNvbnNvbGUud2FybihcIlRoZSBlbnRpdHkgcGFzc2VkIHRvIHRoZSBgc2VsZWN0SWRgIGltcGxlbWVudGF0aW9uIHJldHVybmVkIHVuZGVmaW5lZC5cIiwgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHByb3ZpZGUgeW91ciBvd24gYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbi5cIiwgXCJUaGUgZW50aXR5IHRoYXQgd2FzIHBhc3NlZDpcIiwgZW50aXR5LCBcIlRoZSBgc2VsZWN0SWRgIGltcGxlbWVudGF0aW9uOlwiLCBzZWxlY3RJZC50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4ga2V5O1xufVxuZnVuY3Rpb24gZW5zdXJlRW50aXRpZXNBcnJheShlbnRpdGllcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZW50aXRpZXMpKSB7XG4gICAgZW50aXRpZXMgPSBPYmplY3QudmFsdWVzKGVudGl0aWVzKTtcbiAgfVxuICByZXR1cm4gZW50aXRpZXM7XG59XG5mdW5jdGlvbiBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpIHtcbiAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgY29uc3QgYWRkZWQgPSBbXTtcbiAgY29uc3QgdXBkYXRlZCA9IFtdO1xuICBmb3IgKGNvbnN0IGVudGl0eSBvZiBuZXdFbnRpdGllcykge1xuICAgIGNvbnN0IGlkID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcbiAgICBpZiAoaWQgaW4gc3RhdGUuZW50aXRpZXMpIHtcbiAgICAgIHVwZGF0ZWQucHVzaCh7XG4gICAgICAgIGlkLFxuICAgICAgICBjaGFuZ2VzOiBlbnRpdHlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGRlZC5wdXNoKGVudGl0eSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBbYWRkZWQsIHVwZGF0ZWRdO1xufVxuXG4vLyBzcmMvZW50aXRpZXMvdW5zb3J0ZWRfc3RhdGVfYWRhcHRlci50c1xuZnVuY3Rpb24gY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpIHtcbiAgZnVuY3Rpb24gYWRkT25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XG4gICAgY29uc3Qga2V5ID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcbiAgICBpZiAoa2V5IGluIHN0YXRlLmVudGl0aWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0YXRlLmlkcy5wdXNoKGtleSk7XG4gICAgc3RhdGUuZW50aXRpZXNba2V5XSA9IGVudGl0eTtcbiAgfVxuICBmdW5jdGlvbiBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIG5ld0VudGl0aWVzKSB7XG4gICAgICBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICBjb25zdCBrZXkgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xuICAgIGlmICghKGtleSBpbiBzdGF0ZS5lbnRpdGllcykpIHtcbiAgICAgIHN0YXRlLmlkcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIDtcbiAgICBzdGF0ZS5lbnRpdGllc1trZXldID0gZW50aXR5O1xuICB9XG4gIGZ1bmN0aW9uIHNldE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgbmV3RW50aXRpZXMpIHtcbiAgICAgIHNldE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldEFsbE11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBzdGF0ZS5pZHMgPSBbXTtcbiAgICBzdGF0ZS5lbnRpdGllcyA9IHt9O1xuICAgIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlT25lTXV0YWJseShrZXksIHN0YXRlKSB7XG4gICAgcmV0dXJuIHJlbW92ZU1hbnlNdXRhYmx5KFtrZXldLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlTWFueU11dGFibHkoa2V5cywgc3RhdGUpIHtcbiAgICBsZXQgZGlkTXV0YXRlID0gZmFsc2U7XG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmIChrZXkgaW4gc3RhdGUuZW50aXRpZXMpIHtcbiAgICAgICAgZGVsZXRlIHN0YXRlLmVudGl0aWVzW2tleV07XG4gICAgICAgIGRpZE11dGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGRpZE11dGF0ZSkge1xuICAgICAgc3RhdGUuaWRzID0gc3RhdGUuaWRzLmZpbHRlcigoaWQpID0+IGlkIGluIHN0YXRlLmVudGl0aWVzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlQWxsTXV0YWJseShzdGF0ZSkge1xuICAgIE9iamVjdC5hc3NpZ24oc3RhdGUsIHtcbiAgICAgIGlkczogW10sXG4gICAgICBlbnRpdGllczoge31cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiB0YWtlTmV3S2V5KGtleXMsIHVwZGF0ZSwgc3RhdGUpIHtcbiAgICBjb25zdCBvcmlnaW5hbDMgPSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xuICAgIGlmIChvcmlnaW5hbDMgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVkID0gT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luYWwzLCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgY29uc3QgbmV3S2V5ID0gc2VsZWN0SWRWYWx1ZSh1cGRhdGVkLCBzZWxlY3RJZCk7XG4gICAgY29uc3QgaGFzTmV3S2V5ID0gbmV3S2V5ICE9PSB1cGRhdGUuaWQ7XG4gICAgaWYgKGhhc05ld0tleSkge1xuICAgICAga2V5c1t1cGRhdGUuaWRdID0gbmV3S2V5O1xuICAgICAgZGVsZXRlIHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XG4gICAgfVxuICAgIDtcbiAgICBzdGF0ZS5lbnRpdGllc1tuZXdLZXldID0gdXBkYXRlZDtcbiAgICByZXR1cm4gaGFzTmV3S2V5O1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZU9uZU11dGFibHkodXBkYXRlLCBzdGF0ZSkge1xuICAgIHJldHVybiB1cGRhdGVNYW55TXV0YWJseShbdXBkYXRlXSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZXMsIHN0YXRlKSB7XG4gICAgY29uc3QgbmV3S2V5cyA9IHt9O1xuICAgIGNvbnN0IHVwZGF0ZXNQZXJFbnRpdHkgPSB7fTtcbiAgICB1cGRhdGVzLmZvckVhY2goKHVwZGF0ZSkgPT4ge1xuICAgICAgaWYgKHVwZGF0ZS5pZCBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgICB1cGRhdGVzUGVyRW50aXR5W3VwZGF0ZS5pZF0gPSB7XG4gICAgICAgICAgaWQ6IHVwZGF0ZS5pZCxcbiAgICAgICAgICAvLyBTcHJlYWRzIGlnbm9yZSBmYWxzeSB2YWx1ZXMsIHNvIHRoaXMgd29ya3MgZXZlbiBpZiB0aGVyZSBpc24ndFxuICAgICAgICAgIC8vIGFuIGV4aXN0aW5nIHVwZGF0ZSBhbHJlYWR5IGF0IHRoaXMga2V5XG4gICAgICAgICAgY2hhbmdlczoge1xuICAgICAgICAgICAgLi4udXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdID8gdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdLmNoYW5nZXMgOiBudWxsLFxuICAgICAgICAgICAgLi4udXBkYXRlLmNoYW5nZXNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgdXBkYXRlcyA9IE9iamVjdC52YWx1ZXModXBkYXRlc1BlckVudGl0eSk7XG4gICAgY29uc3QgZGlkTXV0YXRlRW50aXRpZXMgPSB1cGRhdGVzLmxlbmd0aCA+IDA7XG4gICAgaWYgKGRpZE11dGF0ZUVudGl0aWVzKSB7XG4gICAgICBjb25zdCBkaWRNdXRhdGVJZHMgPSB1cGRhdGVzLmZpbHRlcigodXBkYXRlKSA9PiB0YWtlTmV3S2V5KG5ld0tleXMsIHVwZGF0ZSwgc3RhdGUpKS5sZW5ndGggPiAwO1xuICAgICAgaWYgKGRpZE11dGF0ZUlkcykge1xuICAgICAgICBzdGF0ZS5pZHMgPSBPYmplY3QudmFsdWVzKHN0YXRlLmVudGl0aWVzKS5tYXAoKGUpID0+IHNlbGVjdElkVmFsdWUoZSwgc2VsZWN0SWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBzZXJ0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XG4gICAgcmV0dXJuIHVwc2VydE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBzZXJ0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgY29uc3QgW2FkZGVkLCB1cGRhdGVkXSA9IHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSk7XG4gICAgdXBkYXRlTWFueU11dGFibHkodXBkYXRlZCwgc3RhdGUpO1xuICAgIGFkZE1hbnlNdXRhYmx5KGFkZGVkLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZW1vdmVBbGw6IGNyZWF0ZVNpbmdsZUFyZ3VtZW50U3RhdGVPcGVyYXRvcihyZW1vdmVBbGxNdXRhYmx5KSxcbiAgICBhZGRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkT25lTXV0YWJseSksXG4gICAgYWRkTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRNYW55TXV0YWJseSksXG4gICAgc2V0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE9uZU11dGFibHkpLFxuICAgIHNldE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0TWFueU11dGFibHkpLFxuICAgIHNldEFsbDogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRBbGxNdXRhYmx5KSxcbiAgICB1cGRhdGVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlT25lTXV0YWJseSksXG4gICAgdXBkYXRlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVNYW55TXV0YWJseSksXG4gICAgdXBzZXJ0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE9uZU11dGFibHkpLFxuICAgIHVwc2VydE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0TWFueU11dGFibHkpLFxuICAgIHJlbW92ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihyZW1vdmVPbmVNdXRhYmx5KSxcbiAgICByZW1vdmVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHJlbW92ZU1hbnlNdXRhYmx5KVxuICB9O1xufVxuXG4vLyBzcmMvZW50aXRpZXMvc29ydGVkX3N0YXRlX2FkYXB0ZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCwgc29ydCkge1xuICBjb25zdCB7XG4gICAgcmVtb3ZlT25lLFxuICAgIHJlbW92ZU1hbnksXG4gICAgcmVtb3ZlQWxsXG4gIH0gPSBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCk7XG4gIGZ1bmN0aW9uIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIHJldHVybiBhZGRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgY29uc3QgbW9kZWxzID0gbmV3RW50aXRpZXMuZmlsdGVyKChtb2RlbCkgPT4gIShzZWxlY3RJZFZhbHVlKG1vZGVsLCBzZWxlY3RJZCkgaW4gc3RhdGUuZW50aXRpZXMpKTtcbiAgICBpZiAobW9kZWxzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgbWVyZ2UobW9kZWxzLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIHJldHVybiBzZXRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHNldE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgaWYgKG5ld0VudGl0aWVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgbWVyZ2UobmV3RW50aXRpZXMsIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0QWxsTXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIHN0YXRlLmVudGl0aWVzID0ge307XG4gICAgc3RhdGUuaWRzID0gW107XG4gICAgYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVzLCBzdGF0ZSkge1xuICAgIGxldCBhcHBsaWVkVXBkYXRlcyA9IGZhbHNlO1xuICAgIGZvciAobGV0IHVwZGF0ZSBvZiB1cGRhdGVzKSB7XG4gICAgICBjb25zdCBlbnRpdHkgPSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xuICAgICAgaWYgKCFlbnRpdHkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBhcHBsaWVkVXBkYXRlcyA9IHRydWU7XG4gICAgICBPYmplY3QuYXNzaWduKGVudGl0eSwgdXBkYXRlLmNoYW5nZXMpO1xuICAgICAgY29uc3QgbmV3SWQgPSBzZWxlY3RJZChlbnRpdHkpO1xuICAgICAgaWYgKHVwZGF0ZS5pZCAhPT0gbmV3SWQpIHtcbiAgICAgICAgZGVsZXRlIHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XG4gICAgICAgIHN0YXRlLmVudGl0aWVzW25ld0lkXSA9IGVudGl0eTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFwcGxpZWRVcGRhdGVzKSB7XG4gICAgICByZXNvcnRFbnRpdGllcyhzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIGNvbnN0IFthZGRlZCwgdXBkYXRlZF0gPSBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpO1xuICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcbiAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIGFyZUFycmF5c0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGggJiYgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldID09PSBiW2ldKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBtZXJnZShtb2RlbHMsIHN0YXRlKSB7XG4gICAgbW9kZWxzLmZvckVhY2goKG1vZGVsKSA9PiB7XG4gICAgICA7XG4gICAgICBzdGF0ZS5lbnRpdGllc1tzZWxlY3RJZChtb2RlbCldID0gbW9kZWw7XG4gICAgfSk7XG4gICAgcmVzb3J0RW50aXRpZXMoc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc29ydEVudGl0aWVzKHN0YXRlKSB7XG4gICAgY29uc3QgYWxsRW50aXRpZXMgPSBPYmplY3QudmFsdWVzKHN0YXRlLmVudGl0aWVzKTtcbiAgICBhbGxFbnRpdGllcy5zb3J0KHNvcnQpO1xuICAgIGNvbnN0IG5ld1NvcnRlZElkcyA9IGFsbEVudGl0aWVzLm1hcChzZWxlY3RJZCk7XG4gICAgY29uc3Qge1xuICAgICAgaWRzXG4gICAgfSA9IHN0YXRlO1xuICAgIGlmICghYXJlQXJyYXlzRXF1YWwoaWRzLCBuZXdTb3J0ZWRJZHMpKSB7XG4gICAgICBzdGF0ZS5pZHMgPSBuZXdTb3J0ZWRJZHM7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgcmVtb3ZlT25lLFxuICAgIHJlbW92ZU1hbnksXG4gICAgcmVtb3ZlQWxsLFxuICAgIGFkZE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRPbmVNdXRhYmx5KSxcbiAgICB1cGRhdGVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlT25lTXV0YWJseSksXG4gICAgdXBzZXJ0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE9uZU11dGFibHkpLFxuICAgIHNldE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRPbmVNdXRhYmx5KSxcbiAgICBzZXRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE1hbnlNdXRhYmx5KSxcbiAgICBzZXRBbGw6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0QWxsTXV0YWJseSksXG4gICAgYWRkTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRNYW55TXV0YWJseSksXG4gICAgdXBkYXRlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVNYW55TXV0YWJseSksXG4gICAgdXBzZXJ0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRNYW55TXV0YWJseSlcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL2NyZWF0ZV9hZGFwdGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVFbnRpdHlBZGFwdGVyKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgc2VsZWN0SWQsXG4gICAgc29ydENvbXBhcmVyXG4gIH0gPSB7XG4gICAgc29ydENvbXBhcmVyOiBmYWxzZSxcbiAgICBzZWxlY3RJZDogKGluc3RhbmNlKSA9PiBpbnN0YW5jZS5pZCxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGNvbnN0IHN0YXRlQWRhcHRlciA9IHNvcnRDb21wYXJlciA/IGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCwgc29ydENvbXBhcmVyKSA6IGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKTtcbiAgY29uc3Qgc3RhdGVGYWN0b3J5ID0gY3JlYXRlSW5pdGlhbFN0YXRlRmFjdG9yeShzdGF0ZUFkYXB0ZXIpO1xuICBjb25zdCBzZWxlY3RvcnNGYWN0b3J5ID0gY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSgpO1xuICByZXR1cm4ge1xuICAgIHNlbGVjdElkLFxuICAgIHNvcnRDb21wYXJlcixcbiAgICAuLi5zdGF0ZUZhY3RvcnksXG4gICAgLi4uc2VsZWN0b3JzRmFjdG9yeSxcbiAgICAuLi5zdGF0ZUFkYXB0ZXJcbiAgfTtcbn1cblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS9pbmRleC50c1xudmFyIGltcG9ydF9yZWR1eDUgPSByZXF1aXJlKFwicmVkdXhcIik7XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvZXhjZXB0aW9ucy50c1xudmFyIHRhc2sgPSBcInRhc2tcIjtcbnZhciBsaXN0ZW5lciA9IFwibGlzdGVuZXJcIjtcbnZhciBjb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xudmFyIGNhbmNlbGxlZCA9IFwiY2FuY2VsbGVkXCI7XG52YXIgdGFza0NhbmNlbGxlZCA9IGB0YXNrLSR7Y2FuY2VsbGVkfWA7XG52YXIgdGFza0NvbXBsZXRlZCA9IGB0YXNrLSR7Y29tcGxldGVkfWA7XG52YXIgbGlzdGVuZXJDYW5jZWxsZWQgPSBgJHtsaXN0ZW5lcn0tJHtjYW5jZWxsZWR9YDtcbnZhciBsaXN0ZW5lckNvbXBsZXRlZCA9IGAke2xpc3RlbmVyfS0ke2NvbXBsZXRlZH1gO1xudmFyIFRhc2tBYm9ydEVycm9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBgJHt0YXNrfSAke2NhbmNlbGxlZH0gKHJlYXNvbjogJHtjb2RlfSlgO1xuICB9XG4gIG5hbWUgPSBcIlRhc2tBYm9ydEVycm9yXCI7XG4gIG1lc3NhZ2U7XG59O1xuXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL3V0aWxzLnRzXG52YXIgYXNzZXJ0RnVuY3Rpb24gPSAoZnVuYywgZXhwZWN0ZWQpID0+IHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMikgOiBgJHtleHBlY3RlZH0gaXMgbm90IGEgZnVuY3Rpb25gKTtcbiAgfVxufTtcbnZhciBub29wMiA9ICgpID0+IHtcbn07XG52YXIgY2F0Y2hSZWplY3Rpb24gPSAocHJvbWlzZSwgb25FcnJvciA9IG5vb3AyKSA9PiB7XG4gIHByb21pc2UuY2F0Y2gob25FcnJvcik7XG4gIHJldHVybiBwcm9taXNlO1xufTtcbnZhciBhZGRBYm9ydFNpZ25hbExpc3RlbmVyID0gKGFib3J0U2lnbmFsLCBjYWxsYmFjaykgPT4ge1xuICBhYm9ydFNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgY2FsbGJhY2ssIHtcbiAgICBvbmNlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gKCkgPT4gYWJvcnRTaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGNhbGxiYWNrKTtcbn07XG52YXIgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbiA9IChhYm9ydENvbnRyb2xsZXIsIHJlYXNvbikgPT4ge1xuICBjb25zdCBzaWduYWwgPSBhYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCEoXCJyZWFzb25cIiBpbiBzaWduYWwpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNpZ25hbCwgXCJyZWFzb25cIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiByZWFzb24sXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIDtcbiAgYWJvcnRDb250cm9sbGVyLmFib3J0KHJlYXNvbik7XG59O1xuXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL3Rhc2sudHNcbnZhciB2YWxpZGF0ZUFjdGl2ZSA9IChzaWduYWwpID0+IHtcbiAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVhc29uXG4gICAgfSA9IHNpZ25hbDtcbiAgICB0aHJvdyBuZXcgVGFza0Fib3J0RXJyb3IocmVhc29uKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJhY2VXaXRoU2lnbmFsKHNpZ25hbCwgcHJvbWlzZSkge1xuICBsZXQgY2xlYW51cCA9IG5vb3AyO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IG5vdGlmeVJlamVjdGlvbiA9ICgpID0+IHJlamVjdChuZXcgVGFza0Fib3J0RXJyb3Ioc2lnbmFsLnJlYXNvbikpO1xuICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgbm90aWZ5UmVqZWN0aW9uKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFudXAgPSBhZGRBYm9ydFNpZ25hbExpc3RlbmVyKHNpZ25hbCwgbm90aWZ5UmVqZWN0aW9uKTtcbiAgICBwcm9taXNlLmZpbmFsbHkoKCkgPT4gY2xlYW51cCgpKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgIGNsZWFudXAgPSBub29wMjtcbiAgfSk7XG59XG52YXIgcnVuVGFzayA9IGFzeW5jICh0YXNrMiwgY2xlYW5VcCkgPT4ge1xuICB0cnkge1xuICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGFzazIoKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiBcIm9rXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogZXJyb3IgaW5zdGFuY2VvZiBUYXNrQWJvcnRFcnJvciA/IFwiY2FuY2VsbGVkXCIgOiBcInJlamVjdGVkXCIsXG4gICAgICBlcnJvclxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgY2xlYW5VcD8uKCk7XG4gIH1cbn07XG52YXIgY3JlYXRlUGF1c2UgPSAoc2lnbmFsKSA9PiB7XG4gIHJldHVybiAocHJvbWlzZSkgPT4ge1xuICAgIHJldHVybiBjYXRjaFJlamVjdGlvbihyYWNlV2l0aFNpZ25hbChzaWduYWwsIHByb21pc2UpLnRoZW4oKG91dHB1dCkgPT4ge1xuICAgICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSkpO1xuICB9O1xufTtcbnZhciBjcmVhdGVEZWxheSA9IChzaWduYWwpID0+IHtcbiAgY29uc3QgcGF1c2UgPSBjcmVhdGVQYXVzZShzaWduYWwpO1xuICByZXR1cm4gKHRpbWVvdXRNcykgPT4ge1xuICAgIHJldHVybiBwYXVzZShuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0TXMpKSk7XG4gIH07XG59O1xuXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL2luZGV4LnRzXG52YXIge1xuICBhc3NpZ25cbn0gPSBPYmplY3Q7XG52YXIgSU5URVJOQUxfTklMX1RPS0VOID0ge307XG52YXIgYWxtID0gXCJsaXN0ZW5lck1pZGRsZXdhcmVcIjtcbnZhciBjcmVhdGVGb3JrID0gKHBhcmVudEFib3J0U2lnbmFsLCBwYXJlbnRCbG9ja2luZ1Byb21pc2VzKSA9PiB7XG4gIGNvbnN0IGxpbmtDb250cm9sbGVycyA9IChjb250cm9sbGVyKSA9PiBhZGRBYm9ydFNpZ25hbExpc3RlbmVyKHBhcmVudEFib3J0U2lnbmFsLCAoKSA9PiBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNvbnRyb2xsZXIsIHBhcmVudEFib3J0U2lnbmFsLnJlYXNvbikpO1xuICByZXR1cm4gKHRhc2tFeGVjdXRvciwgb3B0cykgPT4ge1xuICAgIGFzc2VydEZ1bmN0aW9uKHRhc2tFeGVjdXRvciwgXCJ0YXNrRXhlY3V0b3JcIik7XG4gICAgY29uc3QgY2hpbGRBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGlua0NvbnRyb2xsZXJzKGNoaWxkQWJvcnRDb250cm9sbGVyKTtcbiAgICBjb25zdCByZXN1bHQgPSBydW5UYXNrKGFzeW5jICgpID0+IHtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKHBhcmVudEFib3J0U2lnbmFsKTtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgdGFza0V4ZWN1dG9yKHtcbiAgICAgICAgcGF1c2U6IGNyZWF0ZVBhdXNlKGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbCksXG4gICAgICAgIGRlbGF5OiBjcmVhdGVEZWxheShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICBzaWduYWw6IGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgICAgfSk7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgfSwgKCkgPT4gYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjaGlsZEFib3J0Q29udHJvbGxlciwgdGFza0NvbXBsZXRlZCkpO1xuICAgIGlmIChvcHRzPy5hdXRvSm9pbikge1xuICAgICAgcGFyZW50QmxvY2tpbmdQcm9taXNlcy5wdXNoKHJlc3VsdC5jYXRjaChub29wMikpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiBjcmVhdGVQYXVzZShwYXJlbnRBYm9ydFNpZ25hbCkocmVzdWx0KSxcbiAgICAgIGNhbmNlbCgpIHtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjaGlsZEFib3J0Q29udHJvbGxlciwgdGFza0NhbmNlbGxlZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn07XG52YXIgY3JlYXRlVGFrZVBhdHRlcm4gPSAoc3RhcnRMaXN0ZW5pbmcsIHNpZ25hbCkgPT4ge1xuICBjb25zdCB0YWtlID0gYXN5bmMgKHByZWRpY2F0ZSwgdGltZW91dCkgPT4ge1xuICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XG4gICAgbGV0IHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgIH07XG4gICAgY29uc3QgdHVwbGVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHN0b3BMaXN0ZW5pbmcgPSBzdGFydExpc3RlbmluZyh7XG4gICAgICAgIHByZWRpY2F0ZSxcbiAgICAgICAgZWZmZWN0OiAoYWN0aW9uLCBsaXN0ZW5lckFwaSkgPT4ge1xuICAgICAgICAgIGxpc3RlbmVyQXBpLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgcmVzb2x2ZShbYWN0aW9uLCBsaXN0ZW5lckFwaS5nZXRTdGF0ZSgpLCBsaXN0ZW5lckFwaS5nZXRPcmlnaW5hbFN0YXRlKCldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB1bnN1YnNjcmliZSA9ICgpID0+IHtcbiAgICAgICAgc3RvcExpc3RlbmluZygpO1xuICAgICAgICByZWplY3QoKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbdHVwbGVQcm9taXNlXTtcbiAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICBwcm9taXNlcy5wdXNoKG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXQsIG51bGwpKSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCByYWNlV2l0aFNpZ25hbChzaWduYWwsIFByb21pc2UucmFjZShwcm9taXNlcykpO1xuICAgICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gKHByZWRpY2F0ZSwgdGltZW91dCkgPT4gY2F0Y2hSZWplY3Rpb24odGFrZShwcmVkaWNhdGUsIHRpbWVvdXQpKTtcbn07XG52YXIgZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbSA9IChvcHRpb25zKSA9PiB7XG4gIGxldCB7XG4gICAgdHlwZSxcbiAgICBhY3Rpb25DcmVhdG9yLFxuICAgIG1hdGNoZXIsXG4gICAgcHJlZGljYXRlLFxuICAgIGVmZmVjdFxuICB9ID0gb3B0aW9ucztcbiAgaWYgKHR5cGUpIHtcbiAgICBwcmVkaWNhdGUgPSBjcmVhdGVBY3Rpb24odHlwZSkubWF0Y2g7XG4gIH0gZWxzZSBpZiAoYWN0aW9uQ3JlYXRvcikge1xuICAgIHR5cGUgPSBhY3Rpb25DcmVhdG9yLnR5cGU7XG4gICAgcHJlZGljYXRlID0gYWN0aW9uQ3JlYXRvci5tYXRjaDtcbiAgfSBlbHNlIGlmIChtYXRjaGVyKSB7XG4gICAgcHJlZGljYXRlID0gbWF0Y2hlcjtcbiAgfSBlbHNlIGlmIChwcmVkaWNhdGUpIHtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyMSkgOiBcIkNyZWF0aW5nIG9yIHJlbW92aW5nIGEgbGlzdGVuZXIgcmVxdWlyZXMgb25lIG9mIHRoZSBrbm93biBmaWVsZHMgZm9yIG1hdGNoaW5nIGFuIGFjdGlvblwiKTtcbiAgfVxuICBhc3NlcnRGdW5jdGlvbihlZmZlY3QsIFwib3B0aW9ucy5saXN0ZW5lclwiKTtcbiAgcmV0dXJuIHtcbiAgICBwcmVkaWNhdGUsXG4gICAgdHlwZSxcbiAgICBlZmZlY3RcbiAgfTtcbn07XG52YXIgY3JlYXRlTGlzdGVuZXJFbnRyeSA9IE9iamVjdC5hc3NpZ24oKG9wdGlvbnMpID0+IHtcbiAgY29uc3Qge1xuICAgIHR5cGUsXG4gICAgcHJlZGljYXRlLFxuICAgIGVmZmVjdFxuICB9ID0gZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbShvcHRpb25zKTtcbiAgY29uc3QgaWQgPSBuYW5vaWQoKTtcbiAgY29uc3QgZW50cnkgPSB7XG4gICAgaWQsXG4gICAgZWZmZWN0LFxuICAgIHR5cGUsXG4gICAgcHJlZGljYXRlLFxuICAgIHBlbmRpbmc6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihmYWxzZSA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMigyMikgOiBcIlVuc3Vic2NyaWJlIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBlbnRyeTtcbn0sIHtcbiAgd2l0aFR5cGVzOiAoKSA9PiBjcmVhdGVMaXN0ZW5lckVudHJ5XG59KTtcbnZhciBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMgPSAoZW50cnkpID0+IHtcbiAgZW50cnkucGVuZGluZy5mb3JFYWNoKChjb250cm9sbGVyKSA9PiB7XG4gICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XG4gIH0pO1xufTtcbnZhciBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZSA9IChsaXN0ZW5lck1hcCkgPT4ge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxpc3RlbmVyTWFwLmZvckVhY2goY2FuY2VsQWN0aXZlTGlzdGVuZXJzKTtcbiAgICBsaXN0ZW5lck1hcC5jbGVhcigpO1xuICB9O1xufTtcbnZhciBzYWZlbHlOb3RpZnlFcnJvciA9IChlcnJvckhhbmRsZXIsIGVycm9yVG9Ob3RpZnksIGVycm9ySW5mbykgPT4ge1xuICB0cnkge1xuICAgIGVycm9ySGFuZGxlcihlcnJvclRvTm90aWZ5LCBlcnJvckluZm8pO1xuICB9IGNhdGNoIChlcnJvckhhbmRsZXJFcnJvcikge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhyb3cgZXJyb3JIYW5kbGVyRXJyb3I7XG4gICAgfSwgMCk7XG4gIH1cbn07XG52YXIgYWRkTGlzdGVuZXIgPSBPYmplY3QuYXNzaWduKGNyZWF0ZUFjdGlvbihgJHthbG19L2FkZGApLCB7XG4gIHdpdGhUeXBlczogKCkgPT4gYWRkTGlzdGVuZXJcbn0pO1xudmFyIGNsZWFyQWxsTGlzdGVuZXJzID0gY3JlYXRlQWN0aW9uKGAke2FsbX0vcmVtb3ZlQWxsYCk7XG52YXIgcmVtb3ZlTGlzdGVuZXIgPSBPYmplY3QuYXNzaWduKGNyZWF0ZUFjdGlvbihgJHthbG19L3JlbW92ZWApLCB7XG4gIHdpdGhUeXBlczogKCkgPT4gcmVtb3ZlTGlzdGVuZXJcbn0pO1xudmFyIGRlZmF1bHRFcnJvckhhbmRsZXIgPSAoLi4uYXJncykgPT4ge1xuICBjb25zb2xlLmVycm9yKGAke2FsbX0vZXJyb3JgLCAuLi5hcmdzKTtcbn07XG52YXIgY3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlID0gKG1pZGRsZXdhcmVPcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgbGlzdGVuZXJNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCB7XG4gICAgZXh0cmEsXG4gICAgb25FcnJvciA9IGRlZmF1bHRFcnJvckhhbmRsZXJcbiAgfSA9IG1pZGRsZXdhcmVPcHRpb25zO1xuICBhc3NlcnRGdW5jdGlvbihvbkVycm9yLCBcIm9uRXJyb3JcIik7XG4gIGNvbnN0IGluc2VydEVudHJ5ID0gKGVudHJ5KSA9PiB7XG4gICAgZW50cnkudW5zdWJzY3JpYmUgPSAoKSA9PiBsaXN0ZW5lck1hcC5kZWxldGUoZW50cnkuaWQpO1xuICAgIGxpc3RlbmVyTWFwLnNldChlbnRyeS5pZCwgZW50cnkpO1xuICAgIHJldHVybiAoY2FuY2VsT3B0aW9ucykgPT4ge1xuICAgICAgZW50cnkudW5zdWJzY3JpYmUoKTtcbiAgICAgIGlmIChjYW5jZWxPcHRpb25zPy5jYW5jZWxBY3RpdmUpIHtcbiAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzKGVudHJ5KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBjb25zdCBzdGFydExpc3RlbmluZyA9IChvcHRpb25zKSA9PiB7XG4gICAgbGV0IGVudHJ5ID0gZmluZChBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKSwgKGV4aXN0aW5nRW50cnkpID0+IGV4aXN0aW5nRW50cnkuZWZmZWN0ID09PSBvcHRpb25zLmVmZmVjdCk7XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgZW50cnkgPSBjcmVhdGVMaXN0ZW5lckVudHJ5KG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zZXJ0RW50cnkoZW50cnkpO1xuICB9O1xuICBPYmplY3QuYXNzaWduKHN0YXJ0TGlzdGVuaW5nLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiBzdGFydExpc3RlbmluZ1xuICB9KTtcbiAgY29uc3Qgc3RvcExpc3RlbmluZyA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIGVmZmVjdCxcbiAgICAgIHByZWRpY2F0ZVxuICAgIH0gPSBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tKG9wdGlvbnMpO1xuICAgIGNvbnN0IGVudHJ5ID0gZmluZChBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKSwgKGVudHJ5MikgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hQcmVkaWNhdGVPclR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIiA/IGVudHJ5Mi50eXBlID09PSB0eXBlIDogZW50cnkyLnByZWRpY2F0ZSA9PT0gcHJlZGljYXRlO1xuICAgICAgcmV0dXJuIG1hdGNoUHJlZGljYXRlT3JUeXBlICYmIGVudHJ5Mi5lZmZlY3QgPT09IGVmZmVjdDtcbiAgICB9KTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnVuc3Vic2NyaWJlKCk7XG4gICAgICBpZiAob3B0aW9ucy5jYW5jZWxBY3RpdmUpIHtcbiAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzKGVudHJ5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICEhZW50cnk7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3RvcExpc3RlbmluZywge1xuICAgIHdpdGhUeXBlczogKCkgPT4gc3RvcExpc3RlbmluZ1xuICB9KTtcbiAgY29uc3Qgbm90aWZ5TGlzdGVuZXIgPSBhc3luYyAoZW50cnksIGFjdGlvbiwgYXBpLCBnZXRPcmlnaW5hbFN0YXRlKSA9PiB7XG4gICAgY29uc3QgaW50ZXJuYWxUYXNrQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCB0YWtlID0gY3JlYXRlVGFrZVBhdHRlcm4oc3RhcnRMaXN0ZW5pbmcsIGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICBjb25zdCBhdXRvSm9pblByb21pc2VzID0gW107XG4gICAgdHJ5IHtcbiAgICAgIGVudHJ5LnBlbmRpbmcuYWRkKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKGVudHJ5LmVmZmVjdChcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICAvLyBVc2UgYXNzaWduKCkgcmF0aGVyIHRoYW4gLi4uIHRvIGF2b2lkIGV4dHJhIGhlbHBlciBmdW5jdGlvbnMgYWRkZWQgdG8gYnVuZGxlXG4gICAgICAgIGFzc2lnbih7fSwgYXBpLCB7XG4gICAgICAgICAgZ2V0T3JpZ2luYWxTdGF0ZSxcbiAgICAgICAgICBjb25kaXRpb246IChwcmVkaWNhdGUsIHRpbWVvdXQpID0+IHRha2UocHJlZGljYXRlLCB0aW1lb3V0KS50aGVuKEJvb2xlYW4pLFxuICAgICAgICAgIHRha2UsXG4gICAgICAgICAgZGVsYXk6IGNyZWF0ZURlbGF5KGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgICBwYXVzZTogY3JlYXRlUGF1c2UoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICAgIGV4dHJhLFxuICAgICAgICAgIHNpZ25hbDogaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgZm9yazogY3JlYXRlRm9yayhpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCwgYXV0b0pvaW5Qcm9taXNlcyksXG4gICAgICAgICAgdW5zdWJzY3JpYmU6IGVudHJ5LnVuc3Vic2NyaWJlLFxuICAgICAgICAgIHN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXJNYXAuc2V0KGVudHJ5LmlkLCBlbnRyeSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnM6ICgpID0+IHtcbiAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZm9yRWFjaCgoY29udHJvbGxlciwgXywgc2V0KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChjb250cm9sbGVyICE9PSBpbnRlcm5hbFRhc2tDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XG4gICAgICAgICAgICAgICAgc2V0LmRlbGV0ZShjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oaW50ZXJuYWxUYXNrQ29udHJvbGxlciwgbGlzdGVuZXJDYW5jZWxsZWQpO1xuICAgICAgICAgICAgZW50cnkucGVuZGluZy5kZWxldGUoaW50ZXJuYWxUYXNrQ29udHJvbGxlcik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkOiAoKSA9PiB7XG4gICAgICAgICAgICB2YWxpZGF0ZUFjdGl2ZShpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKSk7XG4gICAgfSBjYXRjaCAobGlzdGVuZXJFcnJvcikge1xuICAgICAgaWYgKCEobGlzdGVuZXJFcnJvciBpbnN0YW5jZW9mIFRhc2tBYm9ydEVycm9yKSkge1xuICAgICAgICBzYWZlbHlOb3RpZnlFcnJvcihvbkVycm9yLCBsaXN0ZW5lckVycm9yLCB7XG4gICAgICAgICAgcmFpc2VkQnk6IFwiZWZmZWN0XCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGF1dG9Kb2luUHJvbWlzZXMpO1xuICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihpbnRlcm5hbFRhc2tDb250cm9sbGVyLCBsaXN0ZW5lckNvbXBsZXRlZCk7XG4gICAgICBlbnRyeS5wZW5kaW5nLmRlbGV0ZShpbnRlcm5hbFRhc2tDb250cm9sbGVyKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlID0gY3JlYXRlQ2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUobGlzdGVuZXJNYXApO1xuICBjb25zdCBtaWRkbGV3YXJlID0gKGFwaSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICBpZiAoISgwLCBpbXBvcnRfcmVkdXg1LmlzQWN0aW9uKShhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgIH1cbiAgICBpZiAoYWRkTGlzdGVuZXIubWF0Y2goYWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHN0YXJ0TGlzdGVuaW5nKGFjdGlvbi5wYXlsb2FkKTtcbiAgICB9XG4gICAgaWYgKGNsZWFyQWxsTGlzdGVuZXJzLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZW1vdmVMaXN0ZW5lci5tYXRjaChhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gc3RvcExpc3RlbmluZyhhY3Rpb24ucGF5bG9hZCk7XG4gICAgfVxuICAgIGxldCBvcmlnaW5hbFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgY29uc3QgZ2V0T3JpZ2luYWxTdGF0ZSA9ICgpID0+IHtcbiAgICAgIGlmIChvcmlnaW5hbFN0YXRlID09PSBJTlRFUk5BTF9OSUxfVE9LRU4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZhbHNlID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UzKDIzKSA6IGAke2FsbX06IGdldE9yaWdpbmFsU3RhdGUgY2FuIG9ubHkgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHlgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnaW5hbFN0YXRlO1xuICAgIH07XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gbmV4dChhY3Rpb24pO1xuICAgICAgaWYgKGxpc3RlbmVyTWFwLnNpemUgPiAwKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGFwaS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBsaXN0ZW5lckVudHJpZXMgPSBBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBsaXN0ZW5lckVudHJpZXMpIHtcbiAgICAgICAgICBsZXQgcnVuTGlzdGVuZXIgPSBmYWxzZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcnVuTGlzdGVuZXIgPSBlbnRyeS5wcmVkaWNhdGUoYWN0aW9uLCBjdXJyZW50U3RhdGUsIG9yaWdpbmFsU3RhdGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKHByZWRpY2F0ZUVycm9yKSB7XG4gICAgICAgICAgICBydW5MaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgICAgICAgc2FmZWx5Tm90aWZ5RXJyb3Iob25FcnJvciwgcHJlZGljYXRlRXJyb3IsIHtcbiAgICAgICAgICAgICAgcmFpc2VkQnk6IFwicHJlZGljYXRlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJ1bkxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm90aWZ5TGlzdGVuZXIoZW50cnksIGFjdGlvbiwgYXBpLCBnZXRPcmlnaW5hbFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBvcmlnaW5hbFN0YXRlID0gSU5URVJOQUxfTklMX1RPS0VOO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmUsXG4gICAgc3RhcnRMaXN0ZW5pbmcsXG4gICAgc3RvcExpc3RlbmluZyxcbiAgICBjbGVhckxpc3RlbmVyczogY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmVcbiAgfTtcbn07XG5cbi8vIHNyYy9keW5hbWljTWlkZGxld2FyZS9pbmRleC50c1xudmFyIGltcG9ydF9yZWR1eDYgPSByZXF1aXJlKFwicmVkdXhcIik7XG52YXIgY3JlYXRlTWlkZGxld2FyZUVudHJ5ID0gKG1pZGRsZXdhcmUpID0+ICh7XG4gIGlkOiBuYW5vaWQoKSxcbiAgbWlkZGxld2FyZSxcbiAgYXBwbGllZDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxufSk7XG52YXIgbWF0Y2hJbnN0YW5jZSA9IChpbnN0YW5jZUlkKSA9PiAoYWN0aW9uKSA9PiBhY3Rpb24/Lm1ldGE/Lmluc3RhbmNlSWQgPT09IGluc3RhbmNlSWQ7XG52YXIgY3JlYXRlRHluYW1pY01pZGRsZXdhcmUgPSAoKSA9PiB7XG4gIGNvbnN0IGluc3RhbmNlSWQgPSBuYW5vaWQoKTtcbiAgY29uc3QgbWlkZGxld2FyZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHdpdGhNaWRkbGV3YXJlID0gT2JqZWN0LmFzc2lnbihjcmVhdGVBY3Rpb24oXCJkeW5hbWljTWlkZGxld2FyZS9hZGRcIiwgKC4uLm1pZGRsZXdhcmVzKSA9PiAoe1xuICAgIHBheWxvYWQ6IG1pZGRsZXdhcmVzLFxuICAgIG1ldGE6IHtcbiAgICAgIGluc3RhbmNlSWRcbiAgICB9XG4gIH0pKSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gd2l0aE1pZGRsZXdhcmVcbiAgfSk7XG4gIGNvbnN0IGFkZE1pZGRsZXdhcmUgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIGFkZE1pZGRsZXdhcmUyKC4uLm1pZGRsZXdhcmVzKSB7XG4gICAgbWlkZGxld2FyZXMuZm9yRWFjaCgobWlkZGxld2FyZTIpID0+IHtcbiAgICAgIGxldCBlbnRyeSA9IGZpbmQoQXJyYXkuZnJvbShtaWRkbGV3YXJlTWFwLnZhbHVlcygpKSwgKGVudHJ5MikgPT4gZW50cnkyLm1pZGRsZXdhcmUgPT09IG1pZGRsZXdhcmUyKTtcbiAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgZW50cnkgPSBjcmVhdGVNaWRkbGV3YXJlRW50cnkobWlkZGxld2FyZTIpO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZU1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcbiAgICB9KTtcbiAgfSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gYWRkTWlkZGxld2FyZVxuICB9KTtcbiAgY29uc3QgZ2V0RmluYWxNaWRkbGV3YXJlID0gKGFwaSkgPT4ge1xuICAgIGNvbnN0IGFwcGxpZWRNaWRkbGV3YXJlID0gQXJyYXkuZnJvbShtaWRkbGV3YXJlTWFwLnZhbHVlcygpKS5tYXAoKGVudHJ5KSA9PiBlbXBsYWNlKGVudHJ5LmFwcGxpZWQsIGFwaSwge1xuICAgICAgaW5zZXJ0OiAoKSA9PiBlbnRyeS5taWRkbGV3YXJlKGFwaSlcbiAgICB9KSk7XG4gICAgcmV0dXJuICgwLCBpbXBvcnRfcmVkdXg2LmNvbXBvc2UpKC4uLmFwcGxpZWRNaWRkbGV3YXJlKTtcbiAgfTtcbiAgY29uc3QgaXNXaXRoTWlkZGxld2FyZSA9IGlzQWxsT2Yod2l0aE1pZGRsZXdhcmUsIG1hdGNoSW5zdGFuY2UoaW5zdGFuY2VJZCkpO1xuICBjb25zdCBtaWRkbGV3YXJlID0gKGFwaSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICBpZiAoaXNXaXRoTWlkZGxld2FyZShhY3Rpb24pKSB7XG4gICAgICBhZGRNaWRkbGV3YXJlKC4uLmFjdGlvbi5wYXlsb2FkKTtcbiAgICAgIHJldHVybiBhcGkuZGlzcGF0Y2g7XG4gICAgfVxuICAgIHJldHVybiBnZXRGaW5hbE1pZGRsZXdhcmUoYXBpKShuZXh0KShhY3Rpb24pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmUsXG4gICAgYWRkTWlkZGxld2FyZSxcbiAgICB3aXRoTWlkZGxld2FyZSxcbiAgICBpbnN0YW5jZUlkXG4gIH07XG59O1xuXG4vLyBzcmMvY29tYmluZVNsaWNlcy50c1xudmFyIGltcG9ydF9yZWR1eDcgPSByZXF1aXJlKFwicmVkdXhcIik7XG52YXIgaXNTbGljZUxpa2UgPSAobWF5YmVTbGljZUxpa2UpID0+IFwicmVkdWNlclBhdGhcIiBpbiBtYXliZVNsaWNlTGlrZSAmJiB0eXBlb2YgbWF5YmVTbGljZUxpa2UucmVkdWNlclBhdGggPT09IFwic3RyaW5nXCI7XG52YXIgZ2V0UmVkdWNlcnMgPSAoc2xpY2VzKSA9PiBzbGljZXMuZmxhdE1hcCgoc2xpY2VPck1hcCkgPT4gaXNTbGljZUxpa2Uoc2xpY2VPck1hcCkgPyBbW3NsaWNlT3JNYXAucmVkdWNlclBhdGgsIHNsaWNlT3JNYXAucmVkdWNlcl1dIDogT2JqZWN0LmVudHJpZXMoc2xpY2VPck1hcCkpO1xudmFyIE9SSUdJTkFMX1NUQVRFID0gU3ltYm9sLmZvcihcInJ0ay1zdGF0ZS1wcm94eS1vcmlnaW5hbFwiKTtcbnZhciBpc1N0YXRlUHJveHkgPSAodmFsdWUpID0+ICEhdmFsdWUgJiYgISF2YWx1ZVtPUklHSU5BTF9TVEFURV07XG52YXIgc3RhdGVQcm94eU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIGNyZWF0ZVN0YXRlUHJveHkgPSAoc3RhdGUsIHJlZHVjZXJNYXApID0+IGVtcGxhY2Uoc3RhdGVQcm94eU1hcCwgc3RhdGUsIHtcbiAgaW5zZXJ0OiAoKSA9PiBuZXcgUHJveHkoc3RhdGUsIHtcbiAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiB7XG4gICAgICBpZiAocHJvcCA9PT0gT1JJR0lOQUxfU1RBVEUpXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbnN0IHJlZHVjZXIgPSByZWR1Y2VyTWFwW3Byb3AudG9TdHJpbmcoKV07XG4gICAgICAgIGlmIChyZWR1Y2VyKSB7XG4gICAgICAgICAgY29uc3QgcmVkdWNlclJlc3VsdCA9IHJlZHVjZXIodm9pZCAwLCB7XG4gICAgICAgICAgICB0eXBlOiBuYW5vaWQoKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVkdWNlclJlc3VsdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZhbHNlID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjQpIDogYFRoZSBzbGljZSByZWR1Y2VyIGZvciBrZXkgXCIke3Byb3AudG9TdHJpbmcoKX1cIiByZXR1cm5lZCB1bmRlZmluZWQgd2hlbiBjYWxsZWQgZm9yIHNlbGVjdG9yKCkuIElmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlIHJlZHVjZXIgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IG5vdCBiZSB1bmRlZmluZWQuIElmIHlvdSBkb24ndCB3YW50IHRvIHNldCBhIHZhbHVlIGZvciB0aGlzIHJlZHVjZXIsIHlvdSBjYW4gdXNlIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQuYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZWR1Y2VyUmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSlcbn0pO1xudmFyIG9yaWdpbmFsID0gKHN0YXRlKSA9PiB7XG4gIGlmICghaXNTdGF0ZVByb3h5KHN0YXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihmYWxzZSA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMigyNSkgOiBcIm9yaWdpbmFsIG11c3QgYmUgdXNlZCBvbiBzdGF0ZSBQcm94eVwiKTtcbiAgfVxuICByZXR1cm4gc3RhdGVbT1JJR0lOQUxfU1RBVEVdO1xufTtcbnZhciBub29wUmVkdWNlciA9IChzdGF0ZSA9IHt9KSA9PiBzdGF0ZTtcbmZ1bmN0aW9uIGNvbWJpbmVTbGljZXMoLi4uc2xpY2VzKSB7XG4gIGNvbnN0IHJlZHVjZXJNYXAgPSBPYmplY3QuZnJvbUVudHJpZXMoZ2V0UmVkdWNlcnMoc2xpY2VzKSk7XG4gIGNvbnN0IGdldFJlZHVjZXIgPSAoKSA9PiBPYmplY3Qua2V5cyhyZWR1Y2VyTWFwKS5sZW5ndGggPyAoMCwgaW1wb3J0X3JlZHV4Ny5jb21iaW5lUmVkdWNlcnMpKHJlZHVjZXJNYXApIDogbm9vcFJlZHVjZXI7XG4gIGxldCByZWR1Y2VyID0gZ2V0UmVkdWNlcigpO1xuICBmdW5jdGlvbiBjb21iaW5lZFJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIHJldHVybiByZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xuICB9XG4gIGNvbWJpbmVkUmVkdWNlci53aXRoTGF6eUxvYWRlZFNsaWNlcyA9ICgpID0+IGNvbWJpbmVkUmVkdWNlcjtcbiAgY29uc3QgaW5qZWN0ID0gKHNsaWNlLCBjb25maWcgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlZHVjZXJQYXRoLFxuICAgICAgcmVkdWNlcjogcmVkdWNlclRvSW5qZWN0XG4gICAgfSA9IHNsaWNlO1xuICAgIGNvbnN0IGN1cnJlbnRSZWR1Y2VyID0gcmVkdWNlck1hcFtyZWR1Y2VyUGF0aF07XG4gICAgaWYgKCFjb25maWcub3ZlcnJpZGVFeGlzdGluZyAmJiBjdXJyZW50UmVkdWNlciAmJiBjdXJyZW50UmVkdWNlciAhPT0gcmVkdWNlclRvSW5qZWN0KSB7XG4gICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgdHJ1ZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBjYWxsZWQgXFxgaW5qZWN0XFxgIHRvIG92ZXJyaWRlIGFscmVhZHktZXhpc3RpbmcgcmVkdWNlciAke3JlZHVjZXJQYXRofSB3aXRob3V0IHNwZWNpZnlpbmcgXFxgb3ZlcnJpZGVFeGlzdGluZzogdHJ1ZVxcYGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbWJpbmVkUmVkdWNlcjtcbiAgICB9XG4gICAgcmVkdWNlck1hcFtyZWR1Y2VyUGF0aF0gPSByZWR1Y2VyVG9JbmplY3Q7XG4gICAgcmVkdWNlciA9IGdldFJlZHVjZXIoKTtcbiAgICByZXR1cm4gY29tYmluZWRSZWR1Y2VyO1xuICB9O1xuICBjb25zdCBzZWxlY3RvciA9IE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gbWFrZVNlbGVjdG9yKHNlbGVjdG9yRm4sIHNlbGVjdFN0YXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNlbGVjdG9yMihzdGF0ZSwgLi4uYXJncykge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yRm4oY3JlYXRlU3RhdGVQcm94eShzZWxlY3RTdGF0ZSA/IHNlbGVjdFN0YXRlKHN0YXRlLCAuLi5hcmdzKSA6IHN0YXRlLCByZWR1Y2VyTWFwKSwgLi4uYXJncyk7XG4gICAgfTtcbiAgfSwge1xuICAgIG9yaWdpbmFsXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihjb21iaW5lZFJlZHVjZXIsIHtcbiAgICBpbmplY3QsXG4gICAgc2VsZWN0b3JcbiAgfSk7XG59XG5cbi8vIHNyYy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlLnRzXG5mdW5jdGlvbiBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKGNvZGUpIHtcbiAgcmV0dXJuIGBNaW5pZmllZCBSZWR1eCBUb29sa2l0IGVycm9yICMke2NvZGV9OyB2aXNpdCBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL0Vycm9ycz9jb2RlPSR7Y29kZX0gZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycy4gYDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHV4LXRvb2xraXQuZGV2ZWxvcG1lbnQuY2pzLm1hcCJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZ2V0T3duUHJvcERlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2dldE93blByb3BOYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJfX2hhc093blByb3AiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImdldCIsImVudW1lcmFibGUiLCJfX2NvcHlQcm9wcyIsInRvIiwiZnJvbSIsImV4Y2VwdCIsImRlc2MiLCJrZXkiLCJjYWxsIiwiX19yZUV4cG9ydCIsIm1vZCIsInNlY29uZFRhcmdldCIsIl9fdG9Db21tb25KUyIsInZhbHVlIiwic3JjX2V4cG9ydHMiLCJSZWR1Y2VyVHlwZSIsIlNIT1VMRF9BVVRPQkFUQ0giLCJUYXNrQWJvcnRFcnJvciIsIlR1cGxlIiwiYWRkTGlzdGVuZXIiLCJhc3luY1RodW5rQ3JlYXRvciIsImF1dG9CYXRjaEVuaGFuY2VyIiwiYnVpbGRDcmVhdGVTbGljZSIsImNsZWFyQWxsTGlzdGVuZXJzIiwiY29tYmluZVNsaWNlcyIsImNvbmZpZ3VyZVN0b3JlIiwiY3JlYXRlQWN0aW9uIiwiY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUiLCJjcmVhdGVBc3luY1RodW5rIiwiY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IiLCJjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3IiLCJjcmVhdGVEeW5hbWljTWlkZGxld2FyZSIsImNyZWF0ZUVudGl0eUFkYXB0ZXIiLCJjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUiLCJjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUiLCJjcmVhdGVOZXh0U3RhdGUiLCJpbXBvcnRfaW1tZXI1IiwicHJvZHVjZSIsImNyZWF0ZVJlZHVjZXIiLCJjcmVhdGVTZWxlY3RvciIsImltcG9ydF9yZXNlbGVjdDIiLCJjcmVhdGVTZWxlY3RvckNyZWF0b3IiLCJjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUiLCJjcmVhdGVTbGljZSIsImN1cnJlbnQiLCJmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIiwiZnJlZXplIiwiaXNBY3Rpb25DcmVhdG9yIiwiaXNBbGxPZiIsImlzQW55T2YiLCJpc0FzeW5jVGh1bmtBY3Rpb24iLCJpc0RyYWZ0IiwiaXNGbHV4U3RhbmRhcmRBY3Rpb24iLCJpc0ZTQSIsImlzRnVsZmlsbGVkIiwiaXNJbW11dGFibGVEZWZhdWx0IiwiaXNQZW5kaW5nIiwiaXNQbGFpbiIsImlzUmVqZWN0ZWQiLCJpc1JlamVjdGVkV2l0aFZhbHVlIiwibHJ1TWVtb2l6ZSIsIm1pbmlTZXJpYWxpemVFcnJvciIsIm5hbm9pZCIsIm9yaWdpbmFsIiwicHJlcGFyZUF1dG9CYXRjaGVkIiwicmVtb3ZlTGlzdGVuZXIiLCJ1bndyYXBSZXN1bHQiLCJ3ZWFrTWFwTWVtb2l6ZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiaW1wb3J0X2ltbWVyIiwiaW1wb3J0X3Jlc2VsZWN0IiwiYXJncyIsImNyZWF0ZVNlbGVjdG9yMiIsImNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yMiIsImFzc2lnbiIsImFyZ3MyIiwic2VsZWN0b3IiLCJ3cmFwcGVkU2VsZWN0b3IiLCJyZXN0Iiwid2l0aFR5cGVzIiwiaW1wb3J0X3JlZHV4NCIsImltcG9ydF9yZWR1eCIsImNvbXBvc2VXaXRoRGV2VG9vbHMiLCJ3aW5kb3ciLCJfX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJjb21wb3NlIiwiYXBwbHkiLCJkZXZUb29sc0VuaGFuY2VyIiwiX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyIsIm5vb3AzIiwiaW1wb3J0X3JlZHV4X3RodW5rIiwiaW1wb3J0X3JlZHV4MiIsImhhc01hdGNoRnVuY3Rpb24iLCJ2IiwibWF0Y2giLCJ0eXBlIiwicHJlcGFyZUFjdGlvbiIsImFjdGlvbkNyZWF0b3IiLCJwcmVwYXJlZCIsIkVycm9yIiwiX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UiLCJwYXlsb2FkIiwibWV0YSIsImVycm9yIiwidG9TdHJpbmciLCJhY3Rpb24iLCJpc0FjdGlvbiIsImtleXMiLCJldmVyeSIsImlzVmFsaWRLZXkiLCJpbmRleE9mIiwiZ2V0TWVzc2FnZSIsInNwbGl0VHlwZSIsInNwbGl0IiwiYWN0aW9uTmFtZSIsIm9wdGlvbnMiLCJuZXh0IiwiaXNBY3Rpb25DcmVhdG9yMiIsImNvbnNvbGUiLCJ3YXJuIiwiaW1wb3J0X2ltbWVyMiIsImdldFRpbWVNZWFzdXJlVXRpbHMiLCJtYXhEZWxheSIsImZuTmFtZSIsImVsYXBzZWQiLCJtZWFzdXJlVGltZSIsImZuIiwic3RhcnRlZCIsIkRhdGUiLCJub3ciLCJmaW5pc2hlZCIsIndhcm5JZkV4Y2VlZGVkIiwiZmluZCIsIml0ZXJhYmxlIiwiY29tcGFyYXRvciIsImVudHJ5IiwiX1R1cGxlIiwiQXJyYXkiLCJjb25zdHJ1Y3RvciIsIml0ZW1zIiwic2V0UHJvdG90eXBlT2YiLCJTeW1ib2wiLCJzcGVjaWVzIiwiY29uY2F0IiwiYXJyIiwicHJlcGVuZCIsImlzQXJyYXkiLCJmcmVlemVEcmFmdGFibGUiLCJ2YWwiLCJpc0RyYWZ0YWJsZSIsImVtcGxhY2UiLCJtYXAiLCJoYW5kbGVyIiwiaGFzIiwidXBkYXRlIiwic2V0IiwiaW5zZXJ0IiwiaW5zZXJ0ZWQiLCJpc0Zyb3plbiIsInRyYWNrRm9yTXV0YXRpb25zIiwiaXNJbW11dGFibGUiLCJpZ25vcmVQYXRocyIsIm9iaiIsInRyYWNrZWRQcm9wZXJ0aWVzIiwidHJhY2tQcm9wZXJ0aWVzIiwiZGV0ZWN0TXV0YXRpb25zIiwicGF0aCIsImNoZWNrZWRPYmplY3RzIiwiU2V0IiwidHJhY2tlZCIsImFkZCIsImNoaWxkcmVuIiwiY2hpbGRQYXRoIiwiaWdub3JlZFBhdGhzIiwidHJhY2tlZFByb3BlcnR5Iiwic2FtZVBhcmVudFJlZiIsInByZXZPYmoiLCJzYW1lUmVmIiwiTnVtYmVyIiwiaXNOYU4iLCJ3YXNNdXRhdGVkIiwia2V5c1RvRGV0ZWN0IiwiaGFzSWdub3JlZFBhdGhzIiwibmVzdGVkUGF0aCIsImhhc01hdGNoZXMiLCJzb21lIiwiaWdub3JlZCIsIlJlZ0V4cCIsInRlc3QiLCJyZXN1bHQiLCJzdHJpbmdpZnkyIiwic2VyaWFsaXplciIsImluZGVudCIsImRlY3ljbGVyIiwiSlNPTiIsInN0cmluZ2lmeSIsImdldFNlcmlhbGl6ZTIiLCJzdGFjayIsIl8iLCJzbGljZSIsImpvaW4iLCJ0aGlzUG9zIiwic3BsaWNlIiwicHVzaCIsIkluZmluaXR5IiwiZ2V0U2VyaWFsaXplIiwid2FybkFmdGVyIiwidHJhY2siLCJiaW5kIiwiZ2V0U3RhdGUiLCJzdGF0ZSIsInRyYWNrZXIiLCJtZWFzdXJlVXRpbHMiLCJkaXNwYXRjaGVkQWN0aW9uIiwiX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyIiwiaW1wb3J0X3JlZHV4MyIsImlzUGxhaW5PYmplY3QiLCJpc1NlcmlhbGl6YWJsZSIsImdldEVudHJpZXMiLCJjYWNoZSIsImZvdW5kTmVzdGVkU2VyaWFsaXphYmxlIiwia2V5UGF0aCIsImVudHJpZXMiLCJuZXN0ZWRWYWx1ZSIsImlzTmVzdGVkRnJvemVuIiwidmFsdWVzIiwiaWdub3JlZEFjdGlvbnMiLCJpZ25vcmVkQWN0aW9uUGF0aHMiLCJpZ25vcmVTdGF0ZSIsImlnbm9yZUFjdGlvbnMiLCJkaXNhYmxlQ2FjaGUiLCJXZWFrU2V0Iiwic3RvcmVBUEkiLCJmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlIiwiZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlIiwiaXNCb29sZWFuIiwieCIsImJ1aWxkR2V0RGVmYXVsdE1pZGRsZXdhcmUiLCJnZXREZWZhdWx0TWlkZGxld2FyZSIsInRodW5rIiwiaW1tdXRhYmxlQ2hlY2siLCJzZXJpYWxpemFibGVDaGVjayIsImFjdGlvbkNyZWF0b3JDaGVjayIsIm1pZGRsZXdhcmVBcnJheSIsIndpdGhFeHRyYUFyZ3VtZW50IiwiZXh0cmFBcmd1bWVudCIsImltbXV0YWJsZU9wdGlvbnMiLCJ1bnNoaWZ0Iiwic2VyaWFsaXphYmxlT3B0aW9ucyIsImFjdGlvbkNyZWF0b3JPcHRpb25zIiwiY3JlYXRlUXVldWVXaXRoVGltZXIiLCJ0aW1lb3V0Iiwibm90aWZ5Iiwic2V0VGltZW91dCIsInJBRiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInN0b3JlIiwibm90aWZ5aW5nIiwic2hvdWxkTm90aWZ5QXRFbmRPZlRpY2siLCJub3RpZmljYXRpb25RdWV1ZWQiLCJsaXN0ZW5lcnMiLCJxdWV1ZUNhbGxiYWNrIiwicXVldWVNaWNyb3Rhc2siLCJxdWV1ZU5vdGlmaWNhdGlvbiIsIm5vdGlmeUxpc3RlbmVycyIsImZvckVhY2giLCJsIiwic3Vic2NyaWJlIiwibGlzdGVuZXIyIiwid3JhcHBlZExpc3RlbmVyIiwidW5zdWJzY3JpYmUiLCJkZWxldGUiLCJkaXNwYXRjaCIsImJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VycyIsIm1pZGRsZXdhcmVFbmhhbmNlciIsImdldERlZmF1bHRFbmhhbmNlcnMiLCJhdXRvQmF0Y2giLCJlbmhhbmNlckFycmF5IiwiSVNfUFJPRFVDVElPTiIsInJlZHVjZXIiLCJtaWRkbGV3YXJlIiwiZGV2VG9vbHMiLCJwcmVsb2FkZWRTdGF0ZSIsImVuaGFuY2VycyIsInJvb3RSZWR1Y2VyIiwiY29tYmluZVJlZHVjZXJzIiwiZmluYWxNaWRkbGV3YXJlIiwiX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UzIiwiaXRlbSIsIl9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNCIsImZpbmFsQ29tcG9zZSIsInRyYWNlIiwiYXBwbHlNaWRkbGV3YXJlIiwiX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U1Iiwic3RvcmVFbmhhbmNlcnMiLCJfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTYiLCJfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTciLCJpbmNsdWRlcyIsImNvbXBvc2VkRW5oYW5jZXIiLCJjcmVhdGVTdG9yZSIsImltcG9ydF9pbW1lcjMiLCJleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayIsImJ1aWxkZXJDYWxsYmFjayIsImFjdGlvbnNNYXAiLCJhY3Rpb25NYXRjaGVycyIsImRlZmF1bHRDYXNlUmVkdWNlciIsImJ1aWxkZXIiLCJhZGRDYXNlIiwidHlwZU9yQWN0aW9uQ3JlYXRvciIsImFkZE1hdGNoZXIiLCJtYXRjaGVyIiwiYWRkRGVmYXVsdENhc2UiLCJpc1N0YXRlRnVuY3Rpb24iLCJpbml0aWFsU3RhdGUiLCJtYXBPckJ1aWxkZXJDYWxsYmFjayIsImZpbmFsQWN0aW9uTWF0Y2hlcnMiLCJmaW5hbERlZmF1bHRDYXNlUmVkdWNlciIsImdldEluaXRpYWxTdGF0ZSIsImZyb3plbkluaXRpYWxTdGF0ZSIsImNhc2VSZWR1Y2VycyIsImZpbHRlciIsInJlZHVjZXIyIiwiY3IiLCJyZWR1Y2UiLCJwcmV2aW91c1N0YXRlIiwiY2FzZVJlZHVjZXIiLCJkcmFmdCIsInVybEFscGhhYmV0Iiwic2l6ZSIsImlkIiwiaSIsIk1hdGgiLCJyYW5kb20iLCJtYXRjaGVzIiwibWF0Y2hlcnMiLCJoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YSIsInZhbGlkU3RhdHVzIiwiaGFzVmFsaWRSZXF1ZXN0SWQiLCJyZXF1ZXN0SWQiLCJoYXNWYWxpZFJlcXVlc3RTdGF0dXMiLCJyZXF1ZXN0U3RhdHVzIiwiaXNBc3luY1RodW5rQXJyYXkiLCJhIiwiYXN5bmNUaHVua3MiLCJhc3luY1RodW5rIiwicGVuZGluZyIsImNvbWJpbmVkTWF0Y2hlciIsInJlamVjdGVkIiwiaGFzRmxhZyIsInJlamVjdGVkV2l0aFZhbHVlIiwiZnVsZmlsbGVkIiwiY29tbW9uUHJvcGVydGllcyIsIlJlamVjdFdpdGhWYWx1ZSIsIkZ1bGZpbGxXaXRoTWV0YSIsInNpbXBsZUVycm9yIiwicHJvcGVydHkiLCJtZXNzYWdlIiwiU3RyaW5nIiwiY3JlYXRlQXN5bmNUaHVuazIiLCJ0eXBlUHJlZml4IiwicGF5bG9hZENyZWF0b3IiLCJhcmciLCJzZXJpYWxpemVFcnJvciIsImFib3J0ZWQiLCJjb25kaXRpb24iLCJleHRyYSIsImlkR2VuZXJhdG9yIiwiYWJvcnRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwiYWJvcnRIYW5kbGVyIiwiYWJvcnRSZWFzb24iLCJhYm9ydCIsInJlYXNvbiIsInByb21pc2UiLCJmaW5hbEFjdGlvbiIsImNvbmRpdGlvblJlc3VsdCIsImlzVGhlbmFibGUiLCJzaWduYWwiLCJhYm9ydGVkUHJvbWlzZSIsIlByb21pc2UiLCJyZWplY3QiLCJhZGRFdmVudExpc3RlbmVyIiwiZ2V0UGVuZGluZ01ldGEiLCJyYWNlIiwicmVzb2x2ZSIsInJlamVjdFdpdGhWYWx1ZSIsImZ1bGZpbGxXaXRoVmFsdWUiLCJ0aGVuIiwiZXJyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNraXBEaXNwYXRjaCIsImRpc3BhdGNoQ29uZGl0aW9uUmVqZWN0aW9uIiwidW53cmFwIiwic2V0dGxlZCIsImFzeW5jVGh1bmtTeW1ib2wiLCJmb3IiLCJSZWR1Y2VyVHlwZTIiLCJnZXRUeXBlIiwiYWN0aW9uS2V5IiwiY3JlYXRvcnMiLCJjQVQiLCJjcmVhdGVTbGljZTIiLCJyZWR1Y2VyUGF0aCIsInByb2Nlc3MiLCJyZWR1Y2VycyIsImJ1aWxkUmVkdWNlckNyZWF0b3JzIiwicmVkdWNlck5hbWVzIiwiY29udGV4dCIsInNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lIiwic2xpY2VDYXNlUmVkdWNlcnNCeVR5cGUiLCJhY3Rpb25DcmVhdG9ycyIsInNsaWNlTWF0Y2hlcnMiLCJjb250ZXh0TWV0aG9kcyIsImV4cG9zZUFjdGlvbiIsIm5hbWUyIiwiZXhwb3NlQ2FzZVJlZHVjZXIiLCJyZWR1Y2VyTmFtZSIsInJlZHVjZXJEZWZpbml0aW9uIiwicmVkdWNlckRldGFpbHMiLCJjcmVhdGVOb3RhdGlvbiIsImlzQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb24iLCJoYW5kbGVUaHVua0Nhc2VSZWR1Y2VyRGVmaW5pdGlvbiIsImhhbmRsZU5vcm1hbFJlZHVjZXJEZWZpbml0aW9uIiwiYnVpbGRSZWR1Y2VyIiwiZXh0cmFSZWR1Y2VycyIsImZpbmFsQ2FzZVJlZHVjZXJzIiwic00iLCJtIiwic2VsZWN0U2VsZiIsImluamVjdGVkU2VsZWN0b3JDYWNoZSIsIk1hcCIsIl9yZWR1Y2VyIiwibWFrZVNlbGVjdG9yUHJvcHMiLCJyZWR1Y2VyUGF0aDIiLCJpbmplY3RlZCIsInNlbGVjdFNsaWNlIiwic2xpY2VTdGF0ZSIsImdldFNlbGVjdG9ycyIsInNlbGVjdFN0YXRlIiwic2VsZWN0b3JDYWNoZSIsIldlYWtNYXAiLCJzZWxlY3RvcnMiLCJ3cmFwU2VsZWN0b3IiLCJhY3Rpb25zIiwiaW5qZWN0SW50byIsImluamVjdGFibGUiLCJwYXRoT3B0IiwiY29uZmlnIiwibmV3UmVkdWNlclBhdGgiLCJpbmplY3QiLCJ3cmFwcGVyIiwicm9vdFN0YXRlIiwidW53cmFwcGVkIiwiX3JlZHVjZXJEZWZpbml0aW9uVHlwZSIsInByZXBhcmVkUmVkdWNlciIsInByZXBhcmUiLCJtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSIsInByZXBhcmVDYWxsYmFjayIsImlzQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZURlZmluaXRpb24iLCJfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTgiLCJub29wIiwiZ2V0SW5pdGlhbEVudGl0eVN0YXRlIiwiaWRzIiwiZW50aXRpZXMiLCJjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5Iiwic3RhdGVBZGFwdGVyIiwiYWRkaXRpb25hbFN0YXRlIiwic2V0QWxsIiwiY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSIsInNlbGVjdElkcyIsInNlbGVjdEVudGl0aWVzIiwic2VsZWN0QWxsIiwic2VsZWN0SWQiLCJzZWxlY3RCeUlkIiwic2VsZWN0VG90YWwiLCJzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMiLCJpbXBvcnRfaW1tZXI0IiwiaXNEcmFmdFR5cGVkIiwiY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yIiwibXV0YXRvciIsIm9wZXJhdG9yIiwiY3JlYXRlU3RhdGVPcGVyYXRvciIsIm9wZXJhdGlvbiIsImlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50IiwiYXJnMiIsInJ1bk11dGF0b3IiLCJzZWxlY3RJZFZhbHVlIiwiZW50aXR5IiwiZW5zdXJlRW50aXRpZXNBcnJheSIsInNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMiLCJuZXdFbnRpdGllcyIsImFkZGVkIiwidXBkYXRlZCIsImNoYW5nZXMiLCJjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlciIsImFkZE9uZU11dGFibHkiLCJhZGRNYW55TXV0YWJseSIsInNldE9uZU11dGFibHkiLCJzZXRNYW55TXV0YWJseSIsInNldEFsbE11dGFibHkiLCJyZW1vdmVPbmVNdXRhYmx5IiwicmVtb3ZlTWFueU11dGFibHkiLCJkaWRNdXRhdGUiLCJyZW1vdmVBbGxNdXRhYmx5IiwidGFrZU5ld0tleSIsIm9yaWdpbmFsMyIsIm5ld0tleSIsImhhc05ld0tleSIsInVwZGF0ZU9uZU11dGFibHkiLCJ1cGRhdGVNYW55TXV0YWJseSIsInVwZGF0ZXMiLCJuZXdLZXlzIiwidXBkYXRlc1BlckVudGl0eSIsImRpZE11dGF0ZUVudGl0aWVzIiwiZGlkTXV0YXRlSWRzIiwiZSIsInVwc2VydE9uZU11dGFibHkiLCJ1cHNlcnRNYW55TXV0YWJseSIsInJlbW92ZUFsbCIsImFkZE9uZSIsImFkZE1hbnkiLCJzZXRPbmUiLCJzZXRNYW55IiwidXBkYXRlT25lIiwidXBkYXRlTWFueSIsInVwc2VydE9uZSIsInVwc2VydE1hbnkiLCJyZW1vdmVPbmUiLCJyZW1vdmVNYW55IiwiY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyIiwic29ydCIsIm1vZGVscyIsIm1vZGVsIiwibWVyZ2UiLCJhcHBsaWVkVXBkYXRlcyIsIm5ld0lkIiwicmVzb3J0RW50aXRpZXMiLCJhcmVBcnJheXNFcXVhbCIsImIiLCJhbGxFbnRpdGllcyIsIm5ld1NvcnRlZElkcyIsInNvcnRDb21wYXJlciIsImluc3RhbmNlIiwic3RhdGVGYWN0b3J5Iiwic2VsZWN0b3JzRmFjdG9yeSIsImltcG9ydF9yZWR1eDUiLCJ0YXNrIiwibGlzdGVuZXIiLCJjb21wbGV0ZWQiLCJjYW5jZWxsZWQiLCJ0YXNrQ2FuY2VsbGVkIiwidGFza0NvbXBsZXRlZCIsImxpc3RlbmVyQ2FuY2VsbGVkIiwibGlzdGVuZXJDb21wbGV0ZWQiLCJjb2RlIiwiYXNzZXJ0RnVuY3Rpb24iLCJmdW5jIiwiZXhwZWN0ZWQiLCJub29wMiIsImNhdGNoUmVqZWN0aW9uIiwib25FcnJvciIsImNhdGNoIiwiYWRkQWJvcnRTaWduYWxMaXN0ZW5lciIsImFib3J0U2lnbmFsIiwiY2FsbGJhY2siLCJvbmNlIiwiYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbiIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwidmFsaWRhdGVBY3RpdmUiLCJyYWNlV2l0aFNpZ25hbCIsImNsZWFudXAiLCJub3RpZnlSZWplY3Rpb24iLCJmaW5hbGx5IiwicnVuVGFzayIsInRhc2syIiwiY2xlYW5VcCIsInN0YXR1cyIsImNyZWF0ZVBhdXNlIiwib3V0cHV0IiwiY3JlYXRlRGVsYXkiLCJwYXVzZSIsInRpbWVvdXRNcyIsIklOVEVSTkFMX05JTF9UT0tFTiIsImFsbSIsImNyZWF0ZUZvcmsiLCJwYXJlbnRBYm9ydFNpZ25hbCIsInBhcmVudEJsb2NraW5nUHJvbWlzZXMiLCJsaW5rQ29udHJvbGxlcnMiLCJjb250cm9sbGVyIiwidGFza0V4ZWN1dG9yIiwib3B0cyIsImNoaWxkQWJvcnRDb250cm9sbGVyIiwicmVzdWx0MiIsImRlbGF5IiwiYXV0b0pvaW4iLCJjYW5jZWwiLCJjcmVhdGVUYWtlUGF0dGVybiIsInN0YXJ0TGlzdGVuaW5nIiwidGFrZSIsInByZWRpY2F0ZSIsInR1cGxlUHJvbWlzZSIsInN0b3BMaXN0ZW5pbmciLCJlZmZlY3QiLCJsaXN0ZW5lckFwaSIsImdldE9yaWdpbmFsU3RhdGUiLCJwcm9taXNlcyIsImdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20iLCJjcmVhdGVMaXN0ZW5lckVudHJ5IiwiY2FuY2VsQWN0aXZlTGlzdGVuZXJzIiwiY3JlYXRlQ2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUiLCJsaXN0ZW5lck1hcCIsImNsZWFyIiwic2FmZWx5Tm90aWZ5RXJyb3IiLCJlcnJvckhhbmRsZXIiLCJlcnJvclRvTm90aWZ5IiwiZXJyb3JJbmZvIiwiZXJyb3JIYW5kbGVyRXJyb3IiLCJkZWZhdWx0RXJyb3JIYW5kbGVyIiwibWlkZGxld2FyZU9wdGlvbnMiLCJpbnNlcnRFbnRyeSIsImNhbmNlbE9wdGlvbnMiLCJjYW5jZWxBY3RpdmUiLCJleGlzdGluZ0VudHJ5IiwiZW50cnkyIiwibWF0Y2hQcmVkaWNhdGVPclR5cGUiLCJub3RpZnlMaXN0ZW5lciIsImFwaSIsImludGVybmFsVGFza0NvbnRyb2xsZXIiLCJhdXRvSm9pblByb21pc2VzIiwiQm9vbGVhbiIsImZvcmsiLCJ0aHJvd0lmQ2FuY2VsbGVkIiwibGlzdGVuZXJFcnJvciIsInJhaXNlZEJ5IiwiY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUiLCJvcmlnaW5hbFN0YXRlIiwiY3VycmVudFN0YXRlIiwibGlzdGVuZXJFbnRyaWVzIiwicnVuTGlzdGVuZXIiLCJwcmVkaWNhdGVFcnJvciIsImNsZWFyTGlzdGVuZXJzIiwiaW1wb3J0X3JlZHV4NiIsImNyZWF0ZU1pZGRsZXdhcmVFbnRyeSIsImFwcGxpZWQiLCJtYXRjaEluc3RhbmNlIiwiaW5zdGFuY2VJZCIsIm1pZGRsZXdhcmVNYXAiLCJ3aXRoTWlkZGxld2FyZSIsIm1pZGRsZXdhcmVzIiwiYWRkTWlkZGxld2FyZSIsImFkZE1pZGRsZXdhcmUyIiwibWlkZGxld2FyZTIiLCJnZXRGaW5hbE1pZGRsZXdhcmUiLCJhcHBsaWVkTWlkZGxld2FyZSIsImlzV2l0aE1pZGRsZXdhcmUiLCJpbXBvcnRfcmVkdXg3IiwiaXNTbGljZUxpa2UiLCJtYXliZVNsaWNlTGlrZSIsImdldFJlZHVjZXJzIiwic2xpY2VzIiwiZmxhdE1hcCIsInNsaWNlT3JNYXAiLCJPUklHSU5BTF9TVEFURSIsImlzU3RhdGVQcm94eSIsInN0YXRlUHJveHlNYXAiLCJjcmVhdGVTdGF0ZVByb3h5IiwicmVkdWNlck1hcCIsIlByb3h5IiwicHJvcCIsInJlY2VpdmVyIiwiUmVmbGVjdCIsInJlZHVjZXJSZXN1bHQiLCJub29wUmVkdWNlciIsImZyb21FbnRyaWVzIiwiZ2V0UmVkdWNlciIsImNvbWJpbmVkUmVkdWNlciIsIndpdGhMYXp5TG9hZGVkU2xpY2VzIiwicmVkdWNlclRvSW5qZWN0IiwiY3VycmVudFJlZHVjZXIiLCJvdmVycmlkZUV4aXN0aW5nIiwibWFrZVNlbGVjdG9yIiwic2VsZWN0b3JGbiIsInNlbGVjdG9yMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/cjs/redux-toolkit.development.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReducerType: () => (/* binding */ ReducerType),\n/* harmony export */   SHOULD_AUTOBATCH: () => (/* binding */ SHOULD_AUTOBATCH),\n/* harmony export */   TaskAbortError: () => (/* binding */ TaskAbortError),\n/* harmony export */   Tuple: () => (/* binding */ Tuple),\n/* harmony export */   __DO_NOT_USE__ActionTypes: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.__DO_NOT_USE__ActionTypes),\n/* harmony export */   addListener: () => (/* binding */ addListener),\n/* harmony export */   applyMiddleware: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware),\n/* harmony export */   asyncThunkCreator: () => (/* binding */ asyncThunkCreator),\n/* harmony export */   autoBatchEnhancer: () => (/* binding */ autoBatchEnhancer),\n/* harmony export */   bindActionCreators: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.bindActionCreators),\n/* harmony export */   buildCreateSlice: () => (/* binding */ buildCreateSlice),\n/* harmony export */   clearAllListeners: () => (/* binding */ clearAllListeners),\n/* harmony export */   combineReducers: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers),\n/* harmony export */   combineSlices: () => (/* binding */ combineSlices),\n/* harmony export */   compose: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.compose),\n/* harmony export */   configureStore: () => (/* binding */ configureStore),\n/* harmony export */   createAction: () => (/* binding */ createAction),\n/* harmony export */   createActionCreatorInvariantMiddleware: () => (/* binding */ createActionCreatorInvariantMiddleware),\n/* harmony export */   createAsyncThunk: () => (/* binding */ createAsyncThunk),\n/* harmony export */   createDraftSafeSelector: () => (/* binding */ createDraftSafeSelector),\n/* harmony export */   createDraftSafeSelectorCreator: () => (/* binding */ createDraftSafeSelectorCreator),\n/* harmony export */   createDynamicMiddleware: () => (/* binding */ createDynamicMiddleware),\n/* harmony export */   createEntityAdapter: () => (/* binding */ createEntityAdapter),\n/* harmony export */   createImmutableStateInvariantMiddleware: () => (/* binding */ createImmutableStateInvariantMiddleware),\n/* harmony export */   createListenerMiddleware: () => (/* binding */ createListenerMiddleware),\n/* harmony export */   createNextState: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.produce),\n/* harmony export */   createReducer: () => (/* binding */ createReducer),\n/* harmony export */   createSelector: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector),\n/* harmony export */   createSelectorCreator: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator),\n/* harmony export */   createSerializableStateInvariantMiddleware: () => (/* binding */ createSerializableStateInvariantMiddleware),\n/* harmony export */   createSlice: () => (/* binding */ createSlice),\n/* harmony export */   createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.createStore),\n/* harmony export */   current: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.current),\n/* harmony export */   findNonSerializableValue: () => (/* binding */ findNonSerializableValue),\n/* harmony export */   formatProdErrorMessage: () => (/* binding */ formatProdErrorMessage),\n/* harmony export */   freeze: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.freeze),\n/* harmony export */   isAction: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isAction),\n/* harmony export */   isActionCreator: () => (/* binding */ isActionCreator),\n/* harmony export */   isAllOf: () => (/* binding */ isAllOf),\n/* harmony export */   isAnyOf: () => (/* binding */ isAnyOf),\n/* harmony export */   isAsyncThunkAction: () => (/* binding */ isAsyncThunkAction),\n/* harmony export */   isDraft: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.isDraft),\n/* harmony export */   isFluxStandardAction: () => (/* binding */ isFSA),\n/* harmony export */   isFulfilled: () => (/* binding */ isFulfilled),\n/* harmony export */   isImmutableDefault: () => (/* binding */ isImmutableDefault),\n/* harmony export */   isPending: () => (/* binding */ isPending),\n/* harmony export */   isPlain: () => (/* binding */ isPlain),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject),\n/* harmony export */   isRejected: () => (/* binding */ isRejected),\n/* harmony export */   isRejectedWithValue: () => (/* binding */ isRejectedWithValue),\n/* harmony export */   legacy_createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.legacy_createStore),\n/* harmony export */   lruMemoize: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.lruMemoize),\n/* harmony export */   miniSerializeError: () => (/* binding */ miniSerializeError),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   original: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.original),\n/* harmony export */   prepareAutoBatched: () => (/* binding */ prepareAutoBatched),\n/* harmony export */   removeListener: () => (/* binding */ removeListener),\n/* harmony export */   unwrapResult: () => (/* binding */ unwrapResult),\n/* harmony export */   weakMapMemoize: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize)\n/* harmony export */ });\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.mjs\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/reselect.mjs\");\n/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-thunk */ \"(ssr)/./node_modules/redux-thunk/dist/redux-thunk.mjs\");\n// src/index.ts\n\n\n\n// src/createDraftSafeSelector.ts\n\n\nvar createDraftSafeSelectorCreator = (...args)=>{\n    const createSelector2 = (0,reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator)(...args);\n    const createDraftSafeSelector2 = Object.assign((...args2)=>{\n        const selector = createSelector2(...args2);\n        const wrappedSelector = (value, ...rest)=>selector((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value, ...rest);\n        Object.assign(wrappedSelector, selector);\n        return wrappedSelector;\n    }, {\n        withTypes: ()=>createDraftSafeSelector2\n    });\n    return createDraftSafeSelector2;\n};\nvar createDraftSafeSelector = createDraftSafeSelectorCreator(reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize);\n// src/configureStore.ts\n\n// src/devtoolsExtension.ts\n\nvar composeWithDevTools =  false ? 0 : function() {\n    if (arguments.length === 0) return void 0;\n    if (typeof arguments[0] === \"object\") return redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    return redux__WEBPACK_IMPORTED_MODULE_0__.compose.apply(null, arguments);\n};\nvar devToolsEnhancer =  false ? 0 : function() {\n    return function(noop3) {\n        return noop3;\n    };\n};\n// src/getDefaultMiddleware.ts\n\n// src/createAction.ts\n\n// src/tsHelpers.ts\nvar hasMatchFunction = (v)=>{\n    return v && typeof v.match === \"function\";\n};\n// src/createAction.ts\nfunction createAction(type, prepareAction) {\n    function actionCreator(...args) {\n        if (prepareAction) {\n            let prepared = prepareAction(...args);\n            if (!prepared) {\n                throw new Error( false ? 0 : \"prepareAction did not return an object\");\n            }\n            return {\n                type,\n                payload: prepared.payload,\n                ...\"meta\" in prepared && {\n                    meta: prepared.meta\n                },\n                ...\"error\" in prepared && {\n                    error: prepared.error\n                }\n            };\n        }\n        return {\n            type,\n            payload: args[0]\n        };\n    }\n    actionCreator.toString = ()=>`${type}`;\n    actionCreator.type = type;\n    actionCreator.match = (action)=>(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && action.type === type;\n    return actionCreator;\n}\nfunction isActionCreator(action) {\n    return typeof action === \"function\" && \"type\" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it\n    hasMatchFunction(action);\n}\nfunction isFSA(action) {\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && Object.keys(action).every(isValidKey);\n}\nfunction isValidKey(key) {\n    return [\n        \"type\",\n        \"payload\",\n        \"error\",\n        \"meta\"\n    ].indexOf(key) > -1;\n}\n// src/actionCreatorInvariantMiddleware.ts\nfunction getMessage(type) {\n    const splitType = type ? `${type}`.split(\"/\") : [];\n    const actionName = splitType[splitType.length - 1] || \"actionCreator\";\n    return `Detected an action creator with type \"${type || \"unknown\"}\" being dispatched. \nMake sure you're calling the action creator before dispatching, i.e. \\`dispatch(${actionName}())\\` instead of \\`dispatch(${actionName})\\`. This is necessary even if the action has no payload.`;\n}\nfunction createActionCreatorInvariantMiddleware(options = {}) {\n    if (false) {}\n    const { isActionCreator: isActionCreator2 = isActionCreator } = options;\n    return ()=>(next)=>(action)=>{\n                if (isActionCreator2(action)) {\n                    console.warn(getMessage(action.type));\n                }\n                return next(action);\n            };\n}\n// src/utils.ts\n\nfunction getTimeMeasureUtils(maxDelay, fnName) {\n    let elapsed = 0;\n    return {\n        measureTime (fn) {\n            const started = Date.now();\n            try {\n                return fn();\n            } finally{\n                const finished = Date.now();\n                elapsed += finished - started;\n            }\n        },\n        warnIfExceeded () {\n            if (elapsed > maxDelay) {\n                console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that.`);\n            }\n        }\n    };\n}\nfunction find(iterable, comparator) {\n    for (const entry of iterable){\n        if (comparator(entry)) {\n            return entry;\n        }\n    }\n    return void 0;\n}\nvar Tuple = class _Tuple extends Array {\n    constructor(...items){\n        super(...items);\n        Object.setPrototypeOf(this, _Tuple.prototype);\n    }\n    static get [Symbol.species]() {\n        return _Tuple;\n    }\n    concat(...arr) {\n        return super.concat.apply(this, arr);\n    }\n    prepend(...arr) {\n        if (arr.length === 1 && Array.isArray(arr[0])) {\n            return new _Tuple(...arr[0].concat(this));\n        }\n        return new _Tuple(...arr.concat(this));\n    }\n};\nfunction freezeDraftable(val) {\n    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(val) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(val, ()=>{}) : val;\n}\nfunction emplace(map, key, handler) {\n    if (map.has(key)) {\n        let value = map.get(key);\n        if (handler.update) {\n            value = handler.update(value, key, map);\n            map.set(key, value);\n        }\n        return value;\n    }\n    if (!handler.insert) throw new Error( false ? 0 : \"No insert provided for key not already in map\");\n    const inserted = handler.insert(key, map);\n    map.set(key, inserted);\n    return inserted;\n}\n// src/immutableStateInvariantMiddleware.ts\nfunction isImmutableDefault(value) {\n    return typeof value !== \"object\" || value == null || Object.isFrozen(value);\n}\nfunction trackForMutations(isImmutable, ignorePaths, obj) {\n    const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);\n    return {\n        detectMutations () {\n            return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);\n        }\n    };\n}\nfunction trackProperties(isImmutable, ignorePaths = [], obj, path = \"\", checkedObjects = /* @__PURE__ */ new Set()) {\n    const tracked = {\n        value: obj\n    };\n    if (!isImmutable(obj) && !checkedObjects.has(obj)) {\n        checkedObjects.add(obj);\n        tracked.children = {};\n        for(const key in obj){\n            const childPath = path ? path + \".\" + key : key;\n            if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\n                continue;\n            }\n            tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);\n        }\n    }\n    return tracked;\n}\nfunction detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path = \"\") {\n    const prevObj = trackedProperty ? trackedProperty.value : void 0;\n    const sameRef = prevObj === obj;\n    if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\n        return {\n            wasMutated: true,\n            path\n        };\n    }\n    if (isImmutable(prevObj) || isImmutable(obj)) {\n        return {\n            wasMutated: false\n        };\n    }\n    const keysToDetect = {};\n    for(let key in trackedProperty.children){\n        keysToDetect[key] = true;\n    }\n    for(let key in obj){\n        keysToDetect[key] = true;\n    }\n    const hasIgnoredPaths = ignoredPaths.length > 0;\n    for(let key in keysToDetect){\n        const nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            const hasMatches = ignoredPaths.some((ignored)=>{\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                continue;\n            }\n        }\n        const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);\n        if (result.wasMutated) {\n            return result;\n        }\n    }\n    return {\n        wasMutated: false\n    };\n}\nfunction createImmutableStateInvariantMiddleware(options = {}) {\n    if (false) {} else {\n        let stringify2 = function(obj, serializer, indent, decycler) {\n            return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);\n        }, getSerialize2 = function(serializer, decycler) {\n            let stack = [], keys = [];\n            if (!decycler) decycler = function(_, value) {\n                if (stack[0] === value) return \"[Circular ~]\";\n                return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n            };\n            return function(key, value) {\n                if (stack.length > 0) {\n                    var thisPos = stack.indexOf(this);\n                    ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n                    ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n                    if (~stack.indexOf(value)) value = decycler.call(this, key, value);\n                } else stack.push(value);\n                return serializer == null ? value : serializer.call(this, key, value);\n            };\n        };\n        var stringify = stringify2, getSerialize = getSerialize2;\n        let { isImmutable = isImmutableDefault, ignoredPaths, warnAfter = 32 } = options;\n        const track = trackForMutations.bind(null, isImmutable, ignoredPaths);\n        return ({ getState })=>{\n            let state = getState();\n            let tracker = track(state);\n            let result;\n            return (next)=>(action)=>{\n                    const measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\n                    measureUtils.measureTime(()=>{\n                        state = getState();\n                        result = tracker.detectMutations();\n                        tracker = track(state);\n                        if (result.wasMutated) {\n                            throw new Error( false ? 0 : `A state mutation was detected between dispatches, in the path '${result.path || \"\"}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n                        }\n                    });\n                    const dispatchedAction = next(action);\n                    measureUtils.measureTime(()=>{\n                        state = getState();\n                        result = tracker.detectMutations();\n                        tracker = track(state);\n                        if (result.wasMutated) {\n                            throw new Error( false ? 0 : `A state mutation was detected inside a dispatch, in the path: ${result.path || \"\"}. Take a look at the reducer(s) handling the action ${stringify2(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n                        }\n                    });\n                    measureUtils.warnIfExceeded();\n                    return dispatchedAction;\n                };\n        };\n    }\n}\n// src/serializableStateInvariantMiddleware.ts\n\nfunction isPlain(val) {\n    const type = typeof val;\n    return val == null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || (0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(val);\n}\nfunction findNonSerializableValue(value, path = \"\", isSerializable = isPlain, getEntries, ignoredPaths = [], cache) {\n    let foundNestedSerializable;\n    if (!isSerializable(value)) {\n        return {\n            keyPath: path || \"<root>\",\n            value\n        };\n    }\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    if (cache?.has(value)) return false;\n    const entries = getEntries != null ? getEntries(value) : Object.entries(value);\n    const hasIgnoredPaths = ignoredPaths.length > 0;\n    for (const [key, nestedValue] of entries){\n        const nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            const hasMatches = ignoredPaths.some((ignored)=>{\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                continue;\n            }\n        }\n        if (!isSerializable(nestedValue)) {\n            return {\n                keyPath: nestedPath,\n                value: nestedValue\n            };\n        }\n        if (typeof nestedValue === \"object\") {\n            foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);\n            if (foundNestedSerializable) {\n                return foundNestedSerializable;\n            }\n        }\n    }\n    if (cache && isNestedFrozen(value)) cache.add(value);\n    return false;\n}\nfunction isNestedFrozen(value) {\n    if (!Object.isFrozen(value)) return false;\n    for (const nestedValue of Object.values(value)){\n        if (typeof nestedValue !== \"object\" || nestedValue === null) continue;\n        if (!isNestedFrozen(nestedValue)) return false;\n    }\n    return true;\n}\nfunction createSerializableStateInvariantMiddleware(options = {}) {\n    if (false) {} else {\n        const { isSerializable = isPlain, getEntries, ignoredActions = [], ignoredActionPaths = [\n            \"meta.arg\",\n            \"meta.baseQueryMeta\"\n        ], ignoredPaths = [], warnAfter = 32, ignoreState = false, ignoreActions = false, disableCache = false } = options;\n        const cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;\n        return (storeAPI)=>(next)=>(action)=>{\n                    if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n                        return next(action);\n                    }\n                    const result = next(action);\n                    const measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\n                    if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\n                        measureUtils.measureTime(()=>{\n                            const foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths, cache);\n                            if (foundActionNonSerializableValue) {\n                                const { keyPath, value } = foundActionNonSerializableValue;\n                                console.error(`A non-serializable value was detected in an action, in the path: \\`${keyPath}\\`. Value:`, value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\n                            }\n                        });\n                    }\n                    if (!ignoreState) {\n                        measureUtils.measureTime(()=>{\n                            const state = storeAPI.getState();\n                            const foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths, cache);\n                            if (foundStateNonSerializableValue) {\n                                const { keyPath, value } = foundStateNonSerializableValue;\n                                console.error(`A non-serializable value was detected in the state, in the path: \\`${keyPath}\\`. Value:`, value, `\nTake a look at the reducer(s) handling this action type: ${action.type}.\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);\n                            }\n                        });\n                        measureUtils.warnIfExceeded();\n                    }\n                    return result;\n                };\n    }\n}\n// src/getDefaultMiddleware.ts\nfunction isBoolean(x) {\n    return typeof x === \"boolean\";\n}\nvar buildGetDefaultMiddleware = ()=>function getDefaultMiddleware(options) {\n        const { thunk = true, immutableCheck = true, serializableCheck = true, actionCreatorCheck = true } = options ?? {};\n        let middlewareArray = new Tuple();\n        if (thunk) {\n            if (isBoolean(thunk)) {\n                middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__.thunk);\n            } else {\n                middlewareArray.push((0,redux_thunk__WEBPACK_IMPORTED_MODULE_3__.withExtraArgument)(thunk.extraArgument));\n            }\n        }\n        if (true) {\n            if (immutableCheck) {\n                let immutableOptions = {};\n                if (!isBoolean(immutableCheck)) {\n                    immutableOptions = immutableCheck;\n                }\n                middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));\n            }\n            if (serializableCheck) {\n                let serializableOptions = {};\n                if (!isBoolean(serializableCheck)) {\n                    serializableOptions = serializableCheck;\n                }\n                middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));\n            }\n            if (actionCreatorCheck) {\n                let actionCreatorOptions = {};\n                if (!isBoolean(actionCreatorCheck)) {\n                    actionCreatorOptions = actionCreatorCheck;\n                }\n                middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));\n            }\n        }\n        return middlewareArray;\n    };\n// src/autoBatchEnhancer.ts\nvar SHOULD_AUTOBATCH = \"RTK_autoBatch\";\nvar prepareAutoBatched = ()=>(payload)=>({\n            payload,\n            meta: {\n                [SHOULD_AUTOBATCH]: true\n            }\n        });\nvar createQueueWithTimer = (timeout)=>{\n    return (notify)=>{\n        setTimeout(notify, timeout);\n    };\n};\nvar rAF =  false ? 0 : createQueueWithTimer(10);\nvar autoBatchEnhancer = (options = {\n    type: \"raf\"\n})=>(next)=>(...args)=>{\n            const store = next(...args);\n            let notifying = true;\n            let shouldNotifyAtEndOfTick = false;\n            let notificationQueued = false;\n            const listeners = /* @__PURE__ */ new Set();\n            const queueCallback = options.type === \"tick\" ? queueMicrotask : options.type === \"raf\" ? rAF : options.type === \"callback\" ? options.queueNotification : createQueueWithTimer(options.timeout);\n            const notifyListeners = ()=>{\n                notificationQueued = false;\n                if (shouldNotifyAtEndOfTick) {\n                    shouldNotifyAtEndOfTick = false;\n                    listeners.forEach((l)=>l());\n                }\n            };\n            return Object.assign({}, store, {\n                // Override the base `store.subscribe` method to keep original listeners\n                // from running if we're delaying notifications\n                subscribe (listener2) {\n                    const wrappedListener = ()=>notifying && listener2();\n                    const unsubscribe = store.subscribe(wrappedListener);\n                    listeners.add(listener2);\n                    return ()=>{\n                        unsubscribe();\n                        listeners.delete(listener2);\n                    };\n                },\n                // Override the base `store.dispatch` method so that we can check actions\n                // for the `shouldAutoBatch` flag and determine if batching is active\n                dispatch (action) {\n                    try {\n                        notifying = !action?.meta?.[SHOULD_AUTOBATCH];\n                        shouldNotifyAtEndOfTick = !notifying;\n                        if (shouldNotifyAtEndOfTick) {\n                            if (!notificationQueued) {\n                                notificationQueued = true;\n                                queueCallback(notifyListeners);\n                            }\n                        }\n                        return store.dispatch(action);\n                    } finally{\n                        notifying = true;\n                    }\n                }\n            });\n        };\n// src/getDefaultEnhancers.ts\nvar buildGetDefaultEnhancers = (middlewareEnhancer)=>function getDefaultEnhancers(options) {\n        const { autoBatch = true } = options ?? {};\n        let enhancerArray = new Tuple(middlewareEnhancer);\n        if (autoBatch) {\n            enhancerArray.push(autoBatchEnhancer(typeof autoBatch === \"object\" ? autoBatch : void 0));\n        }\n        return enhancerArray;\n    };\n// src/configureStore.ts\nvar IS_PRODUCTION = \"development\" === \"production\";\nfunction configureStore(options) {\n    const getDefaultMiddleware = buildGetDefaultMiddleware();\n    const { reducer = void 0, middleware, devTools = true, preloadedState = void 0, enhancers = void 0 } = options || {};\n    let rootReducer;\n    if (typeof reducer === \"function\") {\n        rootReducer = reducer;\n    } else if ((0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(reducer)) {\n        rootReducer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducer);\n    } else {\n        throw new Error( false ? 0 : \"`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers\");\n    }\n    if (!IS_PRODUCTION && middleware && typeof middleware !== \"function\") {\n        throw new Error( false ? 0 : \"`middleware` field must be a callback\");\n    }\n    let finalMiddleware;\n    if (typeof middleware === \"function\") {\n        finalMiddleware = middleware(getDefaultMiddleware);\n        if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {\n            throw new Error( false ? 0 : \"when using a middleware builder function, an array of middleware must be returned\");\n        }\n    } else {\n        finalMiddleware = getDefaultMiddleware();\n    }\n    if (!IS_PRODUCTION && finalMiddleware.some((item)=>typeof item !== \"function\")) {\n        throw new Error( false ? 0 : \"each middleware provided to configureStore must be a function\");\n    }\n    let finalCompose = redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    if (devTools) {\n        finalCompose = composeWithDevTools({\n            // Enable capture of stack traces for dispatched Redux actions\n            trace: !IS_PRODUCTION,\n            ...typeof devTools === \"object\" && devTools\n        });\n    }\n    const middlewareEnhancer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware)(...finalMiddleware);\n    const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);\n    if (!IS_PRODUCTION && enhancers && typeof enhancers !== \"function\") {\n        throw new Error( false ? 0 : \"`enhancers` field must be a callback\");\n    }\n    let storeEnhancers = typeof enhancers === \"function\" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();\n    if (!IS_PRODUCTION && !Array.isArray(storeEnhancers)) {\n        throw new Error( false ? 0 : \"`enhancers` callback must return an array\");\n    }\n    if (!IS_PRODUCTION && storeEnhancers.some((item)=>typeof item !== \"function\")) {\n        throw new Error( false ? 0 : \"each enhancer provided to configureStore must be a function\");\n    }\n    if (!IS_PRODUCTION && finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {\n        console.error(\"middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`\");\n    }\n    const composedEnhancer = finalCompose(...storeEnhancers);\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.createStore)(rootReducer, preloadedState, composedEnhancer);\n}\n// src/createReducer.ts\n\n// src/mapBuilders.ts\nfunction executeReducerBuilderCallback(builderCallback) {\n    const actionsMap = {};\n    const actionMatchers = [];\n    let defaultCaseReducer;\n    const builder = {\n        addCase (typeOrActionCreator, reducer) {\n            if (true) {\n                if (actionMatchers.length > 0) {\n                    throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addMatcher`\");\n                }\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n            if (!type) {\n                throw new Error( false ? 0 : \"`builder.addCase` cannot be called with an empty action type\");\n            }\n            if (type in actionsMap) {\n                throw new Error( false ? 0 : `\\`builder.addCase\\` cannot be called with two reducers for the same action type '${type}'`);\n            }\n            actionsMap[type] = reducer;\n            return builder;\n        },\n        addMatcher (matcher, reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addMatcher` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            actionMatchers.push({\n                matcher,\n                reducer\n            });\n            return builder;\n        },\n        addDefaultCase (reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addDefaultCase` can only be called once\");\n                }\n            }\n            defaultCaseReducer = reducer;\n            return builder;\n        }\n    };\n    builderCallback(builder);\n    return [\n        actionsMap,\n        actionMatchers,\n        defaultCaseReducer\n    ];\n}\n// src/createReducer.ts\nfunction isStateFunction(x) {\n    return typeof x === \"function\";\n}\nfunction createReducer(initialState, mapOrBuilderCallback) {\n    if (true) {\n        if (typeof mapOrBuilderCallback === \"object\") {\n            throw new Error( false ? 0 : \"The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer\");\n        }\n    }\n    let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);\n    let getInitialState;\n    if (isStateFunction(initialState)) {\n        getInitialState = ()=>freezeDraftable(initialState());\n    } else {\n        const frozenInitialState = freezeDraftable(initialState);\n        getInitialState = ()=>frozenInitialState;\n    }\n    function reducer(state = getInitialState(), action) {\n        let caseReducers = [\n            actionsMap[action.type],\n            ...finalActionMatchers.filter(({ matcher })=>matcher(action)).map(({ reducer: reducer2 })=>reducer2)\n        ];\n        if (caseReducers.filter((cr)=>!!cr).length === 0) {\n            caseReducers = [\n                finalDefaultCaseReducer\n            ];\n        }\n        return caseReducers.reduce((previousState, caseReducer)=>{\n            if (caseReducer) {\n                if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(previousState)) {\n                    const draft = previousState;\n                    const result = caseReducer(draft, action);\n                    if (result === void 0) {\n                        return previousState;\n                    }\n                    return result;\n                } else if (!(0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(previousState)) {\n                    const result = caseReducer(previousState, action);\n                    if (result === void 0) {\n                        if (previousState === null) {\n                            return previousState;\n                        }\n                        throw new Error( false ? 0 : \"A case reducer on a non-draftable value must not return undefined\");\n                    }\n                    return result;\n                } else {\n                    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(previousState, (draft)=>{\n                        return caseReducer(draft, action);\n                    });\n                }\n            }\n            return previousState;\n        }, state);\n    }\n    reducer.getInitialState = getInitialState;\n    return reducer;\n}\n// src/nanoid.ts\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\nvar nanoid = (size = 21)=>{\n    let id = \"\";\n    let i = size;\n    while(i--){\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\n// src/matchers.ts\nvar matches = (matcher, action)=>{\n    if (hasMatchFunction(matcher)) {\n        return matcher.match(action);\n    } else {\n        return matcher(action);\n    }\n};\nfunction isAnyOf(...matchers) {\n    return (action)=>{\n        return matchers.some((matcher)=>matches(matcher, action));\n    };\n}\nfunction isAllOf(...matchers) {\n    return (action)=>{\n        return matchers.every((matcher)=>matches(matcher, action));\n    };\n}\nfunction hasExpectedRequestMetadata(action, validStatus) {\n    if (!action || !action.meta) return false;\n    const hasValidRequestId = typeof action.meta.requestId === \"string\";\n    const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\n    return hasValidRequestId && hasValidRequestStatus;\n}\nfunction isAsyncThunkArray(a) {\n    return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\n}\nfunction isPending(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"pending\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isPending()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.pending);\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejected(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"rejected\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejected()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.rejected);\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejectedWithValue(...asyncThunks) {\n    const hasFlag = (action)=>{\n        return action && action.meta && action.meta.rejectedWithValue;\n    };\n    if (asyncThunks.length === 0) {\n        return (action)=>{\n            const combinedMatcher = isAllOf(isRejected(...asyncThunks), hasFlag);\n            return combinedMatcher(action);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejectedWithValue()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const combinedMatcher = isAllOf(isRejected(...asyncThunks), hasFlag);\n        return combinedMatcher(action);\n    };\n}\nfunction isFulfilled(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"fulfilled\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isFulfilled()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.fulfilled);\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isAsyncThunkAction(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"pending\",\n                \"fulfilled\",\n                \"rejected\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isAsyncThunkAction()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = [];\n        for (const asyncThunk of asyncThunks){\n            matchers.push(asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled);\n        }\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\n// src/createAsyncThunk.ts\nvar commonProperties = [\n    \"name\",\n    \"message\",\n    \"stack\",\n    \"code\"\n];\nvar RejectWithValue = class {\n    constructor(payload, meta){\n        this.payload = payload;\n        this.meta = meta;\n    }\n};\nvar FulfillWithMeta = class {\n    constructor(payload, meta){\n        this.payload = payload;\n        this.meta = meta;\n    }\n};\nvar miniSerializeError = (value)=>{\n    if (typeof value === \"object\" && value !== null) {\n        const simpleError = {};\n        for (const property of commonProperties){\n            if (typeof value[property] === \"string\") {\n                simpleError[property] = value[property];\n            }\n        }\n        return simpleError;\n    }\n    return {\n        message: String(value)\n    };\n};\nvar createAsyncThunk = /* @__PURE__ */ (()=>{\n    function createAsyncThunk2(typePrefix, payloadCreator, options) {\n        const fulfilled = createAction(typePrefix + \"/fulfilled\", (payload, requestId, arg, meta)=>({\n                payload,\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    requestStatus: \"fulfilled\"\n                }\n            }));\n        const pending = createAction(typePrefix + \"/pending\", (requestId, arg, meta)=>({\n                payload: void 0,\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    requestStatus: \"pending\"\n                }\n            }));\n        const rejected = createAction(typePrefix + \"/rejected\", (error, requestId, arg, payload, meta)=>({\n                payload,\n                error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    rejectedWithValue: !!payload,\n                    requestStatus: \"rejected\",\n                    aborted: error?.name === \"AbortError\",\n                    condition: error?.name === \"ConditionError\"\n                }\n            }));\n        function actionCreator(arg) {\n            return (dispatch, getState, extra)=>{\n                const requestId = options?.idGenerator ? options.idGenerator(arg) : nanoid();\n                const abortController = new AbortController();\n                let abortHandler;\n                let abortReason;\n                function abort(reason) {\n                    abortReason = reason;\n                    abortController.abort();\n                }\n                const promise = async function() {\n                    let finalAction;\n                    try {\n                        let conditionResult = options?.condition?.(arg, {\n                            getState,\n                            extra\n                        });\n                        if (isThenable(conditionResult)) {\n                            conditionResult = await conditionResult;\n                        }\n                        if (conditionResult === false || abortController.signal.aborted) {\n                            throw {\n                                name: \"ConditionError\",\n                                message: \"Aborted due to condition callback returning false.\"\n                            };\n                        }\n                        const abortedPromise = new Promise((_, reject)=>{\n                            abortHandler = ()=>{\n                                reject({\n                                    name: \"AbortError\",\n                                    message: abortReason || \"Aborted\"\n                                });\n                            };\n                            abortController.signal.addEventListener(\"abort\", abortHandler);\n                        });\n                        dispatch(pending(requestId, arg, options?.getPendingMeta?.({\n                            requestId,\n                            arg\n                        }, {\n                            getState,\n                            extra\n                        })));\n                        finalAction = await Promise.race([\n                            abortedPromise,\n                            Promise.resolve(payloadCreator(arg, {\n                                dispatch,\n                                getState,\n                                extra,\n                                requestId,\n                                signal: abortController.signal,\n                                abort,\n                                rejectWithValue: (value, meta)=>{\n                                    return new RejectWithValue(value, meta);\n                                },\n                                fulfillWithValue: (value, meta)=>{\n                                    return new FulfillWithMeta(value, meta);\n                                }\n                            })).then((result)=>{\n                                if (result instanceof RejectWithValue) {\n                                    throw result;\n                                }\n                                if (result instanceof FulfillWithMeta) {\n                                    return fulfilled(result.payload, requestId, arg, result.meta);\n                                }\n                                return fulfilled(result, requestId, arg);\n                            })\n                        ]);\n                    } catch (err) {\n                        finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);\n                    } finally{\n                        if (abortHandler) {\n                            abortController.signal.removeEventListener(\"abort\", abortHandler);\n                        }\n                    }\n                    const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\n                    if (!skipDispatch) {\n                        dispatch(finalAction);\n                    }\n                    return finalAction;\n                }();\n                return Object.assign(promise, {\n                    abort,\n                    requestId,\n                    arg,\n                    unwrap () {\n                        return promise.then(unwrapResult);\n                    }\n                });\n            };\n        }\n        return Object.assign(actionCreator, {\n            pending,\n            rejected,\n            fulfilled,\n            settled: isAnyOf(rejected, fulfilled),\n            typePrefix\n        });\n    }\n    createAsyncThunk2.withTypes = ()=>createAsyncThunk2;\n    return createAsyncThunk2;\n})();\nfunction unwrapResult(action) {\n    if (action.meta && action.meta.rejectedWithValue) {\n        throw action.payload;\n    }\n    if (action.error) {\n        throw action.error;\n    }\n    return action.payload;\n}\nfunction isThenable(value) {\n    return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\n}\n// src/createSlice.ts\nvar asyncThunkSymbol = /* @__PURE__ */ Symbol.for(\"rtk-slice-createasyncthunk\");\nvar asyncThunkCreator = {\n    [asyncThunkSymbol]: createAsyncThunk\n};\nvar ReducerType = /* @__PURE__ */ ((ReducerType2)=>{\n    ReducerType2[\"reducer\"] = \"reducer\";\n    ReducerType2[\"reducerWithPrepare\"] = \"reducerWithPrepare\";\n    ReducerType2[\"asyncThunk\"] = \"asyncThunk\";\n    return ReducerType2;\n})(ReducerType || {});\nfunction getType(slice, actionKey) {\n    return `${slice}/${actionKey}`;\n}\nfunction buildCreateSlice({ creators } = {}) {\n    const cAT = creators?.asyncThunk?.[asyncThunkSymbol];\n    return function createSlice2(options) {\n        const { name, reducerPath = name } = options;\n        if (!name) {\n            throw new Error( false ? 0 : \"`name` is a required option for createSlice\");\n        }\n        if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n            if (options.initialState === void 0) {\n                console.error(\"You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`\");\n            }\n        }\n        const reducers = (typeof options.reducers === \"function\" ? options.reducers(buildReducerCreators()) : options.reducers) || {};\n        const reducerNames = Object.keys(reducers);\n        const context = {\n            sliceCaseReducersByName: {},\n            sliceCaseReducersByType: {},\n            actionCreators: {},\n            sliceMatchers: []\n        };\n        const contextMethods = {\n            addCase (typeOrActionCreator, reducer2) {\n                const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n                if (!type) {\n                    throw new Error( false ? 0 : \"`context.addCase` cannot be called with an empty action type\");\n                }\n                if (type in context.sliceCaseReducersByType) {\n                    throw new Error( false ? 0 : \"`context.addCase` cannot be called with two reducers for the same action type: \" + type);\n                }\n                context.sliceCaseReducersByType[type] = reducer2;\n                return contextMethods;\n            },\n            addMatcher (matcher, reducer2) {\n                context.sliceMatchers.push({\n                    matcher,\n                    reducer: reducer2\n                });\n                return contextMethods;\n            },\n            exposeAction (name2, actionCreator) {\n                context.actionCreators[name2] = actionCreator;\n                return contextMethods;\n            },\n            exposeCaseReducer (name2, reducer2) {\n                context.sliceCaseReducersByName[name2] = reducer2;\n                return contextMethods;\n            }\n        };\n        reducerNames.forEach((reducerName)=>{\n            const reducerDefinition = reducers[reducerName];\n            const reducerDetails = {\n                reducerName,\n                type: getType(name, reducerName),\n                createNotation: typeof options.reducers === \"function\"\n            };\n            if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {\n                handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);\n            } else {\n                handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);\n            }\n        });\n        function buildReducer() {\n            if (true) {\n                if (typeof options.extraReducers === \"object\") {\n                    throw new Error( false ? 0 : \"The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice\");\n                }\n            }\n            const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [\n                options.extraReducers\n            ];\n            const finalCaseReducers = {\n                ...extraReducers,\n                ...context.sliceCaseReducersByType\n            };\n            return createReducer(options.initialState, (builder)=>{\n                for(let key in finalCaseReducers){\n                    builder.addCase(key, finalCaseReducers[key]);\n                }\n                for (let sM of context.sliceMatchers){\n                    builder.addMatcher(sM.matcher, sM.reducer);\n                }\n                for (let m of actionMatchers){\n                    builder.addMatcher(m.matcher, m.reducer);\n                }\n                if (defaultCaseReducer) {\n                    builder.addDefaultCase(defaultCaseReducer);\n                }\n            });\n        }\n        const selectSelf = (state)=>state;\n        const injectedSelectorCache = /* @__PURE__ */ new Map();\n        let _reducer;\n        function reducer(state, action) {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer(state, action);\n        }\n        function getInitialState() {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer.getInitialState();\n        }\n        function makeSelectorProps(reducerPath2, injected = false) {\n            function selectSlice(state) {\n                let sliceState = state[reducerPath2];\n                if (typeof sliceState === \"undefined\") {\n                    if (injected) {\n                        sliceState = getInitialState();\n                    } else if (true) {\n                        throw new Error( false ? 0 : \"selectSlice returned undefined for an uninjected slice reducer\");\n                    }\n                }\n                return sliceState;\n            }\n            function getSelectors(selectState = selectSelf) {\n                const selectorCache = emplace(injectedSelectorCache, injected, {\n                    insert: ()=>/* @__PURE__ */ new WeakMap()\n                });\n                return emplace(selectorCache, selectState, {\n                    insert: ()=>{\n                        const map = {};\n                        for (const [name2, selector] of Object.entries(options.selectors ?? {})){\n                            map[name2] = wrapSelector(selector, selectState, getInitialState, injected);\n                        }\n                        return map;\n                    }\n                });\n            }\n            return {\n                reducerPath: reducerPath2,\n                getSelectors,\n                get selectors () {\n                    return getSelectors(selectSlice);\n                },\n                selectSlice\n            };\n        }\n        const slice = {\n            name,\n            reducer,\n            actions: context.actionCreators,\n            caseReducers: context.sliceCaseReducersByName,\n            getInitialState,\n            ...makeSelectorProps(reducerPath),\n            injectInto (injectable, { reducerPath: pathOpt, ...config } = {}) {\n                const newReducerPath = pathOpt ?? reducerPath;\n                injectable.inject({\n                    reducerPath: newReducerPath,\n                    reducer\n                }, config);\n                return {\n                    ...slice,\n                    ...makeSelectorProps(newReducerPath, true)\n                };\n            }\n        };\n        return slice;\n    };\n}\nfunction wrapSelector(selector, selectState, getInitialState, injected) {\n    function wrapper(rootState, ...args) {\n        let sliceState = selectState(rootState);\n        if (typeof sliceState === \"undefined\") {\n            if (injected) {\n                sliceState = getInitialState();\n            } else if (true) {\n                throw new Error( false ? 0 : \"selectState returned undefined for an uninjected slice reducer\");\n            }\n        }\n        return selector(sliceState, ...args);\n    }\n    wrapper.unwrapped = selector;\n    return wrapper;\n}\nvar createSlice = /* @__PURE__ */ buildCreateSlice();\nfunction buildReducerCreators() {\n    function asyncThunk(payloadCreator, config) {\n        return {\n            _reducerDefinitionType: \"asyncThunk\" /* asyncThunk */ ,\n            payloadCreator,\n            ...config\n        };\n    }\n    asyncThunk.withTypes = ()=>asyncThunk;\n    return {\n        reducer (caseReducer) {\n            return Object.assign({\n                // hack so the wrapping function has the same name as the original\n                // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original\n                [caseReducer.name] (...args) {\n                    return caseReducer(...args);\n                }\n            }[caseReducer.name], {\n                _reducerDefinitionType: \"reducer\" /* reducer */ \n            });\n        },\n        preparedReducer (prepare, reducer) {\n            return {\n                _reducerDefinitionType: \"reducerWithPrepare\" /* reducerWithPrepare */ ,\n                prepare,\n                reducer\n            };\n        },\n        asyncThunk\n    };\n}\nfunction handleNormalReducerDefinition({ type, reducerName, createNotation }, maybeReducerWithPrepare, context) {\n    let caseReducer;\n    let prepareCallback;\n    if (\"reducer\" in maybeReducerWithPrepare) {\n        if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {\n            throw new Error( false ? 0 : \"Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.\");\n        }\n        caseReducer = maybeReducerWithPrepare.reducer;\n        prepareCallback = maybeReducerWithPrepare.prepare;\n    } else {\n        caseReducer = maybeReducerWithPrepare;\n    }\n    context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));\n}\nfunction isAsyncThunkSliceReducerDefinition(reducerDefinition) {\n    return reducerDefinition._reducerDefinitionType === \"asyncThunk\" /* asyncThunk */ ;\n}\nfunction isCaseReducerWithPrepareDefinition(reducerDefinition) {\n    return reducerDefinition._reducerDefinitionType === \"reducerWithPrepare\" /* reducerWithPrepare */ ;\n}\nfunction handleThunkCaseReducerDefinition({ type, reducerName }, reducerDefinition, context, cAT) {\n    if (!cAT) {\n        throw new Error( false ? 0 : \"Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.\");\n    }\n    const { payloadCreator, fulfilled, pending, rejected, settled, options } = reducerDefinition;\n    const thunk = cAT(type, payloadCreator, options);\n    context.exposeAction(reducerName, thunk);\n    if (fulfilled) {\n        context.addCase(thunk.fulfilled, fulfilled);\n    }\n    if (pending) {\n        context.addCase(thunk.pending, pending);\n    }\n    if (rejected) {\n        context.addCase(thunk.rejected, rejected);\n    }\n    if (settled) {\n        context.addMatcher(thunk.settled, settled);\n    }\n    context.exposeCaseReducer(reducerName, {\n        fulfilled: fulfilled || noop,\n        pending: pending || noop,\n        rejected: rejected || noop,\n        settled: settled || noop\n    });\n}\nfunction noop() {}\n// src/entities/entity_state.ts\nfunction getInitialEntityState() {\n    return {\n        ids: [],\n        entities: {}\n    };\n}\nfunction createInitialStateFactory(stateAdapter) {\n    function getInitialState(additionalState = {}, entities) {\n        const state = Object.assign(getInitialEntityState(), additionalState);\n        return entities ? stateAdapter.setAll(state, entities) : state;\n    }\n    return {\n        getInitialState\n    };\n}\n// src/entities/state_selectors.ts\nfunction createSelectorsFactory() {\n    function getSelectors(selectState, options = {}) {\n        const { createSelector: createSelector2 = createDraftSafeSelector } = options;\n        const selectIds = (state)=>state.ids;\n        const selectEntities = (state)=>state.entities;\n        const selectAll = createSelector2(selectIds, selectEntities, (ids, entities)=>ids.map((id)=>entities[id]));\n        const selectId = (_, id)=>id;\n        const selectById = (entities, id)=>entities[id];\n        const selectTotal = createSelector2(selectIds, (ids)=>ids.length);\n        if (!selectState) {\n            return {\n                selectIds,\n                selectEntities,\n                selectAll,\n                selectTotal,\n                selectById: createSelector2(selectEntities, selectId, selectById)\n            };\n        }\n        const selectGlobalizedEntities = createSelector2(selectState, selectEntities);\n        return {\n            selectIds: createSelector2(selectState, selectIds),\n            selectEntities: selectGlobalizedEntities,\n            selectAll: createSelector2(selectState, selectAll),\n            selectTotal: createSelector2(selectState, selectTotal),\n            selectById: createSelector2(selectGlobalizedEntities, selectId, selectById)\n        };\n    }\n    return {\n        getSelectors\n    };\n}\n// src/entities/state_adapter.ts\n\nvar isDraftTyped = immer__WEBPACK_IMPORTED_MODULE_2__.isDraft;\nfunction createSingleArgumentStateOperator(mutator) {\n    const operator = createStateOperator((_, state)=>mutator(state));\n    return function operation(state) {\n        return operator(state, void 0);\n    };\n}\nfunction createStateOperator(mutator) {\n    return function operation(state, arg) {\n        function isPayloadActionArgument(arg2) {\n            return isFSA(arg2);\n        }\n        const runMutator = (draft)=>{\n            if (isPayloadActionArgument(arg)) {\n                mutator(arg.payload, draft);\n            } else {\n                mutator(arg, draft);\n            }\n        };\n        if (isDraftTyped(state)) {\n            runMutator(state);\n            return state;\n        }\n        return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(state, runMutator);\n    };\n}\n// src/entities/utils.ts\nfunction selectIdValue(entity, selectId) {\n    const key = selectId(entity);\n    if ( true && key === void 0) {\n        console.warn(\"The entity passed to the `selectId` implementation returned undefined.\", \"You should probably provide your own `selectId` implementation.\", \"The entity that was passed:\", entity, \"The `selectId` implementation:\", selectId.toString());\n    }\n    return key;\n}\nfunction ensureEntitiesArray(entities) {\n    if (!Array.isArray(entities)) {\n        entities = Object.values(entities);\n    }\n    return entities;\n}\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    const added = [];\n    const updated = [];\n    for (const entity of newEntities){\n        const id = selectIdValue(entity, selectId);\n        if (id in state.entities) {\n            updated.push({\n                id,\n                changes: entity\n            });\n        } else {\n            added.push(entity);\n        }\n    }\n    return [\n        added,\n        updated\n    ];\n}\n// src/entities/unsorted_state_adapter.ts\nfunction createUnsortedStateAdapter(selectId) {\n    function addOneMutably(entity, state) {\n        const key = selectIdValue(entity, selectId);\n        if (key in state.entities) {\n            return;\n        }\n        state.ids.push(key);\n        state.entities[key] = entity;\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for (const entity of newEntities){\n            addOneMutably(entity, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        const key = selectIdValue(entity, selectId);\n        if (!(key in state.entities)) {\n            state.ids.push(key);\n        }\n        ;\n        state.entities[key] = entity;\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for (const entity of newEntities){\n            setOneMutably(entity, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.ids = [];\n        state.entities = {};\n        addManyMutably(newEntities, state);\n    }\n    function removeOneMutably(key, state) {\n        return removeManyMutably([\n            key\n        ], state);\n    }\n    function removeManyMutably(keys, state) {\n        let didMutate = false;\n        keys.forEach((key)=>{\n            if (key in state.entities) {\n                delete state.entities[key];\n                didMutate = true;\n            }\n        });\n        if (didMutate) {\n            state.ids = state.ids.filter((id)=>id in state.entities);\n        }\n    }\n    function removeAllMutably(state) {\n        Object.assign(state, {\n            ids: [],\n            entities: {}\n        });\n    }\n    function takeNewKey(keys, update, state) {\n        const original3 = state.entities[update.id];\n        if (original3 === void 0) {\n            return false;\n        }\n        const updated = Object.assign({}, original3, update.changes);\n        const newKey = selectIdValue(updated, selectId);\n        const hasNewKey = newKey !== update.id;\n        if (hasNewKey) {\n            keys[update.id] = newKey;\n            delete state.entities[update.id];\n        }\n        ;\n        state.entities[newKey] = updated;\n        return hasNewKey;\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        const newKeys = {};\n        const updatesPerEntity = {};\n        updates.forEach((update)=>{\n            if (update.id in state.entities) {\n                updatesPerEntity[update.id] = {\n                    id: update.id,\n                    // Spreads ignore falsy values, so this works even if there isn't\n                    // an existing update already at this key\n                    changes: {\n                        ...updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null,\n                        ...update.changes\n                    }\n                };\n            }\n        });\n        updates = Object.values(updatesPerEntity);\n        const didMutateEntities = updates.length > 0;\n        if (didMutateEntities) {\n            const didMutateIds = updates.filter((update)=>takeNewKey(newKeys, update, state)).length > 0;\n            if (didMutateIds) {\n                state.ids = Object.values(state.entities).map((e)=>selectIdValue(e, selectId));\n            }\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    return {\n        removeAll: createSingleArgumentStateOperator(removeAllMutably),\n        addOne: createStateOperator(addOneMutably),\n        addMany: createStateOperator(addManyMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        upsertMany: createStateOperator(upsertManyMutably),\n        removeOne: createStateOperator(removeOneMutably),\n        removeMany: createStateOperator(removeManyMutably)\n    };\n}\n// src/entities/sorted_state_adapter.ts\nfunction createSortedStateAdapter(selectId, sort) {\n    const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(selectId);\n    function addOneMutably(entity, state) {\n        return addManyMutably([\n            entity\n        ], state);\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        const models = newEntities.filter((model)=>!(selectIdValue(model, selectId) in state.entities));\n        if (models.length !== 0) {\n            merge(models, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        return setManyMutably([\n            entity\n        ], state);\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        if (newEntities.length !== 0) {\n            merge(newEntities, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.entities = {};\n        state.ids = [];\n        addManyMutably(newEntities, state);\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        let appliedUpdates = false;\n        for (let update of updates){\n            const entity = state.entities[update.id];\n            if (!entity) {\n                continue;\n            }\n            appliedUpdates = true;\n            Object.assign(entity, update.changes);\n            const newId = selectId(entity);\n            if (update.id !== newId) {\n                delete state.entities[update.id];\n                state.entities[newId] = entity;\n            }\n        }\n        if (appliedUpdates) {\n            resortEntities(state);\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    function areArraysEqual(a, b) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(let i = 0; i < a.length && i < b.length; i++){\n            if (a[i] === b[i]) {\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    function merge(models, state) {\n        models.forEach((model)=>{\n            ;\n            state.entities[selectId(model)] = model;\n        });\n        resortEntities(state);\n    }\n    function resortEntities(state) {\n        const allEntities = Object.values(state.entities);\n        allEntities.sort(sort);\n        const newSortedIds = allEntities.map(selectId);\n        const { ids } = state;\n        if (!areArraysEqual(ids, newSortedIds)) {\n            state.ids = newSortedIds;\n        }\n    }\n    return {\n        removeOne,\n        removeMany,\n        removeAll,\n        addOne: createStateOperator(addOneMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        addMany: createStateOperator(addManyMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertMany: createStateOperator(upsertManyMutably)\n    };\n}\n// src/entities/create_adapter.ts\nfunction createEntityAdapter(options = {}) {\n    const { selectId, sortComparer } = {\n        sortComparer: false,\n        selectId: (instance)=>instance.id,\n        ...options\n    };\n    const stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n    const stateFactory = createInitialStateFactory(stateAdapter);\n    const selectorsFactory = createSelectorsFactory();\n    return {\n        selectId,\n        sortComparer,\n        ...stateFactory,\n        ...selectorsFactory,\n        ...stateAdapter\n    };\n}\n// src/listenerMiddleware/index.ts\n\n// src/listenerMiddleware/exceptions.ts\nvar task = \"task\";\nvar listener = \"listener\";\nvar completed = \"completed\";\nvar cancelled = \"cancelled\";\nvar taskCancelled = `task-${cancelled}`;\nvar taskCompleted = `task-${completed}`;\nvar listenerCancelled = `${listener}-${cancelled}`;\nvar listenerCompleted = `${listener}-${completed}`;\nvar TaskAbortError = class {\n    constructor(code){\n        this.name = \"TaskAbortError\";\n        this.code = code;\n        this.message = `${task} ${cancelled} (reason: ${code})`;\n    }\n};\n// src/listenerMiddleware/utils.ts\nvar assertFunction = (func, expected)=>{\n    if (typeof func !== \"function\") {\n        throw new Error( false ? 0 : `${expected} is not a function`);\n    }\n};\nvar noop2 = ()=>{};\nvar catchRejection = (promise, onError = noop2)=>{\n    promise.catch(onError);\n    return promise;\n};\nvar addAbortSignalListener = (abortSignal, callback)=>{\n    abortSignal.addEventListener(\"abort\", callback, {\n        once: true\n    });\n    return ()=>abortSignal.removeEventListener(\"abort\", callback);\n};\nvar abortControllerWithReason = (abortController, reason)=>{\n    const signal = abortController.signal;\n    if (signal.aborted) {\n        return;\n    }\n    if (!(\"reason\" in signal)) {\n        Object.defineProperty(signal, \"reason\", {\n            enumerable: true,\n            value: reason,\n            configurable: true,\n            writable: true\n        });\n    }\n    ;\n    abortController.abort(reason);\n};\n// src/listenerMiddleware/task.ts\nvar validateActive = (signal)=>{\n    if (signal.aborted) {\n        const { reason } = signal;\n        throw new TaskAbortError(reason);\n    }\n};\nfunction raceWithSignal(signal, promise) {\n    let cleanup = noop2;\n    return new Promise((resolve, reject)=>{\n        const notifyRejection = ()=>reject(new TaskAbortError(signal.reason));\n        if (signal.aborted) {\n            notifyRejection();\n            return;\n        }\n        cleanup = addAbortSignalListener(signal, notifyRejection);\n        promise.finally(()=>cleanup()).then(resolve, reject);\n    }).finally(()=>{\n        cleanup = noop2;\n    });\n}\nvar runTask = async (task2, cleanUp)=>{\n    try {\n        await Promise.resolve();\n        const value = await task2();\n        return {\n            status: \"ok\",\n            value\n        };\n    } catch (error) {\n        return {\n            status: error instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\n            error\n        };\n    } finally{\n        cleanUp?.();\n    }\n};\nvar createPause = (signal)=>{\n    return (promise)=>{\n        return catchRejection(raceWithSignal(signal, promise).then((output)=>{\n            validateActive(signal);\n            return output;\n        }));\n    };\n};\nvar createDelay = (signal)=>{\n    const pause = createPause(signal);\n    return (timeoutMs)=>{\n        return pause(new Promise((resolve)=>setTimeout(resolve, timeoutMs)));\n    };\n};\n// src/listenerMiddleware/index.ts\nvar { assign } = Object;\nvar INTERNAL_NIL_TOKEN = {};\nvar alm = \"listenerMiddleware\";\nvar createFork = (parentAbortSignal, parentBlockingPromises)=>{\n    const linkControllers = (controller)=>addAbortSignalListener(parentAbortSignal, ()=>abortControllerWithReason(controller, parentAbortSignal.reason));\n    return (taskExecutor, opts)=>{\n        assertFunction(taskExecutor, \"taskExecutor\");\n        const childAbortController = new AbortController();\n        linkControllers(childAbortController);\n        const result = runTask(async ()=>{\n            validateActive(parentAbortSignal);\n            validateActive(childAbortController.signal);\n            const result2 = await taskExecutor({\n                pause: createPause(childAbortController.signal),\n                delay: createDelay(childAbortController.signal),\n                signal: childAbortController.signal\n            });\n            validateActive(childAbortController.signal);\n            return result2;\n        }, ()=>abortControllerWithReason(childAbortController, taskCompleted));\n        if (opts?.autoJoin) {\n            parentBlockingPromises.push(result.catch(noop2));\n        }\n        return {\n            result: createPause(parentAbortSignal)(result),\n            cancel () {\n                abortControllerWithReason(childAbortController, taskCancelled);\n            }\n        };\n    };\n};\nvar createTakePattern = (startListening, signal)=>{\n    const take = async (predicate, timeout)=>{\n        validateActive(signal);\n        let unsubscribe = ()=>{};\n        const tuplePromise = new Promise((resolve, reject)=>{\n            let stopListening = startListening({\n                predicate,\n                effect: (action, listenerApi)=>{\n                    listenerApi.unsubscribe();\n                    resolve([\n                        action,\n                        listenerApi.getState(),\n                        listenerApi.getOriginalState()\n                    ]);\n                }\n            });\n            unsubscribe = ()=>{\n                stopListening();\n                reject();\n            };\n        });\n        const promises = [\n            tuplePromise\n        ];\n        if (timeout != null) {\n            promises.push(new Promise((resolve)=>setTimeout(resolve, timeout, null)));\n        }\n        try {\n            const output = await raceWithSignal(signal, Promise.race(promises));\n            validateActive(signal);\n            return output;\n        } finally{\n            unsubscribe();\n        }\n    };\n    return (predicate, timeout)=>catchRejection(take(predicate, timeout));\n};\nvar getListenerEntryPropsFrom = (options)=>{\n    let { type, actionCreator, matcher, predicate, effect } = options;\n    if (type) {\n        predicate = createAction(type).match;\n    } else if (actionCreator) {\n        type = actionCreator.type;\n        predicate = actionCreator.match;\n    } else if (matcher) {\n        predicate = matcher;\n    } else if (predicate) {} else {\n        throw new Error( false ? 0 : \"Creating or removing a listener requires one of the known fields for matching an action\");\n    }\n    assertFunction(effect, \"options.listener\");\n    return {\n        predicate,\n        type,\n        effect\n    };\n};\nvar createListenerEntry = Object.assign((options)=>{\n    const { type, predicate, effect } = getListenerEntryPropsFrom(options);\n    const id = nanoid();\n    const entry = {\n        id,\n        effect,\n        type,\n        predicate,\n        pending: /* @__PURE__ */ new Set(),\n        unsubscribe: ()=>{\n            throw new Error( false ? 0 : \"Unsubscribe not initialized\");\n        }\n    };\n    return entry;\n}, {\n    withTypes: ()=>createListenerEntry\n});\nvar cancelActiveListeners = (entry)=>{\n    entry.pending.forEach((controller)=>{\n        abortControllerWithReason(controller, listenerCancelled);\n    });\n};\nvar createClearListenerMiddleware = (listenerMap)=>{\n    return ()=>{\n        listenerMap.forEach(cancelActiveListeners);\n        listenerMap.clear();\n    };\n};\nvar safelyNotifyError = (errorHandler, errorToNotify, errorInfo)=>{\n    try {\n        errorHandler(errorToNotify, errorInfo);\n    } catch (errorHandlerError) {\n        setTimeout(()=>{\n            throw errorHandlerError;\n        }, 0);\n    }\n};\nvar addListener = Object.assign(createAction(`${alm}/add`), {\n    withTypes: ()=>addListener\n});\nvar clearAllListeners = createAction(`${alm}/removeAll`);\nvar removeListener = Object.assign(createAction(`${alm}/remove`), {\n    withTypes: ()=>removeListener\n});\nvar defaultErrorHandler = (...args)=>{\n    console.error(`${alm}/error`, ...args);\n};\nvar createListenerMiddleware = (middlewareOptions = {})=>{\n    const listenerMap = /* @__PURE__ */ new Map();\n    const { extra, onError = defaultErrorHandler } = middlewareOptions;\n    assertFunction(onError, \"onError\");\n    const insertEntry = (entry)=>{\n        entry.unsubscribe = ()=>listenerMap.delete(entry.id);\n        listenerMap.set(entry.id, entry);\n        return (cancelOptions)=>{\n            entry.unsubscribe();\n            if (cancelOptions?.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        };\n    };\n    const startListening = (options)=>{\n        let entry = find(Array.from(listenerMap.values()), (existingEntry)=>existingEntry.effect === options.effect);\n        if (!entry) {\n            entry = createListenerEntry(options);\n        }\n        return insertEntry(entry);\n    };\n    Object.assign(startListening, {\n        withTypes: ()=>startListening\n    });\n    const stopListening = (options)=>{\n        const { type, effect, predicate } = getListenerEntryPropsFrom(options);\n        const entry = find(Array.from(listenerMap.values()), (entry2)=>{\n            const matchPredicateOrType = typeof type === \"string\" ? entry2.type === type : entry2.predicate === predicate;\n            return matchPredicateOrType && entry2.effect === effect;\n        });\n        if (entry) {\n            entry.unsubscribe();\n            if (options.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        }\n        return !!entry;\n    };\n    Object.assign(stopListening, {\n        withTypes: ()=>stopListening\n    });\n    const notifyListener = async (entry, action, api, getOriginalState)=>{\n        const internalTaskController = new AbortController();\n        const take = createTakePattern(startListening, internalTaskController.signal);\n        const autoJoinPromises = [];\n        try {\n            entry.pending.add(internalTaskController);\n            await Promise.resolve(entry.effect(action, // Use assign() rather than ... to avoid extra helper functions added to bundle\n            assign({}, api, {\n                getOriginalState,\n                condition: (predicate, timeout)=>take(predicate, timeout).then(Boolean),\n                take,\n                delay: createDelay(internalTaskController.signal),\n                pause: createPause(internalTaskController.signal),\n                extra,\n                signal: internalTaskController.signal,\n                fork: createFork(internalTaskController.signal, autoJoinPromises),\n                unsubscribe: entry.unsubscribe,\n                subscribe: ()=>{\n                    listenerMap.set(entry.id, entry);\n                },\n                cancelActiveListeners: ()=>{\n                    entry.pending.forEach((controller, _, set)=>{\n                        if (controller !== internalTaskController) {\n                            abortControllerWithReason(controller, listenerCancelled);\n                            set.delete(controller);\n                        }\n                    });\n                },\n                cancel: ()=>{\n                    abortControllerWithReason(internalTaskController, listenerCancelled);\n                    entry.pending.delete(internalTaskController);\n                },\n                throwIfCancelled: ()=>{\n                    validateActive(internalTaskController.signal);\n                }\n            })));\n        } catch (listenerError) {\n            if (!(listenerError instanceof TaskAbortError)) {\n                safelyNotifyError(onError, listenerError, {\n                    raisedBy: \"effect\"\n                });\n            }\n        } finally{\n            await Promise.all(autoJoinPromises);\n            abortControllerWithReason(internalTaskController, listenerCompleted);\n            entry.pending.delete(internalTaskController);\n        }\n    };\n    const clearListenerMiddleware = createClearListenerMiddleware(listenerMap);\n    const middleware = (api)=>(next)=>(action)=>{\n                if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n                    return next(action);\n                }\n                if (addListener.match(action)) {\n                    return startListening(action.payload);\n                }\n                if (clearAllListeners.match(action)) {\n                    clearListenerMiddleware();\n                    return;\n                }\n                if (removeListener.match(action)) {\n                    return stopListening(action.payload);\n                }\n                let originalState = api.getState();\n                const getOriginalState = ()=>{\n                    if (originalState === INTERNAL_NIL_TOKEN) {\n                        throw new Error( false ? 0 : `${alm}: getOriginalState can only be called synchronously`);\n                    }\n                    return originalState;\n                };\n                let result;\n                try {\n                    result = next(action);\n                    if (listenerMap.size > 0) {\n                        const currentState = api.getState();\n                        const listenerEntries = Array.from(listenerMap.values());\n                        for (const entry of listenerEntries){\n                            let runListener = false;\n                            try {\n                                runListener = entry.predicate(action, currentState, originalState);\n                            } catch (predicateError) {\n                                runListener = false;\n                                safelyNotifyError(onError, predicateError, {\n                                    raisedBy: \"predicate\"\n                                });\n                            }\n                            if (!runListener) {\n                                continue;\n                            }\n                            notifyListener(entry, action, api, getOriginalState);\n                        }\n                    }\n                } finally{\n                    originalState = INTERNAL_NIL_TOKEN;\n                }\n                return result;\n            };\n    return {\n        middleware,\n        startListening,\n        stopListening,\n        clearListeners: clearListenerMiddleware\n    };\n};\n// src/dynamicMiddleware/index.ts\n\nvar createMiddlewareEntry = (middleware)=>({\n        id: nanoid(),\n        middleware,\n        applied: /* @__PURE__ */ new Map()\n    });\nvar matchInstance = (instanceId)=>(action)=>action?.meta?.instanceId === instanceId;\nvar createDynamicMiddleware = ()=>{\n    const instanceId = nanoid();\n    const middlewareMap = /* @__PURE__ */ new Map();\n    const withMiddleware = Object.assign(createAction(\"dynamicMiddleware/add\", (...middlewares)=>({\n            payload: middlewares,\n            meta: {\n                instanceId\n            }\n        })), {\n        withTypes: ()=>withMiddleware\n    });\n    const addMiddleware = Object.assign(function addMiddleware2(...middlewares) {\n        middlewares.forEach((middleware2)=>{\n            let entry = find(Array.from(middlewareMap.values()), (entry2)=>entry2.middleware === middleware2);\n            if (!entry) {\n                entry = createMiddlewareEntry(middleware2);\n            }\n            middlewareMap.set(entry.id, entry);\n        });\n    }, {\n        withTypes: ()=>addMiddleware\n    });\n    const getFinalMiddleware = (api)=>{\n        const appliedMiddleware = Array.from(middlewareMap.values()).map((entry)=>emplace(entry.applied, api, {\n                insert: ()=>entry.middleware(api)\n            }));\n        return (0,redux__WEBPACK_IMPORTED_MODULE_0__.compose)(...appliedMiddleware);\n    };\n    const isWithMiddleware = isAllOf(withMiddleware, matchInstance(instanceId));\n    const middleware = (api)=>(next)=>(action)=>{\n                if (isWithMiddleware(action)) {\n                    addMiddleware(...action.payload);\n                    return api.dispatch;\n                }\n                return getFinalMiddleware(api)(next)(action);\n            };\n    return {\n        middleware,\n        addMiddleware,\n        withMiddleware,\n        instanceId\n    };\n};\n// src/combineSlices.ts\n\nvar isSliceLike = (maybeSliceLike)=>\"reducerPath\" in maybeSliceLike && typeof maybeSliceLike.reducerPath === \"string\";\nvar getReducers = (slices)=>slices.flatMap((sliceOrMap)=>isSliceLike(sliceOrMap) ? [\n            [\n                sliceOrMap.reducerPath,\n                sliceOrMap.reducer\n            ]\n        ] : Object.entries(sliceOrMap));\nvar ORIGINAL_STATE = Symbol.for(\"rtk-state-proxy-original\");\nvar isStateProxy = (value)=>!!value && !!value[ORIGINAL_STATE];\nvar stateProxyMap = /* @__PURE__ */ new WeakMap();\nvar createStateProxy = (state, reducerMap)=>emplace(stateProxyMap, state, {\n        insert: ()=>new Proxy(state, {\n                get: (target, prop, receiver)=>{\n                    if (prop === ORIGINAL_STATE) return target;\n                    const result = Reflect.get(target, prop, receiver);\n                    if (typeof result === \"undefined\") {\n                        const reducer = reducerMap[prop.toString()];\n                        if (reducer) {\n                            const reducerResult = reducer(void 0, {\n                                type: nanoid()\n                            });\n                            if (typeof reducerResult === \"undefined\") {\n                                throw new Error( false ? 0 : `The slice reducer for key \"${prop.toString()}\" returned undefined when called for selector(). If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);\n                            }\n                            return reducerResult;\n                        }\n                    }\n                    return result;\n                }\n            })\n    });\nvar original = (state)=>{\n    if (!isStateProxy(state)) {\n        throw new Error( false ? 0 : \"original must be used on state Proxy\");\n    }\n    return state[ORIGINAL_STATE];\n};\nvar noopReducer = (state = {})=>state;\nfunction combineSlices(...slices) {\n    const reducerMap = Object.fromEntries(getReducers(slices));\n    const getReducer = ()=>Object.keys(reducerMap).length ? (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducerMap) : noopReducer;\n    let reducer = getReducer();\n    function combinedReducer(state, action) {\n        return reducer(state, action);\n    }\n    combinedReducer.withLazyLoadedSlices = ()=>combinedReducer;\n    const inject = (slice, config = {})=>{\n        const { reducerPath, reducer: reducerToInject } = slice;\n        const currentReducer = reducerMap[reducerPath];\n        if (!config.overrideExisting && currentReducer && currentReducer !== reducerToInject) {\n            if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n                console.error(`called \\`inject\\` to override already-existing reducer ${reducerPath} without specifying \\`overrideExisting: true\\``);\n            }\n            return combinedReducer;\n        }\n        reducerMap[reducerPath] = reducerToInject;\n        reducer = getReducer();\n        return combinedReducer;\n    };\n    const selector = Object.assign(function makeSelector(selectorFn, selectState) {\n        return function selector2(state, ...args) {\n            return selectorFn(createStateProxy(selectState ? selectState(state, ...args) : state, reducerMap), ...args);\n        };\n    }, {\n        original\n    });\n    return Object.assign(combinedReducer, {\n        inject,\n        selector\n    });\n}\n// src/formatProdErrorMessage.ts\nfunction formatProdErrorMessage(code) {\n    return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;\n}\n //# sourceMappingURL=redux-toolkit.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3JlZHV4LXRvb2xraXQubW9kZXJuLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxlQUFlO0FBQ087QUFDbUY7QUFDaUM7QUFFMUksaUNBQWlDO0FBQ1E7QUFDd0I7QUFDakUsSUFBSWMsaUNBQWlDLENBQUMsR0FBR0M7SUFDdkMsTUFBTUMsa0JBQWtCUCwrREFBcUJBLElBQUlNO0lBQ2pELE1BQU1FLDJCQUEyQkMsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR0M7UUFDakQsTUFBTUMsV0FBV0wsbUJBQW1CSTtRQUNwQyxNQUFNRSxrQkFBa0IsQ0FBQ0MsT0FBTyxHQUFHQyxPQUFTSCxTQUFTZiw4Q0FBT0EsQ0FBQ2lCLFNBQVN0Qiw4Q0FBT0EsQ0FBQ3NCLFNBQVNBLFVBQVVDO1FBQ2pHTixPQUFPQyxNQUFNLENBQUNHLGlCQUFpQkQ7UUFDL0IsT0FBT0M7SUFDVCxHQUFHO1FBQ0RHLFdBQVcsSUFBTVI7SUFDbkI7SUFDQSxPQUFPQTtBQUNUO0FBQ0EsSUFBSVMsMEJBQTBCWiwrQkFBK0JGLG9EQUFjQTtBQUUzRSx3QkFBd0I7QUFDb0c7QUFFNUgsMkJBQTJCO0FBQ0s7QUFDaEMsSUFBSXNCLHNCQUFzQixNQUE0RSxHQUFHQyxDQUEyQyxHQUFHO0lBQ3JKLElBQUlFLFVBQVVDLE1BQU0sS0FBSyxHQUN2QixPQUFPLEtBQUs7SUFDZCxJQUFJLE9BQU9ELFNBQVMsQ0FBQyxFQUFFLEtBQUssVUFDMUIsT0FBT1IsMENBQU9BO0lBQ2hCLE9BQU9BLDBDQUFPQSxDQUFDVSxLQUFLLENBQUMsTUFBTUY7QUFDN0I7QUFDQSxJQUFJRyxtQkFBbUIsTUFBb0UsR0FBR0wsQ0FBbUMsR0FBRztJQUNsSSxPQUFPLFNBQVNPLEtBQUs7UUFDbkIsT0FBT0E7SUFDVDtBQUNGO0FBRUEsOEJBQThC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d2VicGFjazovL3dvcmtmbG93Ly4vbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvZGlzdC9yZWR1eC10b29sa2l0Lm1vZGVybi5tanM/YWQzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJyZWR1eFwiO1xuaW1wb3J0IHsgcHJvZHVjZSwgY3VycmVudCBhcyBjdXJyZW50MiwgZnJlZXplLCBvcmlnaW5hbCBhcyBvcmlnaW5hbDIsIGlzRHJhZnQgYXMgaXNEcmFmdDQgfSBmcm9tIFwiaW1tZXJcIjtcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yLCBjcmVhdGVTZWxlY3RvckNyZWF0b3IgYXMgY3JlYXRlU2VsZWN0b3JDcmVhdG9yMiwgbHJ1TWVtb2l6ZSwgd2Vha01hcE1lbW9pemUgYXMgd2Vha01hcE1lbW9pemUyIH0gZnJvbSBcInJlc2VsZWN0XCI7XG5cbi8vIHNyYy9jcmVhdGVEcmFmdFNhZmVTZWxlY3Rvci50c1xuaW1wb3J0IHsgY3VycmVudCwgaXNEcmFmdCB9IGZyb20gXCJpbW1lclwiO1xuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JDcmVhdG9yLCB3ZWFrTWFwTWVtb2l6ZSB9IGZyb20gXCJyZXNlbGVjdFwiO1xudmFyIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvciA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IGNyZWF0ZVNlbGVjdG9yMiA9IGNyZWF0ZVNlbGVjdG9yQ3JlYXRvciguLi5hcmdzKTtcbiAgY29uc3QgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyID0gT2JqZWN0LmFzc2lnbigoLi4uYXJnczIpID0+IHtcbiAgICBjb25zdCBzZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yMiguLi5hcmdzMik7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gKHZhbHVlLCAuLi5yZXN0KSA9PiBzZWxlY3Rvcihpc0RyYWZ0KHZhbHVlKSA/IGN1cnJlbnQodmFsdWUpIDogdmFsdWUsIC4uLnJlc3QpO1xuICAgIE9iamVjdC5hc3NpZ24od3JhcHBlZFNlbGVjdG9yLCBzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHdyYXBwZWRTZWxlY3RvcjtcbiAgfSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyXG4gIH0pO1xuICByZXR1cm4gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyO1xufTtcbnZhciBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvcih3ZWFrTWFwTWVtb2l6ZSk7XG5cbi8vIHNyYy9jb25maWd1cmVTdG9yZS50c1xuaW1wb3J0IHsgYXBwbHlNaWRkbGV3YXJlLCBjcmVhdGVTdG9yZSwgY29tcG9zZSBhcyBjb21wb3NlMiwgY29tYmluZVJlZHVjZXJzLCBpc1BsYWluT2JqZWN0IGFzIGlzUGxhaW5PYmplY3QyIH0gZnJvbSBcInJlZHV4XCI7XG5cbi8vIHNyYy9kZXZ0b29sc0V4dGVuc2lvbi50c1xuaW1wb3J0IHsgY29tcG9zZSB9IGZyb20gXCJyZWR1eFwiO1xudmFyIGNvbXBvc2VXaXRoRGV2VG9vbHMgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIDogZnVuY3Rpb24oKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBjb21wb3NlO1xuICByZXR1cm4gY29tcG9zZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcbnZhciBkZXZUb29sc0VuaGFuY2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyA/IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fIDogZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmdW5jdGlvbihub29wMykge1xuICAgIHJldHVybiBub29wMztcbiAgfTtcbn07XG5cbi8vIHNyYy9nZXREZWZhdWx0TWlkZGxld2FyZS50c1xuaW1wb3J0IHsgdGh1bmsgYXMgdGh1bmtNaWRkbGV3YXJlLCB3aXRoRXh0cmFBcmd1bWVudCB9IGZyb20gXCJyZWR1eC10aHVua1wiO1xuXG4vLyBzcmMvY3JlYXRlQWN0aW9uLnRzXG5pbXBvcnQgeyBpc0FjdGlvbiB9IGZyb20gXCJyZWR1eFwiO1xuXG4vLyBzcmMvdHNIZWxwZXJzLnRzXG52YXIgaGFzTWF0Y2hGdW5jdGlvbiA9ICh2KSA9PiB7XG4gIHJldHVybiB2ICYmIHR5cGVvZiB2Lm1hdGNoID09PSBcImZ1bmN0aW9uXCI7XG59O1xuXG4vLyBzcmMvY3JlYXRlQWN0aW9uLnRzXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb24odHlwZSwgcHJlcGFyZUFjdGlvbikge1xuICBmdW5jdGlvbiBhY3Rpb25DcmVhdG9yKC4uLmFyZ3MpIHtcbiAgICBpZiAocHJlcGFyZUFjdGlvbikge1xuICAgICAgbGV0IHByZXBhcmVkID0gcHJlcGFyZUFjdGlvbiguLi5hcmdzKTtcbiAgICAgIGlmICghcHJlcGFyZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMCkgOiBcInByZXBhcmVBY3Rpb24gZGlkIG5vdCByZXR1cm4gYW4gb2JqZWN0XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcGF5bG9hZDogcHJlcGFyZWQucGF5bG9hZCxcbiAgICAgICAgLi4uXCJtZXRhXCIgaW4gcHJlcGFyZWQgJiYge1xuICAgICAgICAgIG1ldGE6IHByZXBhcmVkLm1ldGFcbiAgICAgICAgfSxcbiAgICAgICAgLi4uXCJlcnJvclwiIGluIHByZXBhcmVkICYmIHtcbiAgICAgICAgICBlcnJvcjogcHJlcGFyZWQuZXJyb3JcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGUsXG4gICAgICBwYXlsb2FkOiBhcmdzWzBdXG4gICAgfTtcbiAgfVxuICBhY3Rpb25DcmVhdG9yLnRvU3RyaW5nID0gKCkgPT4gYCR7dHlwZX1gO1xuICBhY3Rpb25DcmVhdG9yLnR5cGUgPSB0eXBlO1xuICBhY3Rpb25DcmVhdG9yLm1hdGNoID0gKGFjdGlvbikgPT4gaXNBY3Rpb24oYWN0aW9uKSAmJiBhY3Rpb24udHlwZSA9PT0gdHlwZTtcbiAgcmV0dXJuIGFjdGlvbkNyZWF0b3I7XG59XG5mdW5jdGlvbiBpc0FjdGlvbkNyZWF0b3IoYWN0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSBcImZ1bmN0aW9uXCIgJiYgXCJ0eXBlXCIgaW4gYWN0aW9uICYmIC8vIGhhc01hdGNoRnVuY3Rpb24gb25seSB3YW50cyBNYXRjaGVycyBidXQgSSBkb24ndCBzZWUgdGhlIHBvaW50IGluIHJld3JpdGluZyBpdFxuICBoYXNNYXRjaEZ1bmN0aW9uKGFjdGlvbik7XG59XG5mdW5jdGlvbiBpc0ZTQShhY3Rpb24pIHtcbiAgcmV0dXJuIGlzQWN0aW9uKGFjdGlvbikgJiYgT2JqZWN0LmtleXMoYWN0aW9uKS5ldmVyeShpc1ZhbGlkS2V5KTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XG4gIHJldHVybiBbXCJ0eXBlXCIsIFwicGF5bG9hZFwiLCBcImVycm9yXCIsIFwibWV0YVwiXS5pbmRleE9mKGtleSkgPiAtMTtcbn1cblxuLy8gc3JjL2FjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBnZXRNZXNzYWdlKHR5cGUpIHtcbiAgY29uc3Qgc3BsaXRUeXBlID0gdHlwZSA/IGAke3R5cGV9YC5zcGxpdChcIi9cIikgOiBbXTtcbiAgY29uc3QgYWN0aW9uTmFtZSA9IHNwbGl0VHlwZVtzcGxpdFR5cGUubGVuZ3RoIC0gMV0gfHwgXCJhY3Rpb25DcmVhdG9yXCI7XG4gIHJldHVybiBgRGV0ZWN0ZWQgYW4gYWN0aW9uIGNyZWF0b3Igd2l0aCB0eXBlIFwiJHt0eXBlIHx8IFwidW5rbm93blwifVwiIGJlaW5nIGRpc3BhdGNoZWQuIFxuTWFrZSBzdXJlIHlvdSdyZSBjYWxsaW5nIHRoZSBhY3Rpb24gY3JlYXRvciBiZWZvcmUgZGlzcGF0Y2hpbmcsIGkuZS4gXFxgZGlzcGF0Y2goJHthY3Rpb25OYW1lfSgpKVxcYCBpbnN0ZWFkIG9mIFxcYGRpc3BhdGNoKCR7YWN0aW9uTmFtZX0pXFxgLiBUaGlzIGlzIG5lY2Vzc2FyeSBldmVuIGlmIHRoZSBhY3Rpb24gaGFzIG5vIHBheWxvYWQuYDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiBuZXh0KGFjdGlvbik7XG4gIH1cbiAgY29uc3Qge1xuICAgIGlzQWN0aW9uQ3JlYXRvcjogaXNBY3Rpb25DcmVhdG9yMiA9IGlzQWN0aW9uQ3JlYXRvclxuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgaWYgKGlzQWN0aW9uQ3JlYXRvcjIoYWN0aW9uKSkge1xuICAgICAgY29uc29sZS53YXJuKGdldE1lc3NhZ2UoYWN0aW9uLnR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzLnRzXG5pbXBvcnQgeyBwcm9kdWNlIGFzIGNyZWF0ZU5leHRTdGF0ZSwgaXNEcmFmdGFibGUgfSBmcm9tIFwiaW1tZXJcIjtcbmZ1bmN0aW9uIGdldFRpbWVNZWFzdXJlVXRpbHMobWF4RGVsYXksIGZuTmFtZSkge1xuICBsZXQgZWxhcHNlZCA9IDA7XG4gIHJldHVybiB7XG4gICAgbWVhc3VyZVRpbWUoZm4pIHtcbiAgICAgIGNvbnN0IHN0YXJ0ZWQgPSBEYXRlLm5vdygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb25zdCBmaW5pc2hlZCA9IERhdGUubm93KCk7XG4gICAgICAgIGVsYXBzZWQgKz0gZmluaXNoZWQgLSBzdGFydGVkO1xuICAgICAgfVxuICAgIH0sXG4gICAgd2FybklmRXhjZWVkZWQoKSB7XG4gICAgICBpZiAoZWxhcHNlZCA+IG1heERlbGF5KSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgJHtmbk5hbWV9IHRvb2sgJHtlbGFwc2VkfW1zLCB3aGljaCBpcyBtb3JlIHRoYW4gdGhlIHdhcm5pbmcgdGhyZXNob2xkIG9mICR7bWF4RGVsYXl9bXMuIFxuSWYgeW91ciBzdGF0ZSBvciBhY3Rpb25zIGFyZSB2ZXJ5IGxhcmdlLCB5b3UgbWF5IHdhbnQgdG8gZGlzYWJsZSB0aGUgbWlkZGxld2FyZSBhcyBpdCBtaWdodCBjYXVzZSB0b28gbXVjaCBvZiBhIHNsb3dkb3duIGluIGRldmVsb3BtZW50IG1vZGUuIFNlZSBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9nZXREZWZhdWx0TWlkZGxld2FyZSBmb3IgaW5zdHJ1Y3Rpb25zLlxuSXQgaXMgZGlzYWJsZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMsIHNvIHlvdSBkb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoYXQuYCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZmluZChpdGVyYWJsZSwgY29tcGFyYXRvcikge1xuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGl0ZXJhYmxlKSB7XG4gICAgaWYgKGNvbXBhcmF0b3IoZW50cnkpKSB7XG4gICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG52YXIgVHVwbGUgPSBjbGFzcyBfVHVwbGUgZXh0ZW5kcyBBcnJheSB7XG4gIGNvbnN0cnVjdG9yKC4uLml0ZW1zKSB7XG4gICAgc3VwZXIoLi4uaXRlbXMpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBfVHVwbGUucHJvdG90eXBlKTtcbiAgfVxuICBzdGF0aWMgZ2V0IFtTeW1ib2wuc3BlY2llc10oKSB7XG4gICAgcmV0dXJuIF9UdXBsZTtcbiAgfVxuICBjb25jYXQoLi4uYXJyKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvbmNhdC5hcHBseSh0aGlzLCBhcnIpO1xuICB9XG4gIHByZXBlbmQoLi4uYXJyKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcnJbMF0pKSB7XG4gICAgICByZXR1cm4gbmV3IF9UdXBsZSguLi5hcnJbMF0uY29uY2F0KHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfVHVwbGUoLi4uYXJyLmNvbmNhdCh0aGlzKSk7XG4gIH1cbn07XG5mdW5jdGlvbiBmcmVlemVEcmFmdGFibGUodmFsKSB7XG4gIHJldHVybiBpc0RyYWZ0YWJsZSh2YWwpID8gY3JlYXRlTmV4dFN0YXRlKHZhbCwgKCkgPT4ge1xuICB9KSA6IHZhbDtcbn1cbmZ1bmN0aW9uIGVtcGxhY2UobWFwLCBrZXksIGhhbmRsZXIpIHtcbiAgaWYgKG1hcC5oYXMoa2V5KSkge1xuICAgIGxldCB2YWx1ZSA9IG1hcC5nZXQoa2V5KTtcbiAgICBpZiAoaGFuZGxlci51cGRhdGUpIHtcbiAgICAgIHZhbHVlID0gaGFuZGxlci51cGRhdGUodmFsdWUsIGtleSwgbWFwKTtcbiAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoIWhhbmRsZXIuaW5zZXJ0KVxuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEwKSA6IFwiTm8gaW5zZXJ0IHByb3ZpZGVkIGZvciBrZXkgbm90IGFscmVhZHkgaW4gbWFwXCIpO1xuICBjb25zdCBpbnNlcnRlZCA9IGhhbmRsZXIuaW5zZXJ0KGtleSwgbWFwKTtcbiAgbWFwLnNldChrZXksIGluc2VydGVkKTtcbiAgcmV0dXJuIGluc2VydGVkO1xufVxuXG4vLyBzcmMvaW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBpc0ltbXV0YWJsZURlZmF1bHQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PSBudWxsIHx8IE9iamVjdC5pc0Zyb3plbih2YWx1ZSk7XG59XG5mdW5jdGlvbiB0cmFja0Zvck11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9iaikge1xuICBjb25zdCB0cmFja2VkUHJvcGVydGllcyA9IHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9iaik7XG4gIHJldHVybiB7XG4gICAgZGV0ZWN0TXV0YXRpb25zKCkge1xuICAgICAgcmV0dXJuIGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIHRyYWNrZWRQcm9wZXJ0aWVzLCBvYmopO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMgPSBbXSwgb2JqLCBwYXRoID0gXCJcIiwgY2hlY2tlZE9iamVjdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSB7XG4gIGNvbnN0IHRyYWNrZWQgPSB7XG4gICAgdmFsdWU6IG9ialxuICB9O1xuICBpZiAoIWlzSW1tdXRhYmxlKG9iaikgJiYgIWNoZWNrZWRPYmplY3RzLmhhcyhvYmopKSB7XG4gICAgY2hlY2tlZE9iamVjdHMuYWRkKG9iaik7XG4gICAgdHJhY2tlZC5jaGlsZHJlbiA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcbiAgICAgIGlmIChpZ25vcmVQYXRocy5sZW5ndGggJiYgaWdub3JlUGF0aHMuaW5kZXhPZihjaGlsZFBhdGgpICE9PSAtMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRyYWNrZWQuY2hpbGRyZW5ba2V5XSA9IHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9ialtrZXldLCBjaGlsZFBhdGgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJhY2tlZDtcbn1cbmZ1bmN0aW9uIGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzID0gW10sIHRyYWNrZWRQcm9wZXJ0eSwgb2JqLCBzYW1lUGFyZW50UmVmID0gZmFsc2UsIHBhdGggPSBcIlwiKSB7XG4gIGNvbnN0IHByZXZPYmogPSB0cmFja2VkUHJvcGVydHkgPyB0cmFja2VkUHJvcGVydHkudmFsdWUgOiB2b2lkIDA7XG4gIGNvbnN0IHNhbWVSZWYgPSBwcmV2T2JqID09PSBvYmo7XG4gIGlmIChzYW1lUGFyZW50UmVmICYmICFzYW1lUmVmICYmICFOdW1iZXIuaXNOYU4ob2JqKSkge1xuICAgIHJldHVybiB7XG4gICAgICB3YXNNdXRhdGVkOiB0cnVlLFxuICAgICAgcGF0aFxuICAgIH07XG4gIH1cbiAgaWYgKGlzSW1tdXRhYmxlKHByZXZPYmopIHx8IGlzSW1tdXRhYmxlKG9iaikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2FzTXV0YXRlZDogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNvbnN0IGtleXNUb0RldGVjdCA9IHt9O1xuICBmb3IgKGxldCBrZXkgaW4gdHJhY2tlZFByb3BlcnR5LmNoaWxkcmVuKSB7XG4gICAga2V5c1RvRGV0ZWN0W2tleV0gPSB0cnVlO1xuICB9XG4gIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICBrZXlzVG9EZXRlY3Rba2V5XSA9IHRydWU7XG4gIH1cbiAgY29uc3QgaGFzSWdub3JlZFBhdGhzID0gaWdub3JlZFBhdGhzLmxlbmd0aCA+IDA7XG4gIGZvciAobGV0IGtleSBpbiBrZXlzVG9EZXRlY3QpIHtcbiAgICBjb25zdCBuZXN0ZWRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcbiAgICBpZiAoaGFzSWdub3JlZFBhdGhzKSB7XG4gICAgICBjb25zdCBoYXNNYXRjaGVzID0gaWdub3JlZFBhdGhzLnNvbWUoKGlnbm9yZWQpID0+IHtcbiAgICAgICAgaWYgKGlnbm9yZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICByZXR1cm4gaWdub3JlZC50ZXN0KG5lc3RlZFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXN0ZWRQYXRoID09PSBpZ25vcmVkO1xuICAgICAgfSk7XG4gICAgICBpZiAoaGFzTWF0Y2hlcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMsIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbltrZXldLCBvYmpba2V5XSwgc2FtZVJlZiwgbmVzdGVkUGF0aCk7XG4gICAgaWYgKHJlc3VsdC53YXNNdXRhdGVkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdhc011dGF0ZWQ6IGZhbHNlXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUob3B0aW9ucyA9IHt9KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICByZXR1cm4gKCkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IG5leHQoYWN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgc3RyaW5naWZ5MiA9IGZ1bmN0aW9uKG9iaiwgc2VyaWFsaXplciwgaW5kZW50LCBkZWN5Y2xlcikge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgZ2V0U2VyaWFsaXplMihzZXJpYWxpemVyLCBkZWN5Y2xlciksIGluZGVudCk7XG4gICAgfSwgZ2V0U2VyaWFsaXplMiA9IGZ1bmN0aW9uKHNlcmlhbGl6ZXIsIGRlY3ljbGVyKSB7XG4gICAgICBsZXQgc3RhY2sgPSBbXSwga2V5cyA9IFtdO1xuICAgICAgaWYgKCFkZWN5Y2xlcilcbiAgICAgICAgZGVjeWNsZXIgPSBmdW5jdGlvbihfLCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChzdGFja1swXSA9PT0gdmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXIgfl1cIjtcbiAgICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXIgfi5cIiArIGtleXMuc2xpY2UoMCwgc3RhY2suaW5kZXhPZih2YWx1ZSkpLmpvaW4oXCIuXCIpICsgXCJdXCI7XG4gICAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICB+dGhpc1BvcyA/IHN0YWNrLnNwbGljZSh0aGlzUG9zICsgMSkgOiBzdGFjay5wdXNoKHRoaXMpO1xuICAgICAgICAgIH50aGlzUG9zID8ga2V5cy5zcGxpY2UodGhpc1BvcywgSW5maW5pdHksIGtleSkgOiBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKVxuICAgICAgICAgICAgdmFsdWUgPSBkZWN5Y2xlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZXIgPT0gbnVsbCA/IHZhbHVlIDogc2VyaWFsaXplci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBzdHJpbmdpZnkgPSBzdHJpbmdpZnkyLCBnZXRTZXJpYWxpemUgPSBnZXRTZXJpYWxpemUyO1xuICAgIGxldCB7XG4gICAgICBpc0ltbXV0YWJsZSA9IGlzSW1tdXRhYmxlRGVmYXVsdCxcbiAgICAgIGlnbm9yZWRQYXRocyxcbiAgICAgIHdhcm5BZnRlciA9IDMyXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdHJhY2sgPSB0cmFja0Zvck11dGF0aW9ucy5iaW5kKG51bGwsIGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMpO1xuICAgIHJldHVybiAoe1xuICAgICAgZ2V0U3RhdGVcbiAgICB9KSA9PiB7XG4gICAgICBsZXQgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgbGV0IHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgcmV0dXJuIChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVVdGlscyA9IGdldFRpbWVNZWFzdXJlVXRpbHMod2FybkFmdGVyLCBcIkltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZVwiKTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICAgICAgcmVzdWx0ID0gdHJhY2tlci5kZXRlY3RNdXRhdGlvbnMoKTtcbiAgICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTkpIDogYEEgc3RhdGUgbXV0YXRpb24gd2FzIGRldGVjdGVkIGJldHdlZW4gZGlzcGF0Y2hlcywgaW4gdGhlIHBhdGggJyR7cmVzdWx0LnBhdGggfHwgXCJcIn0nLiAgVGhpcyBtYXkgY2F1c2UgaW5jb3JyZWN0IGJlaGF2aW9yLiAoaHR0cHM6Ly9yZWR1eC5qcy5vcmcvc3R5bGUtZ3VpZGUvc3R5bGUtZ3VpZGUjZG8tbm90LW11dGF0ZS1zdGF0ZSlgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkaXNwYXRjaGVkQWN0aW9uID0gbmV4dChhY3Rpb24pO1xuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xuICAgICAgICAgIHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgICAgICByZXN1bHQgPSB0cmFja2VyLmRldGVjdE11dGF0aW9ucygpO1xuICAgICAgICAgIHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC53YXNNdXRhdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyMCkgOiBgQSBzdGF0ZSBtdXRhdGlvbiB3YXMgZGV0ZWN0ZWQgaW5zaWRlIGEgZGlzcGF0Y2gsIGluIHRoZSBwYXRoOiAke3Jlc3VsdC5wYXRoIHx8IFwiXCJ9LiBUYWtlIGEgbG9vayBhdCB0aGUgcmVkdWNlcihzKSBoYW5kbGluZyB0aGUgYWN0aW9uICR7c3RyaW5naWZ5MihhY3Rpb24pfS4gKGh0dHBzOi8vcmVkdXguanMub3JnL3N0eWxlLWd1aWRlL3N0eWxlLWd1aWRlI2RvLW5vdC1tdXRhdGUtc3RhdGUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLndhcm5JZkV4Y2VlZGVkKCk7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaGVkQWN0aW9uO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9zZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcbmltcG9ydCB7IGlzQWN0aW9uIGFzIGlzQWN0aW9uMiwgaXNQbGFpbk9iamVjdCB9IGZyb20gXCJyZWR1eFwiO1xuZnVuY3Rpb24gaXNQbGFpbih2YWwpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWwpIHx8IGlzUGxhaW5PYmplY3QodmFsKTtcbn1cbmZ1bmN0aW9uIGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSh2YWx1ZSwgcGF0aCA9IFwiXCIsIGlzU2VyaWFsaXphYmxlID0gaXNQbGFpbiwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzID0gW10sIGNhY2hlKSB7XG4gIGxldCBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZTtcbiAgaWYgKCFpc1NlcmlhbGl6YWJsZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5UGF0aDogcGF0aCB8fCBcIjxyb290PlwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNhY2hlPy5oYXModmFsdWUpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgZW50cmllcyA9IGdldEVudHJpZXMgIT0gbnVsbCA/IGdldEVudHJpZXModmFsdWUpIDogT2JqZWN0LmVudHJpZXModmFsdWUpO1xuICBjb25zdCBoYXNJZ25vcmVkUGF0aHMgPSBpZ25vcmVkUGF0aHMubGVuZ3RoID4gMDtcbiAgZm9yIChjb25zdCBba2V5LCBuZXN0ZWRWYWx1ZV0gb2YgZW50cmllcykge1xuICAgIGNvbnN0IG5lc3RlZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xuICAgIGlmIChoYXNJZ25vcmVkUGF0aHMpIHtcbiAgICAgIGNvbnN0IGhhc01hdGNoZXMgPSBpZ25vcmVkUGF0aHMuc29tZSgoaWdub3JlZCkgPT4ge1xuICAgICAgICBpZiAoaWdub3JlZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgIHJldHVybiBpZ25vcmVkLnRlc3QobmVzdGVkUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5lc3RlZFBhdGggPT09IGlnbm9yZWQ7XG4gICAgICB9KTtcbiAgICAgIGlmIChoYXNNYXRjaGVzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzU2VyaWFsaXphYmxlKG5lc3RlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5UGF0aDogbmVzdGVkUGF0aCxcbiAgICAgICAgdmFsdWU6IG5lc3RlZFZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShuZXN0ZWRWYWx1ZSwgbmVzdGVkUGF0aCwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRQYXRocywgY2FjaGUpO1xuICAgICAgaWYgKGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlKSB7XG4gICAgICAgIHJldHVybiBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGNhY2hlICYmIGlzTmVzdGVkRnJvemVuKHZhbHVlKSlcbiAgICBjYWNoZS5hZGQodmFsdWUpO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc05lc3RlZEZyb3plbih2YWx1ZSkge1xuICBpZiAoIU9iamVjdC5pc0Zyb3plbih2YWx1ZSkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGNvbnN0IG5lc3RlZFZhbHVlIG9mIE9iamVjdC52YWx1ZXModmFsdWUpKSB7XG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSAhPT0gXCJvYmplY3RcIiB8fCBuZXN0ZWRWYWx1ZSA9PT0gbnVsbClcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmICghaXNOZXN0ZWRGcm96ZW4obmVzdGVkVmFsdWUpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiBuZXh0KGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNTZXJpYWxpemFibGUgPSBpc1BsYWluLFxuICAgICAgZ2V0RW50cmllcyxcbiAgICAgIGlnbm9yZWRBY3Rpb25zID0gW10sXG4gICAgICBpZ25vcmVkQWN0aW9uUGF0aHMgPSBbXCJtZXRhLmFyZ1wiLCBcIm1ldGEuYmFzZVF1ZXJ5TWV0YVwiXSxcbiAgICAgIGlnbm9yZWRQYXRocyA9IFtdLFxuICAgICAgd2FybkFmdGVyID0gMzIsXG4gICAgICBpZ25vcmVTdGF0ZSA9IGZhbHNlLFxuICAgICAgaWdub3JlQWN0aW9ucyA9IGZhbHNlLFxuICAgICAgZGlzYWJsZUNhY2hlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBjYWNoZSA9ICFkaXNhYmxlQ2FjaGUgJiYgV2Vha1NldCA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpIDogdm9pZCAwO1xuICAgIHJldHVybiAoc3RvcmVBUEkpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoIWlzQWN0aW9uMihhY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBuZXh0KGFjdGlvbik7XG4gICAgICBjb25zdCBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XG4gICAgICBpZiAoIWlnbm9yZUFjdGlvbnMgJiYgIShpZ25vcmVkQWN0aW9ucy5sZW5ndGggJiYgaWdub3JlZEFjdGlvbnMuaW5kZXhPZihhY3Rpb24udHlwZSkgIT09IC0xKSkge1xuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoYWN0aW9uLCBcIlwiLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZEFjdGlvblBhdGhzLCBjYWNoZSk7XG4gICAgICAgICAgaWYgKGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0gPSBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQSBub24tc2VyaWFsaXphYmxlIHZhbHVlIHdhcyBkZXRlY3RlZCBpbiBhbiBhY3Rpb24sIGluIHRoZSBwYXRoOiBcXGAke2tleVBhdGh9XFxgLiBWYWx1ZTpgLCB2YWx1ZSwgXCJcXG5UYWtlIGEgbG9vayBhdCB0aGUgbG9naWMgdGhhdCBkaXNwYXRjaGVkIHRoaXMgYWN0aW9uOiBcIiwgYWN0aW9uLCBcIlxcbihTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvZmFxL2FjdGlvbnMjd2h5LXNob3VsZC10eXBlLWJlLWEtc3RyaW5nLW9yLWF0LWxlYXN0LXNlcmlhbGl6YWJsZS13aHktc2hvdWxkLW15LWFjdGlvbi10eXBlcy1iZS1jb25zdGFudHMpXCIsIFwiXFxuKFRvIGFsbG93IG5vbi1zZXJpYWxpemFibGUgdmFsdWVzIHNlZTogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy91c2FnZS91c2FnZS1ndWlkZSN3b3JraW5nLXdpdGgtbm9uLXNlcmlhbGl6YWJsZS1kYXRhKVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFpZ25vcmVTdGF0ZSkge1xuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RvcmVBUEkuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBjb25zdCBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoc3RhdGUsIFwiXCIsIGlzU2VyaWFsaXphYmxlLCBnZXRFbnRyaWVzLCBpZ25vcmVkUGF0aHMsIGNhY2hlKTtcbiAgICAgICAgICBpZiAoZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9ID0gZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQSBub24tc2VyaWFsaXphYmxlIHZhbHVlIHdhcyBkZXRlY3RlZCBpbiB0aGUgc3RhdGUsIGluIHRoZSBwYXRoOiBcXGAke2tleVBhdGh9XFxgLiBWYWx1ZTpgLCB2YWx1ZSwgYFxuVGFrZSBhIGxvb2sgYXQgdGhlIHJlZHVjZXIocykgaGFuZGxpbmcgdGhpcyBhY3Rpb24gdHlwZTogJHthY3Rpb24udHlwZX0uXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9vcmdhbml6aW5nLXN0YXRlI2Nhbi1pLXB1dC1mdW5jdGlvbnMtcHJvbWlzZXMtb3Itb3RoZXItbm9uLXNlcmlhbGl6YWJsZS1pdGVtcy1pbi1teS1zdG9yZS1zdGF0ZSlgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZWFzdXJlVXRpbHMud2FybklmRXhjZWVkZWQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvZ2V0RGVmYXVsdE1pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGlzQm9vbGVhbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJib29sZWFuXCI7XG59XG52YXIgYnVpbGRHZXREZWZhdWx0TWlkZGxld2FyZSA9ICgpID0+IGZ1bmN0aW9uIGdldERlZmF1bHRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHRodW5rID0gdHJ1ZSxcbiAgICBpbW11dGFibGVDaGVjayA9IHRydWUsXG4gICAgc2VyaWFsaXphYmxlQ2hlY2sgPSB0cnVlLFxuICAgIGFjdGlvbkNyZWF0b3JDaGVjayA9IHRydWVcbiAgfSA9IG9wdGlvbnMgPz8ge307XG4gIGxldCBtaWRkbGV3YXJlQXJyYXkgPSBuZXcgVHVwbGUoKTtcbiAgaWYgKHRodW5rKSB7XG4gICAgaWYgKGlzQm9vbGVhbih0aHVuaykpIHtcbiAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKHRodW5rTWlkZGxld2FyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKHdpdGhFeHRyYUFyZ3VtZW50KHRodW5rLmV4dHJhQXJndW1lbnQpKTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChpbW11dGFibGVDaGVjaykge1xuICAgICAgbGV0IGltbXV0YWJsZU9wdGlvbnMgPSB7fTtcbiAgICAgIGlmICghaXNCb29sZWFuKGltbXV0YWJsZUNoZWNrKSkge1xuICAgICAgICBpbW11dGFibGVPcHRpb25zID0gaW1tdXRhYmxlQ2hlY2s7XG4gICAgICB9XG4gICAgICBtaWRkbGV3YXJlQXJyYXkudW5zaGlmdChjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUoaW1tdXRhYmxlT3B0aW9ucykpO1xuICAgIH1cbiAgICBpZiAoc2VyaWFsaXphYmxlQ2hlY2spIHtcbiAgICAgIGxldCBzZXJpYWxpemFibGVPcHRpb25zID0ge307XG4gICAgICBpZiAoIWlzQm9vbGVhbihzZXJpYWxpemFibGVDaGVjaykpIHtcbiAgICAgICAgc2VyaWFsaXphYmxlT3B0aW9ucyA9IHNlcmlhbGl6YWJsZUNoZWNrO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2goY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKHNlcmlhbGl6YWJsZU9wdGlvbnMpKTtcbiAgICB9XG4gICAgaWYgKGFjdGlvbkNyZWF0b3JDaGVjaykge1xuICAgICAgbGV0IGFjdGlvbkNyZWF0b3JPcHRpb25zID0ge307XG4gICAgICBpZiAoIWlzQm9vbGVhbihhY3Rpb25DcmVhdG9yQ2hlY2spKSB7XG4gICAgICAgIGFjdGlvbkNyZWF0b3JPcHRpb25zID0gYWN0aW9uQ3JlYXRvckNoZWNrO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZUFycmF5LnVuc2hpZnQoY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUoYWN0aW9uQ3JlYXRvck9wdGlvbnMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pZGRsZXdhcmVBcnJheTtcbn07XG5cbi8vIHNyYy9hdXRvQmF0Y2hFbmhhbmNlci50c1xudmFyIFNIT1VMRF9BVVRPQkFUQ0ggPSBcIlJUS19hdXRvQmF0Y2hcIjtcbnZhciBwcmVwYXJlQXV0b0JhdGNoZWQgPSAoKSA9PiAocGF5bG9hZCkgPT4gKHtcbiAgcGF5bG9hZCxcbiAgbWV0YToge1xuICAgIFtTSE9VTERfQVVUT0JBVENIXTogdHJ1ZVxuICB9XG59KTtcbnZhciBjcmVhdGVRdWV1ZVdpdGhUaW1lciA9ICh0aW1lb3V0KSA9PiB7XG4gIHJldHVybiAobm90aWZ5KSA9PiB7XG4gICAgc2V0VGltZW91dChub3RpZnksIHRpbWVvdXQpO1xuICB9O1xufTtcbnZhciByQUYgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogY3JlYXRlUXVldWVXaXRoVGltZXIoMTApO1xudmFyIGF1dG9CYXRjaEVuaGFuY2VyID0gKG9wdGlvbnMgPSB7XG4gIHR5cGU6IFwicmFmXCJcbn0pID0+IChuZXh0KSA9PiAoLi4uYXJncykgPT4ge1xuICBjb25zdCBzdG9yZSA9IG5leHQoLi4uYXJncyk7XG4gIGxldCBub3RpZnlpbmcgPSB0cnVlO1xuICBsZXQgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSBmYWxzZTtcbiAgbGV0IG5vdGlmaWNhdGlvblF1ZXVlZCA9IGZhbHNlO1xuICBjb25zdCBsaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBxdWV1ZUNhbGxiYWNrID0gb3B0aW9ucy50eXBlID09PSBcInRpY2tcIiA/IHF1ZXVlTWljcm90YXNrIDogb3B0aW9ucy50eXBlID09PSBcInJhZlwiID8gckFGIDogb3B0aW9ucy50eXBlID09PSBcImNhbGxiYWNrXCIgPyBvcHRpb25zLnF1ZXVlTm90aWZpY2F0aW9uIDogY3JlYXRlUXVldWVXaXRoVGltZXIob3B0aW9ucy50aW1lb3V0KTtcbiAgY29uc3Qgbm90aWZ5TGlzdGVuZXJzID0gKCkgPT4ge1xuICAgIG5vdGlmaWNhdGlvblF1ZXVlZCA9IGZhbHNlO1xuICAgIGlmIChzaG91bGROb3RpZnlBdEVuZE9mVGljaykge1xuICAgICAgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSBmYWxzZTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChsKSA9PiBsKCkpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0b3JlLCB7XG4gICAgLy8gT3ZlcnJpZGUgdGhlIGJhc2UgYHN0b3JlLnN1YnNjcmliZWAgbWV0aG9kIHRvIGtlZXAgb3JpZ2luYWwgbGlzdGVuZXJzXG4gICAgLy8gZnJvbSBydW5uaW5nIGlmIHdlJ3JlIGRlbGF5aW5nIG5vdGlmaWNhdGlvbnNcbiAgICBzdWJzY3JpYmUobGlzdGVuZXIyKSB7XG4gICAgICBjb25zdCB3cmFwcGVkTGlzdGVuZXIgPSAoKSA9PiBub3RpZnlpbmcgJiYgbGlzdGVuZXIyKCk7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN0b3JlLnN1YnNjcmliZSh3cmFwcGVkTGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcjIpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcjIpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIE92ZXJyaWRlIHRoZSBiYXNlIGBzdG9yZS5kaXNwYXRjaGAgbWV0aG9kIHNvIHRoYXQgd2UgY2FuIGNoZWNrIGFjdGlvbnNcbiAgICAvLyBmb3IgdGhlIGBzaG91bGRBdXRvQmF0Y2hgIGZsYWcgYW5kIGRldGVybWluZSBpZiBiYXRjaGluZyBpcyBhY3RpdmVcbiAgICBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5vdGlmeWluZyA9ICFhY3Rpb24/Lm1ldGE/LltTSE9VTERfQVVUT0JBVENIXTtcbiAgICAgICAgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSAhbm90aWZ5aW5nO1xuICAgICAgICBpZiAoc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2spIHtcbiAgICAgICAgICBpZiAoIW5vdGlmaWNhdGlvblF1ZXVlZCkge1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uUXVldWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHF1ZXVlQ2FsbGJhY2sobm90aWZ5TGlzdGVuZXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBub3RpZnlpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBzcmMvZ2V0RGVmYXVsdEVuaGFuY2Vycy50c1xudmFyIGJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VycyA9IChtaWRkbGV3YXJlRW5oYW5jZXIpID0+IGZ1bmN0aW9uIGdldERlZmF1bHRFbmhhbmNlcnMob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgYXV0b0JhdGNoID0gdHJ1ZVxuICB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgbGV0IGVuaGFuY2VyQXJyYXkgPSBuZXcgVHVwbGUobWlkZGxld2FyZUVuaGFuY2VyKTtcbiAgaWYgKGF1dG9CYXRjaCkge1xuICAgIGVuaGFuY2VyQXJyYXkucHVzaChhdXRvQmF0Y2hFbmhhbmNlcih0eXBlb2YgYXV0b0JhdGNoID09PSBcIm9iamVjdFwiID8gYXV0b0JhdGNoIDogdm9pZCAwKSk7XG4gIH1cbiAgcmV0dXJuIGVuaGFuY2VyQXJyYXk7XG59O1xuXG4vLyBzcmMvY29uZmlndXJlU3RvcmUudHNcbnZhciBJU19QUk9EVUNUSU9OID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiO1xuZnVuY3Rpb24gY29uZmlndXJlU3RvcmUob3B0aW9ucykge1xuICBjb25zdCBnZXREZWZhdWx0TWlkZGxld2FyZSA9IGJ1aWxkR2V0RGVmYXVsdE1pZGRsZXdhcmUoKTtcbiAgY29uc3Qge1xuICAgIHJlZHVjZXIgPSB2b2lkIDAsXG4gICAgbWlkZGxld2FyZSxcbiAgICBkZXZUb29scyA9IHRydWUsXG4gICAgcHJlbG9hZGVkU3RhdGUgPSB2b2lkIDAsXG4gICAgZW5oYW5jZXJzID0gdm9pZCAwXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgcm9vdFJlZHVjZXI7XG4gIGlmICh0eXBlb2YgcmVkdWNlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcm9vdFJlZHVjZXIgPSByZWR1Y2VyO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QyKHJlZHVjZXIpKSB7XG4gICAgcm9vdFJlZHVjZXIgPSBjb21iaW5lUmVkdWNlcnMocmVkdWNlcik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMSkgOiBcImByZWR1Y2VyYCBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LCBhbmQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCBvZiBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGNvbWJpbmVSZWR1Y2Vyc1wiKTtcbiAgfVxuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgbWlkZGxld2FyZSAmJiB0eXBlb2YgbWlkZGxld2FyZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMikgOiBcImBtaWRkbGV3YXJlYCBmaWVsZCBtdXN0IGJlIGEgY2FsbGJhY2tcIik7XG4gIH1cbiAgbGV0IGZpbmFsTWlkZGxld2FyZTtcbiAgaWYgKHR5cGVvZiBtaWRkbGV3YXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmaW5hbE1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlKGdldERlZmF1bHRNaWRkbGV3YXJlKTtcbiAgICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgIUFycmF5LmlzQXJyYXkoZmluYWxNaWRkbGV3YXJlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMykgOiBcIndoZW4gdXNpbmcgYSBtaWRkbGV3YXJlIGJ1aWxkZXIgZnVuY3Rpb24sIGFuIGFycmF5IG9mIG1pZGRsZXdhcmUgbXVzdCBiZSByZXR1cm5lZFwiKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZmluYWxNaWRkbGV3YXJlID0gZ2V0RGVmYXVsdE1pZGRsZXdhcmUoKTtcbiAgfVxuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgZmluYWxNaWRkbGV3YXJlLnNvbWUoKGl0ZW0pID0+IHR5cGVvZiBpdGVtICE9PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNCkgOiBcImVhY2ggbWlkZGxld2FyZSBwcm92aWRlZCB0byBjb25maWd1cmVTdG9yZSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgbGV0IGZpbmFsQ29tcG9zZSA9IGNvbXBvc2UyO1xuICBpZiAoZGV2VG9vbHMpIHtcbiAgICBmaW5hbENvbXBvc2UgPSBjb21wb3NlV2l0aERldlRvb2xzKHtcbiAgICAgIC8vIEVuYWJsZSBjYXB0dXJlIG9mIHN0YWNrIHRyYWNlcyBmb3IgZGlzcGF0Y2hlZCBSZWR1eCBhY3Rpb25zXG4gICAgICB0cmFjZTogIUlTX1BST0RVQ1RJT04sXG4gICAgICAuLi50eXBlb2YgZGV2VG9vbHMgPT09IFwib2JqZWN0XCIgJiYgZGV2VG9vbHNcbiAgICB9KTtcbiAgfVxuICBjb25zdCBtaWRkbGV3YXJlRW5oYW5jZXIgPSBhcHBseU1pZGRsZXdhcmUoLi4uZmluYWxNaWRkbGV3YXJlKTtcbiAgY29uc3QgZ2V0RGVmYXVsdEVuaGFuY2VycyA9IGJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VycyhtaWRkbGV3YXJlRW5oYW5jZXIpO1xuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgZW5oYW5jZXJzICYmIHR5cGVvZiBlbmhhbmNlcnMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDUpIDogXCJgZW5oYW5jZXJzYCBmaWVsZCBtdXN0IGJlIGEgY2FsbGJhY2tcIik7XG4gIH1cbiAgbGV0IHN0b3JlRW5oYW5jZXJzID0gdHlwZW9mIGVuaGFuY2VycyA9PT0gXCJmdW5jdGlvblwiID8gZW5oYW5jZXJzKGdldERlZmF1bHRFbmhhbmNlcnMpIDogZ2V0RGVmYXVsdEVuaGFuY2VycygpO1xuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgIUFycmF5LmlzQXJyYXkoc3RvcmVFbmhhbmNlcnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNikgOiBcImBlbmhhbmNlcnNgIGNhbGxiYWNrIG11c3QgcmV0dXJuIGFuIGFycmF5XCIpO1xuICB9XG4gIGlmICghSVNfUFJPRFVDVElPTiAmJiBzdG9yZUVuaGFuY2Vycy5zb21lKChpdGVtKSA9PiB0eXBlb2YgaXRlbSAhPT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDcpIDogXCJlYWNoIGVuaGFuY2VyIHByb3ZpZGVkIHRvIGNvbmZpZ3VyZVN0b3JlIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgfVxuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgZmluYWxNaWRkbGV3YXJlLmxlbmd0aCAmJiAhc3RvcmVFbmhhbmNlcnMuaW5jbHVkZXMobWlkZGxld2FyZUVuaGFuY2VyKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJtaWRkbGV3YXJlcyB3ZXJlIHByb3ZpZGVkLCBidXQgbWlkZGxld2FyZSBlbmhhbmNlciB3YXMgbm90IGluY2x1ZGVkIGluIGZpbmFsIGVuaGFuY2VycyAtIG1ha2Ugc3VyZSB0byBjYWxsIGBnZXREZWZhdWx0RW5oYW5jZXJzYFwiKTtcbiAgfVxuICBjb25zdCBjb21wb3NlZEVuaGFuY2VyID0gZmluYWxDb21wb3NlKC4uLnN0b3JlRW5oYW5jZXJzKTtcbiAgcmV0dXJuIGNyZWF0ZVN0b3JlKHJvb3RSZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgY29tcG9zZWRFbmhhbmNlcik7XG59XG5cbi8vIHNyYy9jcmVhdGVSZWR1Y2VyLnRzXG5pbXBvcnQgeyBwcm9kdWNlIGFzIGNyZWF0ZU5leHRTdGF0ZTIsIGlzRHJhZnQgYXMgaXNEcmFmdDIsIGlzRHJhZnRhYmxlIGFzIGlzRHJhZnRhYmxlMiB9IGZyb20gXCJpbW1lclwiO1xuXG4vLyBzcmMvbWFwQnVpbGRlcnMudHNcbmZ1bmN0aW9uIGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKGJ1aWxkZXJDYWxsYmFjaykge1xuICBjb25zdCBhY3Rpb25zTWFwID0ge307XG4gIGNvbnN0IGFjdGlvbk1hdGNoZXJzID0gW107XG4gIGxldCBkZWZhdWx0Q2FzZVJlZHVjZXI7XG4gIGNvbnN0IGJ1aWxkZXIgPSB7XG4gICAgYWRkQ2FzZSh0eXBlT3JBY3Rpb25DcmVhdG9yLCByZWR1Y2VyKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChhY3Rpb25NYXRjaGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjYpIDogXCJgYnVpbGRlci5hZGRDYXNlYCBzaG91bGQgb25seSBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGJ1aWxkZXIuYWRkTWF0Y2hlcmBcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI3KSA6IFwiYGJ1aWxkZXIuYWRkQ2FzZWAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZERlZmF1bHRDYXNlYFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB0eXBlT3JBY3Rpb25DcmVhdG9yID09PSBcInN0cmluZ1wiID8gdHlwZU9yQWN0aW9uQ3JlYXRvciA6IHR5cGVPckFjdGlvbkNyZWF0b3IudHlwZTtcbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyOCkgOiBcImBidWlsZGVyLmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBhbiBlbXB0eSBhY3Rpb24gdHlwZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlIGluIGFjdGlvbnNNYXApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjkpIDogYFxcYGJ1aWxkZXIuYWRkQ2FzZVxcYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggdHdvIHJlZHVjZXJzIGZvciB0aGUgc2FtZSBhY3Rpb24gdHlwZSAnJHt0eXBlfSdgKTtcbiAgICAgIH1cbiAgICAgIGFjdGlvbnNNYXBbdHlwZV0gPSByZWR1Y2VyO1xuICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfSxcbiAgICBhZGRNYXRjaGVyKG1hdGNoZXIsIHJlZHVjZXIpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMwKSA6IFwiYGJ1aWxkZXIuYWRkTWF0Y2hlcmAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZERlZmF1bHRDYXNlYFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWN0aW9uTWF0Y2hlcnMucHVzaCh7XG4gICAgICAgIG1hdGNoZXIsXG4gICAgICAgIHJlZHVjZXJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfSxcbiAgICBhZGREZWZhdWx0Q2FzZShyZWR1Y2VyKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMSkgOiBcImBidWlsZGVyLmFkZERlZmF1bHRDYXNlYCBjYW4gb25seSBiZSBjYWxsZWQgb25jZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVmYXVsdENhc2VSZWR1Y2VyID0gcmVkdWNlcjtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH1cbiAgfTtcbiAgYnVpbGRlckNhbGxiYWNrKGJ1aWxkZXIpO1xuICByZXR1cm4gW2FjdGlvbnNNYXAsIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXJdO1xufVxuXG4vLyBzcmMvY3JlYXRlUmVkdWNlci50c1xuZnVuY3Rpb24gaXNTdGF0ZUZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWR1Y2VyKGluaXRpYWxTdGF0ZSwgbWFwT3JCdWlsZGVyQ2FsbGJhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICh0eXBlb2YgbWFwT3JCdWlsZGVyQ2FsbGJhY2sgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDgpIDogXCJUaGUgb2JqZWN0IG5vdGF0aW9uIGZvciBgY3JlYXRlUmVkdWNlcmAgaGFzIGJlZW4gcmVtb3ZlZC4gUGxlYXNlIHVzZSB0aGUgJ2J1aWxkZXIgY2FsbGJhY2snIG5vdGF0aW9uIGluc3RlYWQ6IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2NyZWF0ZVJlZHVjZXJcIik7XG4gICAgfVxuICB9XG4gIGxldCBbYWN0aW9uc01hcCwgZmluYWxBY3Rpb25NYXRjaGVycywgZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXJdID0gZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2sobWFwT3JCdWlsZGVyQ2FsbGJhY2spO1xuICBsZXQgZ2V0SW5pdGlhbFN0YXRlO1xuICBpZiAoaXNTdGF0ZUZ1bmN0aW9uKGluaXRpYWxTdGF0ZSkpIHtcbiAgICBnZXRJbml0aWFsU3RhdGUgPSAoKSA9PiBmcmVlemVEcmFmdGFibGUoaW5pdGlhbFN0YXRlKCkpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGZyb3plbkluaXRpYWxTdGF0ZSA9IGZyZWV6ZURyYWZ0YWJsZShpbml0aWFsU3RhdGUpO1xuICAgIGdldEluaXRpYWxTdGF0ZSA9ICgpID0+IGZyb3plbkluaXRpYWxTdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiByZWR1Y2VyKHN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlKCksIGFjdGlvbikge1xuICAgIGxldCBjYXNlUmVkdWNlcnMgPSBbYWN0aW9uc01hcFthY3Rpb24udHlwZV0sIC4uLmZpbmFsQWN0aW9uTWF0Y2hlcnMuZmlsdGVyKCh7XG4gICAgICBtYXRjaGVyXG4gICAgfSkgPT4gbWF0Y2hlcihhY3Rpb24pKS5tYXAoKHtcbiAgICAgIHJlZHVjZXI6IHJlZHVjZXIyXG4gICAgfSkgPT4gcmVkdWNlcjIpXTtcbiAgICBpZiAoY2FzZVJlZHVjZXJzLmZpbHRlcigoY3IpID0+ICEhY3IpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY2FzZVJlZHVjZXJzID0gW2ZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyXTtcbiAgICB9XG4gICAgcmV0dXJuIGNhc2VSZWR1Y2Vycy5yZWR1Y2UoKHByZXZpb3VzU3RhdGUsIGNhc2VSZWR1Y2VyKSA9PiB7XG4gICAgICBpZiAoY2FzZVJlZHVjZXIpIHtcbiAgICAgICAgaWYgKGlzRHJhZnQyKHByZXZpb3VzU3RhdGUpKSB7XG4gICAgICAgICAgY29uc3QgZHJhZnQgPSBwcmV2aW91c1N0YXRlO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhc2VSZWR1Y2VyKGRyYWZ0LCBhY3Rpb24pO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRHJhZnRhYmxlMihwcmV2aW91c1N0YXRlKSkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhc2VSZWR1Y2VyKHByZXZpb3VzU3RhdGUsIGFjdGlvbik7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDkpIDogXCJBIGNhc2UgcmVkdWNlciBvbiBhIG5vbi1kcmFmdGFibGUgdmFsdWUgbXVzdCBub3QgcmV0dXJuIHVuZGVmaW5lZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlTmV4dFN0YXRlMihwcmV2aW91c1N0YXRlLCAoZHJhZnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XG4gICAgfSwgc3RhdGUpO1xuICB9XG4gIHJlZHVjZXIuZ2V0SW5pdGlhbFN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlO1xuICByZXR1cm4gcmVkdWNlcjtcbn1cblxuLy8gc3JjL25hbm9pZC50c1xudmFyIHVybEFscGhhYmV0ID0gXCJNb2R1bGVTeW1iaGFzT3duUHItMDEyMzQ1Njc4OUFCQ0RFRkdITlJWZmdjdGlVdnpfS3FZVEprTHhwWlhJalFXXCI7XG52YXIgbmFub2lkID0gKHNpemUgPSAyMSkgPT4ge1xuICBsZXQgaWQgPSBcIlwiO1xuICBsZXQgaSA9IHNpemU7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZCArPSB1cmxBbHBoYWJldFtNYXRoLnJhbmRvbSgpICogNjQgfCAwXTtcbiAgfVxuICByZXR1cm4gaWQ7XG59O1xuXG4vLyBzcmMvbWF0Y2hlcnMudHNcbnZhciBtYXRjaGVzID0gKG1hdGNoZXIsIGFjdGlvbikgPT4ge1xuICBpZiAoaGFzTWF0Y2hGdW5jdGlvbihtYXRjaGVyKSkge1xuICAgIHJldHVybiBtYXRjaGVyLm1hdGNoKGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1hdGNoZXIoYWN0aW9uKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGlzQW55T2YoLi4ubWF0Y2hlcnMpIHtcbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gbWF0Y2hlcnMuc29tZSgobWF0Y2hlcikgPT4gbWF0Y2hlcyhtYXRjaGVyLCBhY3Rpb24pKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQWxsT2YoLi4ubWF0Y2hlcnMpIHtcbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gbWF0Y2hlcnMuZXZlcnkoKG1hdGNoZXIpID0+IG1hdGNoZXMobWF0Y2hlciwgYWN0aW9uKSk7XG4gIH07XG59XG5mdW5jdGlvbiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIHZhbGlkU3RhdHVzKSB7XG4gIGlmICghYWN0aW9uIHx8ICFhY3Rpb24ubWV0YSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGhhc1ZhbGlkUmVxdWVzdElkID0gdHlwZW9mIGFjdGlvbi5tZXRhLnJlcXVlc3RJZCA9PT0gXCJzdHJpbmdcIjtcbiAgY29uc3QgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzID0gdmFsaWRTdGF0dXMuaW5kZXhPZihhY3Rpb24ubWV0YS5yZXF1ZXN0U3RhdHVzKSA+IC0xO1xuICByZXR1cm4gaGFzVmFsaWRSZXF1ZXN0SWQgJiYgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzO1xufVxuZnVuY3Rpb24gaXNBc3luY1RodW5rQXJyYXkoYSkge1xuICByZXR1cm4gdHlwZW9mIGFbMF0gPT09IFwiZnVuY3Rpb25cIiAmJiBcInBlbmRpbmdcIiBpbiBhWzBdICYmIFwiZnVsZmlsbGVkXCIgaW4gYVswXSAmJiBcInJlamVjdGVkXCIgaW4gYVswXTtcbn1cbmZ1bmN0aW9uIGlzUGVuZGluZyguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicGVuZGluZ1wiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNQZW5kaW5nKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBhc3luY1RodW5rcy5tYXAoKGFzeW5jVGh1bmspID0+IGFzeW5jVGh1bmsucGVuZGluZyk7XG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZiguLi5tYXRjaGVycyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufVxuZnVuY3Rpb24gaXNSZWplY3RlZCguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicmVqZWN0ZWRcIl0pO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzUmVqZWN0ZWQoKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICBjb25zdCBtYXRjaGVycyA9IGFzeW5jVGh1bmtzLm1hcCgoYXN5bmNUaHVuaykgPT4gYXN5bmNUaHVuay5yZWplY3RlZCk7XG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZiguLi5tYXRjaGVycyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufVxuZnVuY3Rpb24gaXNSZWplY3RlZFdpdGhWYWx1ZSguLi5hc3luY1RodW5rcykge1xuICBjb25zdCBoYXNGbGFnID0gKGFjdGlvbikgPT4ge1xuICAgIHJldHVybiBhY3Rpb24gJiYgYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWU7XG4gIH07XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFjdGlvbikgPT4ge1xuICAgICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbGxPZihpc1JlamVjdGVkKC4uLmFzeW5jVGh1bmtzKSwgaGFzRmxhZyk7XG4gICAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XG4gICAgfTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc1JlamVjdGVkV2l0aFZhbHVlKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbGxPZihpc1JlamVjdGVkKC4uLmFzeW5jVGh1bmtzKSwgaGFzRmxhZyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufVxuZnVuY3Rpb24gaXNGdWxmaWxsZWQoLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcImZ1bGZpbGxlZFwiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNGdWxmaWxsZWQoKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICBjb25zdCBtYXRjaGVycyA9IGFzeW5jVGh1bmtzLm1hcCgoYXN5bmNUaHVuaykgPT4gYXN5bmNUaHVuay5mdWxmaWxsZWQpO1xuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YoLi4ubWF0Y2hlcnMpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua0FjdGlvbiguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicGVuZGluZ1wiLCBcImZ1bGZpbGxlZFwiLCBcInJlamVjdGVkXCJdKTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc0FzeW5jVGh1bmtBY3Rpb24oKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICBjb25zdCBtYXRjaGVycyA9IFtdO1xuICAgIGZvciAoY29uc3QgYXN5bmNUaHVuayBvZiBhc3luY1RodW5rcykge1xuICAgICAgbWF0Y2hlcnMucHVzaChhc3luY1RodW5rLnBlbmRpbmcsIGFzeW5jVGh1bmsucmVqZWN0ZWQsIGFzeW5jVGh1bmsuZnVsZmlsbGVkKTtcbiAgICB9XG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZiguLi5tYXRjaGVycyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufVxuXG4vLyBzcmMvY3JlYXRlQXN5bmNUaHVuay50c1xudmFyIGNvbW1vblByb3BlcnRpZXMgPSBbXCJuYW1lXCIsIFwibWVzc2FnZVwiLCBcInN0YWNrXCIsIFwiY29kZVwiXTtcbnZhciBSZWplY3RXaXRoVmFsdWUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHBheWxvYWQsIG1ldGEpIHtcbiAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gIH1cbiAgLypcbiAgdHlwZS1vbmx5IHByb3BlcnR5IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gUmVqZWN0V2l0aFZhbHVlIGFuZCBGdWxmaWxsV2l0aE1ldGFcbiAgZG9lcyBub3QgZXhpc3QgYXQgcnVudGltZVxuICAqL1xuICBfdHlwZTtcbn07XG52YXIgRnVsZmlsbFdpdGhNZXRhID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBtZXRhKSB7XG4gICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICB9XG4gIC8qXG4gIHR5cGUtb25seSBwcm9wZXJ0eSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIFJlamVjdFdpdGhWYWx1ZSBhbmQgRnVsZmlsbFdpdGhNZXRhXG4gIGRvZXMgbm90IGV4aXN0IGF0IHJ1bnRpbWVcbiAgKi9cbiAgX3R5cGU7XG59O1xudmFyIG1pbmlTZXJpYWxpemVFcnJvciA9ICh2YWx1ZSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgY29uc3Qgc2ltcGxlRXJyb3IgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIGNvbW1vblByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVbcHJvcGVydHldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHNpbXBsZUVycm9yW3Byb3BlcnR5XSA9IHZhbHVlW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpbXBsZUVycm9yO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogU3RyaW5nKHZhbHVlKVxuICB9O1xufTtcbnZhciBjcmVhdGVBc3luY1RodW5rID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUFzeW5jVGh1bmsyKHR5cGVQcmVmaXgsIHBheWxvYWRDcmVhdG9yLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZnVsZmlsbGVkID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9mdWxmaWxsZWRcIiwgKHBheWxvYWQsIHJlcXVlc3RJZCwgYXJnLCBtZXRhKSA9PiAoe1xuICAgICAgcGF5bG9hZCxcbiAgICAgIG1ldGE6IHtcbiAgICAgICAgLi4ubWV0YSB8fCB7fSxcbiAgICAgICAgYXJnLFxuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHJlcXVlc3RTdGF0dXM6IFwiZnVsZmlsbGVkXCJcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgY29uc3QgcGVuZGluZyA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvcGVuZGluZ1wiLCAocmVxdWVzdElkLCBhcmcsIG1ldGEpID0+ICh7XG4gICAgICBwYXlsb2FkOiB2b2lkIDAsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLm1ldGEgfHwge30sXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiBcInBlbmRpbmdcIlxuICAgICAgfVxuICAgIH0pKTtcbiAgICBjb25zdCByZWplY3RlZCA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvcmVqZWN0ZWRcIiwgKGVycm9yLCByZXF1ZXN0SWQsIGFyZywgcGF5bG9hZCwgbWV0YSkgPT4gKHtcbiAgICAgIHBheWxvYWQsXG4gICAgICBlcnJvcjogKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXJpYWxpemVFcnJvciB8fCBtaW5pU2VyaWFsaXplRXJyb3IpKGVycm9yIHx8IFwiUmVqZWN0ZWRcIiksXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLm1ldGEgfHwge30sXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZWplY3RlZFdpdGhWYWx1ZTogISFwYXlsb2FkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiBcInJlamVjdGVkXCIsXG4gICAgICAgIGFib3J0ZWQ6IGVycm9yPy5uYW1lID09PSBcIkFib3J0RXJyb3JcIixcbiAgICAgICAgY29uZGl0aW9uOiBlcnJvcj8ubmFtZSA9PT0gXCJDb25kaXRpb25FcnJvclwiXG4gICAgICB9XG4gICAgfSkpO1xuICAgIGZ1bmN0aW9uIGFjdGlvbkNyZWF0b3IoYXJnKSB7XG4gICAgICByZXR1cm4gKGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmEpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gb3B0aW9ucz8uaWRHZW5lcmF0b3IgPyBvcHRpb25zLmlkR2VuZXJhdG9yKGFyZykgOiBuYW5vaWQoKTtcbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBsZXQgYWJvcnRIYW5kbGVyO1xuICAgICAgICBsZXQgYWJvcnRSZWFzb247XG4gICAgICAgIGZ1bmN0aW9uIGFib3J0KHJlYXNvbikge1xuICAgICAgICAgIGFib3J0UmVhc29uID0gcmVhc29uO1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsZXQgZmluYWxBY3Rpb247XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBjb25kaXRpb25SZXN1bHQgPSBvcHRpb25zPy5jb25kaXRpb24/LihhcmcsIHtcbiAgICAgICAgICAgICAgZ2V0U3RhdGUsXG4gICAgICAgICAgICAgIGV4dHJhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpc1RoZW5hYmxlKGNvbmRpdGlvblJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gYXdhaXQgY29uZGl0aW9uUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmRpdGlvblJlc3VsdCA9PT0gZmFsc2UgfHwgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkNvbmRpdGlvbkVycm9yXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBYm9ydGVkIGR1ZSB0byBjb25kaXRpb24gY2FsbGJhY2sgcmV0dXJuaW5nIGZhbHNlLlwiXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhYm9ydGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgYWJvcnRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcIkFib3J0RXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGFib3J0UmVhc29uIHx8IFwiQWJvcnRlZFwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHBlbmRpbmcocmVxdWVzdElkLCBhcmcsIG9wdGlvbnM/LmdldFBlbmRpbmdNZXRhPy4oe1xuICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgIGFyZ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBnZXRTdGF0ZSxcbiAgICAgICAgICAgICAgZXh0cmFcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICBmaW5hbEFjdGlvbiA9IGF3YWl0IFByb21pc2UucmFjZShbYWJvcnRlZFByb21pc2UsIFByb21pc2UucmVzb2x2ZShwYXlsb2FkQ3JlYXRvcihhcmcsIHtcbiAgICAgICAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgICAgICAgIGdldFN0YXRlLFxuICAgICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICAgIGFib3J0LFxuICAgICAgICAgICAgICByZWplY3RXaXRoVmFsdWU6ICh2YWx1ZSwgbWV0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVqZWN0V2l0aFZhbHVlKHZhbHVlLCBtZXRhKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVsZmlsbFdpdGhWYWx1ZTogKHZhbHVlLCBtZXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGdWxmaWxsV2l0aE1ldGEodmFsdWUsIG1ldGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEZ1bGZpbGxXaXRoTWV0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWQocmVzdWx0LnBheWxvYWQsIHJlcXVlc3RJZCwgYXJnLCByZXN1bHQubWV0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZChyZXN1bHQsIHJlcXVlc3RJZCwgYXJnKTtcbiAgICAgICAgICAgIH0pXSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBmaW5hbEFjdGlvbiA9IGVyciBpbnN0YW5jZW9mIFJlamVjdFdpdGhWYWx1ZSA/IHJlamVjdGVkKG51bGwsIHJlcXVlc3RJZCwgYXJnLCBlcnIucGF5bG9hZCwgZXJyLm1ldGEpIDogcmVqZWN0ZWQoZXJyLCByZXF1ZXN0SWQsIGFyZyk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChhYm9ydEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2tpcERpc3BhdGNoID0gb3B0aW9ucyAmJiAhb3B0aW9ucy5kaXNwYXRjaENvbmRpdGlvblJlamVjdGlvbiAmJiByZWplY3RlZC5tYXRjaChmaW5hbEFjdGlvbikgJiYgZmluYWxBY3Rpb24ubWV0YS5jb25kaXRpb247XG4gICAgICAgICAgaWYgKCFza2lwRGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKGZpbmFsQWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZpbmFsQWN0aW9uO1xuICAgICAgICB9KCk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHByb21pc2UsIHtcbiAgICAgICAgICBhYm9ydCxcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgYXJnLFxuICAgICAgICAgIHVud3JhcCgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4odW53cmFwUmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWN0aW9uQ3JlYXRvciwge1xuICAgICAgcGVuZGluZyxcbiAgICAgIHJlamVjdGVkLFxuICAgICAgZnVsZmlsbGVkLFxuICAgICAgc2V0dGxlZDogaXNBbnlPZihyZWplY3RlZCwgZnVsZmlsbGVkKSxcbiAgICAgIHR5cGVQcmVmaXhcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVBc3luY1RodW5rMi53aXRoVHlwZXMgPSAoKSA9PiBjcmVhdGVBc3luY1RodW5rMjtcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jVGh1bmsyO1xufSkoKTtcbmZ1bmN0aW9uIHVud3JhcFJlc3VsdChhY3Rpb24pIHtcbiAgaWYgKGFjdGlvbi5tZXRhICYmIGFjdGlvbi5tZXRhLnJlamVjdGVkV2l0aFZhbHVlKSB7XG4gICAgdGhyb3cgYWN0aW9uLnBheWxvYWQ7XG4gIH1cbiAgaWYgKGFjdGlvbi5lcnJvcikge1xuICAgIHRocm93IGFjdGlvbi5lcnJvcjtcbiAgfVxuICByZXR1cm4gYWN0aW9uLnBheWxvYWQ7XG59XG5mdW5jdGlvbiBpc1RoZW5hYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLy8gc3JjL2NyZWF0ZVNsaWNlLnRzXG52YXIgYXN5bmNUaHVua1N5bWJvbCA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicnRrLXNsaWNlLWNyZWF0ZWFzeW5jdGh1bmtcIik7XG52YXIgYXN5bmNUaHVua0NyZWF0b3IgPSB7XG4gIFthc3luY1RodW5rU3ltYm9sXTogY3JlYXRlQXN5bmNUaHVua1xufTtcbnZhciBSZWR1Y2VyVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFJlZHVjZXJUeXBlMikgPT4ge1xuICBSZWR1Y2VyVHlwZTJbXCJyZWR1Y2VyXCJdID0gXCJyZWR1Y2VyXCI7XG4gIFJlZHVjZXJUeXBlMltcInJlZHVjZXJXaXRoUHJlcGFyZVwiXSA9IFwicmVkdWNlcldpdGhQcmVwYXJlXCI7XG4gIFJlZHVjZXJUeXBlMltcImFzeW5jVGh1bmtcIl0gPSBcImFzeW5jVGh1bmtcIjtcbiAgcmV0dXJuIFJlZHVjZXJUeXBlMjtcbn0pKFJlZHVjZXJUeXBlIHx8IHt9KTtcbmZ1bmN0aW9uIGdldFR5cGUoc2xpY2UsIGFjdGlvbktleSkge1xuICByZXR1cm4gYCR7c2xpY2V9LyR7YWN0aW9uS2V5fWA7XG59XG5mdW5jdGlvbiBidWlsZENyZWF0ZVNsaWNlKHtcbiAgY3JlYXRvcnNcbn0gPSB7fSkge1xuICBjb25zdCBjQVQgPSBjcmVhdG9ycz8uYXN5bmNUaHVuaz8uW2FzeW5jVGh1bmtTeW1ib2xdO1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlU2xpY2UyKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgcmVkdWNlclBhdGggPSBuYW1lXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMSkgOiBcImBuYW1lYCBpcyBhIHJlcXVpcmVkIG9wdGlvbiBmb3IgY3JlYXRlU2xpY2VcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbml0aWFsU3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiWW91IG11c3QgcHJvdmlkZSBhbiBgaW5pdGlhbFN0YXRlYCB2YWx1ZSB0aGF0IGlzIG5vdCBgdW5kZWZpbmVkYC4gWW91IG1heSBoYXZlIG1pc3NwZWxsZWQgYGluaXRpYWxTdGF0ZWBcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlZHVjZXJzID0gKHR5cGVvZiBvcHRpb25zLnJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLnJlZHVjZXJzKGJ1aWxkUmVkdWNlckNyZWF0b3JzKCkpIDogb3B0aW9ucy5yZWR1Y2VycykgfHwge307XG4gICAgY29uc3QgcmVkdWNlck5hbWVzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZToge30sXG4gICAgICBzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZToge30sXG4gICAgICBhY3Rpb25DcmVhdG9yczoge30sXG4gICAgICBzbGljZU1hdGNoZXJzOiBbXVxuICAgIH07XG4gICAgY29uc3QgY29udGV4dE1ldGhvZHMgPSB7XG4gICAgICBhZGRDYXNlKHR5cGVPckFjdGlvbkNyZWF0b3IsIHJlZHVjZXIyKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPckFjdGlvbkNyZWF0b3IgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGU7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEyKSA6IFwiYGNvbnRleHQuYWRkQ2FzZWAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5IGFjdGlvbiB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlIGluIGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMykgOiBcImBjb250ZXh0LmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCB0d28gcmVkdWNlcnMgZm9yIHRoZSBzYW1lIGFjdGlvbiB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGVbdHlwZV0gPSByZWR1Y2VyMjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZXRob2RzO1xuICAgICAgfSxcbiAgICAgIGFkZE1hdGNoZXIobWF0Y2hlciwgcmVkdWNlcjIpIHtcbiAgICAgICAgY29udGV4dC5zbGljZU1hdGNoZXJzLnB1c2goe1xuICAgICAgICAgIG1hdGNoZXIsXG4gICAgICAgICAgcmVkdWNlcjogcmVkdWNlcjJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcbiAgICAgIH0sXG4gICAgICBleHBvc2VBY3Rpb24obmFtZTIsIGFjdGlvbkNyZWF0b3IpIHtcbiAgICAgICAgY29udGV4dC5hY3Rpb25DcmVhdG9yc1tuYW1lMl0gPSBhY3Rpb25DcmVhdG9yO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9LFxuICAgICAgZXhwb3NlQ2FzZVJlZHVjZXIobmFtZTIsIHJlZHVjZXIyKSB7XG4gICAgICAgIGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWVbbmFtZTJdID0gcmVkdWNlcjI7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlZHVjZXJOYW1lcy5mb3JFYWNoKChyZWR1Y2VyTmFtZSkgPT4ge1xuICAgICAgY29uc3QgcmVkdWNlckRlZmluaXRpb24gPSByZWR1Y2Vyc1tyZWR1Y2VyTmFtZV07XG4gICAgICBjb25zdCByZWR1Y2VyRGV0YWlscyA9IHtcbiAgICAgICAgcmVkdWNlck5hbWUsXG4gICAgICAgIHR5cGU6IGdldFR5cGUobmFtZSwgcmVkdWNlck5hbWUpLFxuICAgICAgICBjcmVhdGVOb3RhdGlvbjogdHlwZW9mIG9wdGlvbnMucmVkdWNlcnMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgfTtcbiAgICAgIGlmIChpc0FzeW5jVGh1bmtTbGljZVJlZHVjZXJEZWZpbml0aW9uKHJlZHVjZXJEZWZpbml0aW9uKSkge1xuICAgICAgICBoYW5kbGVUaHVua0Nhc2VSZWR1Y2VyRGVmaW5pdGlvbihyZWR1Y2VyRGV0YWlscywgcmVkdWNlckRlZmluaXRpb24sIGNvbnRleHRNZXRob2RzLCBjQVQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlTm9ybWFsUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRldGFpbHMsIHJlZHVjZXJEZWZpbml0aW9uLCBjb250ZXh0TWV0aG9kcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gYnVpbGRSZWR1Y2VyKCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZXh0cmFSZWR1Y2VycyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE0KSA6IFwiVGhlIG9iamVjdCBub3RhdGlvbiBmb3IgYGNyZWF0ZVNsaWNlLmV4dHJhUmVkdWNlcnNgIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSB1c2UgdGhlICdidWlsZGVyIGNhbGxiYWNrJyBub3RhdGlvbiBpbnN0ZWFkOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9jcmVhdGVTbGljZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgW2V4dHJhUmVkdWNlcnMgPSB7fSwgYWN0aW9uTWF0Y2hlcnMgPSBbXSwgZGVmYXVsdENhc2VSZWR1Y2VyID0gdm9pZCAwXSA9IHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09IFwiZnVuY3Rpb25cIiA/IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKG9wdGlvbnMuZXh0cmFSZWR1Y2VycykgOiBbb3B0aW9ucy5leHRyYVJlZHVjZXJzXTtcbiAgICAgIGNvbnN0IGZpbmFsQ2FzZVJlZHVjZXJzID0ge1xuICAgICAgICAuLi5leHRyYVJlZHVjZXJzLFxuICAgICAgICAuLi5jb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlZHVjZXIob3B0aW9ucy5pbml0aWFsU3RhdGUsIChidWlsZGVyKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBmaW5hbENhc2VSZWR1Y2Vycykge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShrZXksIGZpbmFsQ2FzZVJlZHVjZXJzW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHNNIG9mIGNvbnRleHQuc2xpY2VNYXRjaGVycykge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkTWF0Y2hlcihzTS5tYXRjaGVyLCBzTS5yZWR1Y2VyKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBtIG9mIGFjdGlvbk1hdGNoZXJzKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGRNYXRjaGVyKG0ubWF0Y2hlciwgbS5yZWR1Y2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGREZWZhdWx0Q2FzZShkZWZhdWx0Q2FzZVJlZHVjZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0U2VsZiA9IChzdGF0ZSkgPT4gc3RhdGU7XG4gICAgY29uc3QgaW5qZWN0ZWRTZWxlY3RvckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgX3JlZHVjZXI7XG4gICAgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICBpZiAoIV9yZWR1Y2VyKVxuICAgICAgICBfcmVkdWNlciA9IGJ1aWxkUmVkdWNlcigpO1xuICAgICAgcmV0dXJuIF9yZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgICBpZiAoIV9yZWR1Y2VyKVxuICAgICAgICBfcmVkdWNlciA9IGJ1aWxkUmVkdWNlcigpO1xuICAgICAgcmV0dXJuIF9yZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlU2VsZWN0b3JQcm9wcyhyZWR1Y2VyUGF0aDIsIGluamVjdGVkID0gZmFsc2UpIHtcbiAgICAgIGZ1bmN0aW9uIHNlbGVjdFNsaWNlKHN0YXRlKSB7XG4gICAgICAgIGxldCBzbGljZVN0YXRlID0gc3RhdGVbcmVkdWNlclBhdGgyXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzbGljZVN0YXRlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaWYgKGluamVjdGVkKSB7XG4gICAgICAgICAgICBzbGljZVN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE1KSA6IFwic2VsZWN0U2xpY2UgcmV0dXJuZWQgdW5kZWZpbmVkIGZvciBhbiB1bmluamVjdGVkIHNsaWNlIHJlZHVjZXJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzbGljZVN0YXRlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2V0U2VsZWN0b3JzKHNlbGVjdFN0YXRlID0gc2VsZWN0U2VsZikge1xuICAgICAgICBjb25zdCBzZWxlY3RvckNhY2hlID0gZW1wbGFjZShpbmplY3RlZFNlbGVjdG9yQ2FjaGUsIGluamVjdGVkLCB7XG4gICAgICAgICAgaW5zZXJ0OiAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVtcGxhY2Uoc2VsZWN0b3JDYWNoZSwgc2VsZWN0U3RhdGUsIHtcbiAgICAgICAgICBpbnNlcnQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZTIsIHNlbGVjdG9yXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zLnNlbGVjdG9ycyA/PyB7fSkpIHtcbiAgICAgICAgICAgICAgbWFwW25hbWUyXSA9IHdyYXBTZWxlY3RvcihzZWxlY3Rvciwgc2VsZWN0U3RhdGUsIGdldEluaXRpYWxTdGF0ZSwgaW5qZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVkdWNlclBhdGg6IHJlZHVjZXJQYXRoMixcbiAgICAgICAgZ2V0U2VsZWN0b3JzLFxuICAgICAgICBnZXQgc2VsZWN0b3JzKCkge1xuICAgICAgICAgIHJldHVybiBnZXRTZWxlY3RvcnMoc2VsZWN0U2xpY2UpO1xuICAgICAgICB9LFxuICAgICAgICBzZWxlY3RTbGljZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2xpY2UgPSB7XG4gICAgICBuYW1lLFxuICAgICAgcmVkdWNlcixcbiAgICAgIGFjdGlvbnM6IGNvbnRleHQuYWN0aW9uQ3JlYXRvcnMsXG4gICAgICBjYXNlUmVkdWNlcnM6IGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWUsXG4gICAgICBnZXRJbml0aWFsU3RhdGUsXG4gICAgICAuLi5tYWtlU2VsZWN0b3JQcm9wcyhyZWR1Y2VyUGF0aCksXG4gICAgICBpbmplY3RJbnRvKGluamVjdGFibGUsIHtcbiAgICAgICAgcmVkdWNlclBhdGg6IHBhdGhPcHQsXG4gICAgICAgIC4uLmNvbmZpZ1xuICAgICAgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG5ld1JlZHVjZXJQYXRoID0gcGF0aE9wdCA/PyByZWR1Y2VyUGF0aDtcbiAgICAgICAgaW5qZWN0YWJsZS5pbmplY3Qoe1xuICAgICAgICAgIHJlZHVjZXJQYXRoOiBuZXdSZWR1Y2VyUGF0aCxcbiAgICAgICAgICByZWR1Y2VyXG4gICAgICAgIH0sIGNvbmZpZyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc2xpY2UsXG4gICAgICAgICAgLi4ubWFrZVNlbGVjdG9yUHJvcHMobmV3UmVkdWNlclBhdGgsIHRydWUpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gc2xpY2U7XG4gIH07XG59XG5mdW5jdGlvbiB3cmFwU2VsZWN0b3Ioc2VsZWN0b3IsIHNlbGVjdFN0YXRlLCBnZXRJbml0aWFsU3RhdGUsIGluamVjdGVkKSB7XG4gIGZ1bmN0aW9uIHdyYXBwZXIocm9vdFN0YXRlLCAuLi5hcmdzKSB7XG4gICAgbGV0IHNsaWNlU3RhdGUgPSBzZWxlY3RTdGF0ZShyb290U3RhdGUpO1xuICAgIGlmICh0eXBlb2Ygc2xpY2VTdGF0ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKGluamVjdGVkKSB7XG4gICAgICAgIHNsaWNlU3RhdGUgPSBnZXRJbml0aWFsU3RhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE2KSA6IFwic2VsZWN0U3RhdGUgcmV0dXJuZWQgdW5kZWZpbmVkIGZvciBhbiB1bmluamVjdGVkIHNsaWNlIHJlZHVjZXJcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RvcihzbGljZVN0YXRlLCAuLi5hcmdzKTtcbiAgfVxuICB3cmFwcGVyLnVud3JhcHBlZCA9IHNlbGVjdG9yO1xuICByZXR1cm4gd3JhcHBlcjtcbn1cbnZhciBjcmVhdGVTbGljZSA9IC8qIEBfX1BVUkVfXyAqLyBidWlsZENyZWF0ZVNsaWNlKCk7XG5mdW5jdGlvbiBidWlsZFJlZHVjZXJDcmVhdG9ycygpIHtcbiAgZnVuY3Rpb24gYXN5bmNUaHVuayhwYXlsb2FkQ3JlYXRvciwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9yZWR1Y2VyRGVmaW5pdGlvblR5cGU6IFwiYXN5bmNUaHVua1wiIC8qIGFzeW5jVGh1bmsgKi8sXG4gICAgICBwYXlsb2FkQ3JlYXRvcixcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH07XG4gIH1cbiAgYXN5bmNUaHVuay53aXRoVHlwZXMgPSAoKSA9PiBhc3luY1RodW5rO1xuICByZXR1cm4ge1xuICAgIHJlZHVjZXIoY2FzZVJlZHVjZXIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgLy8gaGFjayBzbyB0aGUgd3JhcHBpbmcgZnVuY3Rpb24gaGFzIHRoZSBzYW1lIG5hbWUgYXMgdGhlIG9yaWdpbmFsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gY3JlYXRlIGEgd3JhcHBlciBzbyB0aGUgYHJlZHVjZXJEZWZpbml0aW9uVHlwZWAgaXMgbm90IGFzc2lnbmVkIHRvIHRoZSBvcmlnaW5hbFxuICAgICAgICBbY2FzZVJlZHVjZXIubmFtZV0oLi4uYXJncykge1xuICAgICAgICAgIHJldHVybiBjYXNlUmVkdWNlciguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVtjYXNlUmVkdWNlci5uYW1lXSwge1xuICAgICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcInJlZHVjZXJcIiAvKiByZWR1Y2VyICovXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHByZXBhcmVkUmVkdWNlcihwcmVwYXJlLCByZWR1Y2VyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcInJlZHVjZXJXaXRoUHJlcGFyZVwiIC8qIHJlZHVjZXJXaXRoUHJlcGFyZSAqLyxcbiAgICAgICAgcHJlcGFyZSxcbiAgICAgICAgcmVkdWNlclxuICAgICAgfTtcbiAgICB9LFxuICAgIGFzeW5jVGh1bmtcbiAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5vcm1hbFJlZHVjZXJEZWZpbml0aW9uKHtcbiAgdHlwZSxcbiAgcmVkdWNlck5hbWUsXG4gIGNyZWF0ZU5vdGF0aW9uXG59LCBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSwgY29udGV4dCkge1xuICBsZXQgY2FzZVJlZHVjZXI7XG4gIGxldCBwcmVwYXJlQ2FsbGJhY2s7XG4gIGlmIChcInJlZHVjZXJcIiBpbiBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSkge1xuICAgIGlmIChjcmVhdGVOb3RhdGlvbiAmJiAhaXNDYXNlUmVkdWNlcldpdGhQcmVwYXJlRGVmaW5pdGlvbihtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE3KSA6IFwiUGxlYXNlIHVzZSB0aGUgYGNyZWF0ZS5wcmVwYXJlZFJlZHVjZXJgIG5vdGF0aW9uIGZvciBwcmVwYXJlZCBhY3Rpb24gY3JlYXRvcnMgd2l0aCB0aGUgYGNyZWF0ZWAgbm90YXRpb24uXCIpO1xuICAgIH1cbiAgICBjYXNlUmVkdWNlciA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlLnJlZHVjZXI7XG4gICAgcHJlcGFyZUNhbGxiYWNrID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUucHJlcGFyZTtcbiAgfSBlbHNlIHtcbiAgICBjYXNlUmVkdWNlciA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlO1xuICB9XG4gIGNvbnRleHQuYWRkQ2FzZSh0eXBlLCBjYXNlUmVkdWNlcikuZXhwb3NlQ2FzZVJlZHVjZXIocmVkdWNlck5hbWUsIGNhc2VSZWR1Y2VyKS5leHBvc2VBY3Rpb24ocmVkdWNlck5hbWUsIHByZXBhcmVDYWxsYmFjayA/IGNyZWF0ZUFjdGlvbih0eXBlLCBwcmVwYXJlQ2FsbGJhY2spIDogY3JlYXRlQWN0aW9uKHR5cGUpKTtcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRlZmluaXRpb24pIHtcbiAgcmV0dXJuIHJlZHVjZXJEZWZpbml0aW9uLl9yZWR1Y2VyRGVmaW5pdGlvblR5cGUgPT09IFwiYXN5bmNUaHVua1wiIC8qIGFzeW5jVGh1bmsgKi87XG59XG5mdW5jdGlvbiBpc0Nhc2VSZWR1Y2VyV2l0aFByZXBhcmVEZWZpbml0aW9uKHJlZHVjZXJEZWZpbml0aW9uKSB7XG4gIHJldHVybiByZWR1Y2VyRGVmaW5pdGlvbi5fcmVkdWNlckRlZmluaXRpb25UeXBlID09PSBcInJlZHVjZXJXaXRoUHJlcGFyZVwiIC8qIHJlZHVjZXJXaXRoUHJlcGFyZSAqLztcbn1cbmZ1bmN0aW9uIGhhbmRsZVRodW5rQ2FzZVJlZHVjZXJEZWZpbml0aW9uKHtcbiAgdHlwZSxcbiAgcmVkdWNlck5hbWVcbn0sIHJlZHVjZXJEZWZpbml0aW9uLCBjb250ZXh0LCBjQVQpIHtcbiAgaWYgKCFjQVQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxOCkgOiBcIkNhbm5vdCB1c2UgYGNyZWF0ZS5hc3luY1RodW5rYCBpbiB0aGUgYnVpbHQtaW4gYGNyZWF0ZVNsaWNlYC4gVXNlIGBidWlsZENyZWF0ZVNsaWNlKHsgY3JlYXRvcnM6IHsgYXN5bmNUaHVuazogYXN5bmNUaHVua0NyZWF0b3IgfSB9KWAgdG8gY3JlYXRlIGEgY3VzdG9taXNlZCB2ZXJzaW9uIG9mIGBjcmVhdGVTbGljZWAuXCIpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBwYXlsb2FkQ3JlYXRvcixcbiAgICBmdWxmaWxsZWQsXG4gICAgcGVuZGluZyxcbiAgICByZWplY3RlZCxcbiAgICBzZXR0bGVkLFxuICAgIG9wdGlvbnNcbiAgfSA9IHJlZHVjZXJEZWZpbml0aW9uO1xuICBjb25zdCB0aHVuayA9IGNBVCh0eXBlLCBwYXlsb2FkQ3JlYXRvciwgb3B0aW9ucyk7XG4gIGNvbnRleHQuZXhwb3NlQWN0aW9uKHJlZHVjZXJOYW1lLCB0aHVuayk7XG4gIGlmIChmdWxmaWxsZWQpIHtcbiAgICBjb250ZXh0LmFkZENhc2UodGh1bmsuZnVsZmlsbGVkLCBmdWxmaWxsZWQpO1xuICB9XG4gIGlmIChwZW5kaW5nKSB7XG4gICAgY29udGV4dC5hZGRDYXNlKHRodW5rLnBlbmRpbmcsIHBlbmRpbmcpO1xuICB9XG4gIGlmIChyZWplY3RlZCkge1xuICAgIGNvbnRleHQuYWRkQ2FzZSh0aHVuay5yZWplY3RlZCwgcmVqZWN0ZWQpO1xuICB9XG4gIGlmIChzZXR0bGVkKSB7XG4gICAgY29udGV4dC5hZGRNYXRjaGVyKHRodW5rLnNldHRsZWQsIHNldHRsZWQpO1xuICB9XG4gIGNvbnRleHQuZXhwb3NlQ2FzZVJlZHVjZXIocmVkdWNlck5hbWUsIHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCB8fCBub29wLFxuICAgIHBlbmRpbmc6IHBlbmRpbmcgfHwgbm9vcCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWQgfHwgbm9vcCxcbiAgICBzZXR0bGVkOiBzZXR0bGVkIHx8IG5vb3BcbiAgfSk7XG59XG5mdW5jdGlvbiBub29wKCkge1xufVxuXG4vLyBzcmMvZW50aXRpZXMvZW50aXR5X3N0YXRlLnRzXG5mdW5jdGlvbiBnZXRJbml0aWFsRW50aXR5U3RhdGUoKSB7XG4gIHJldHVybiB7XG4gICAgaWRzOiBbXSxcbiAgICBlbnRpdGllczoge31cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3Rvcnkoc3RhdGVBZGFwdGVyKSB7XG4gIGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZShhZGRpdGlvbmFsU3RhdGUgPSB7fSwgZW50aXRpZXMpIHtcbiAgICBjb25zdCBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCksIGFkZGl0aW9uYWxTdGF0ZSk7XG4gICAgcmV0dXJuIGVudGl0aWVzID8gc3RhdGVBZGFwdGVyLnNldEFsbChzdGF0ZSwgZW50aXRpZXMpIDogc3RhdGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRJbml0aWFsU3RhdGVcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3N0YXRlX3NlbGVjdG9ycy50c1xuZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSgpIHtcbiAgZnVuY3Rpb24gZ2V0U2VsZWN0b3JzKHNlbGVjdFN0YXRlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBjcmVhdGVTZWxlY3RvcjogY3JlYXRlU2VsZWN0b3IyID0gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBzZWxlY3RJZHMgPSAoc3RhdGUpID0+IHN0YXRlLmlkcztcbiAgICBjb25zdCBzZWxlY3RFbnRpdGllcyA9IChzdGF0ZSkgPT4gc3RhdGUuZW50aXRpZXM7XG4gICAgY29uc3Qgc2VsZWN0QWxsID0gY3JlYXRlU2VsZWN0b3IyKHNlbGVjdElkcywgc2VsZWN0RW50aXRpZXMsIChpZHMsIGVudGl0aWVzKSA9PiBpZHMubWFwKChpZCkgPT4gZW50aXRpZXNbaWRdKSk7XG4gICAgY29uc3Qgc2VsZWN0SWQgPSAoXywgaWQpID0+IGlkO1xuICAgIGNvbnN0IHNlbGVjdEJ5SWQgPSAoZW50aXRpZXMsIGlkKSA9PiBlbnRpdGllc1tpZF07XG4gICAgY29uc3Qgc2VsZWN0VG90YWwgPSBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0SWRzLCAoaWRzKSA9PiBpZHMubGVuZ3RoKTtcbiAgICBpZiAoIXNlbGVjdFN0YXRlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RJZHMsXG4gICAgICAgIHNlbGVjdEVudGl0aWVzLFxuICAgICAgICBzZWxlY3RBbGwsXG4gICAgICAgIHNlbGVjdFRvdGFsLFxuICAgICAgICBzZWxlY3RCeUlkOiBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0RW50aXRpZXMsIHNlbGVjdElkLCBzZWxlY3RCeUlkKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0R2xvYmFsaXplZEVudGl0aWVzID0gY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFN0YXRlLCBzZWxlY3RFbnRpdGllcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdElkczogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFN0YXRlLCBzZWxlY3RJZHMpLFxuICAgICAgc2VsZWN0RW50aXRpZXM6IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyxcbiAgICAgIHNlbGVjdEFsbDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFN0YXRlLCBzZWxlY3RBbGwpLFxuICAgICAgc2VsZWN0VG90YWw6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0VG90YWwpLFxuICAgICAgc2VsZWN0QnlJZDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcywgc2VsZWN0SWQsIHNlbGVjdEJ5SWQpXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldFNlbGVjdG9yc1xuICB9O1xufVxuXG4vLyBzcmMvZW50aXRpZXMvc3RhdGVfYWRhcHRlci50c1xuaW1wb3J0IHsgcHJvZHVjZSBhcyBjcmVhdGVOZXh0U3RhdGUzLCBpc0RyYWZ0IGFzIGlzRHJhZnQzIH0gZnJvbSBcImltbWVyXCI7XG52YXIgaXNEcmFmdFR5cGVkID0gaXNEcmFmdDM7XG5mdW5jdGlvbiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IobXV0YXRvcikge1xuICBjb25zdCBvcGVyYXRvciA9IGNyZWF0ZVN0YXRlT3BlcmF0b3IoKF8sIHN0YXRlKSA9PiBtdXRhdG9yKHN0YXRlKSk7XG4gIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gb3BlcmF0b3Ioc3RhdGUsIHZvaWQgMCk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0ZU9wZXJhdG9yKG11dGF0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9wZXJhdGlvbihzdGF0ZSwgYXJnKSB7XG4gICAgZnVuY3Rpb24gaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQoYXJnMikge1xuICAgICAgcmV0dXJuIGlzRlNBKGFyZzIpO1xuICAgIH1cbiAgICBjb25zdCBydW5NdXRhdG9yID0gKGRyYWZ0KSA9PiB7XG4gICAgICBpZiAoaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQoYXJnKSkge1xuICAgICAgICBtdXRhdG9yKGFyZy5wYXlsb2FkLCBkcmFmdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdXRhdG9yKGFyZywgZHJhZnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzRHJhZnRUeXBlZChzdGF0ZSkpIHtcbiAgICAgIHJ1bk11dGF0b3Ioc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlTmV4dFN0YXRlMyhzdGF0ZSwgcnVuTXV0YXRvcik7XG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy91dGlscy50c1xuZnVuY3Rpb24gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKSB7XG4gIGNvbnN0IGtleSA9IHNlbGVjdElkKGVudGl0eSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYga2V5ID09PSB2b2lkIDApIHtcbiAgICBjb25zb2xlLndhcm4oXCJUaGUgZW50aXR5IHBhc3NlZCB0byB0aGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCB1bmRlZmluZWQuXCIsIFwiWW91IHNob3VsZCBwcm9iYWJseSBwcm92aWRlIHlvdXIgb3duIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb24uXCIsIFwiVGhlIGVudGl0eSB0aGF0IHdhcyBwYXNzZWQ6XCIsIGVudGl0eSwgXCJUaGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbjpcIiwgc2VsZWN0SWQudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUVudGl0aWVzQXJyYXkoZW50aXRpZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGVudGl0aWVzKSkge1xuICAgIGVudGl0aWVzID0gT2JqZWN0LnZhbHVlcyhlbnRpdGllcyk7XG4gIH1cbiAgcmV0dXJuIGVudGl0aWVzO1xufVxuZnVuY3Rpb24gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKSB7XG4gIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gIGNvbnN0IGFkZGVkID0gW107XG4gIGNvbnN0IHVwZGF0ZWQgPSBbXTtcbiAgZm9yIChjb25zdCBlbnRpdHkgb2YgbmV3RW50aXRpZXMpIHtcbiAgICBjb25zdCBpZCA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XG4gICAgaWYgKGlkIGluIHN0YXRlLmVudGl0aWVzKSB7XG4gICAgICB1cGRhdGVkLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgY2hhbmdlczogZW50aXR5XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkZWQucHVzaChlbnRpdHkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2FkZGVkLCB1cGRhdGVkXTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3Vuc29ydGVkX3N0YXRlX2FkYXB0ZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKSB7XG4gIGZ1bmN0aW9uIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIGNvbnN0IGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XG4gICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGF0ZS5pZHMucHVzaChrZXkpO1xuICAgIHN0YXRlLmVudGl0aWVzW2tleV0gPSBlbnRpdHk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBuZXdFbnRpdGllcykge1xuICAgICAgYWRkT25lTXV0YWJseShlbnRpdHksIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XG4gICAgY29uc3Qga2V5ID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcbiAgICBpZiAoIShrZXkgaW4gc3RhdGUuZW50aXRpZXMpKSB7XG4gICAgICBzdGF0ZS5pZHMucHVzaChrZXkpO1xuICAgIH1cbiAgICA7XG4gICAgc3RhdGUuZW50aXRpZXNba2V5XSA9IGVudGl0eTtcbiAgfVxuICBmdW5jdGlvbiBzZXRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIG5ld0VudGl0aWVzKSB7XG4gICAgICBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRBbGxNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgc3RhdGUuaWRzID0gW107XG4gICAgc3RhdGUuZW50aXRpZXMgPSB7fTtcbiAgICBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU9uZU11dGFibHkoa2V5LCBzdGF0ZSkge1xuICAgIHJldHVybiByZW1vdmVNYW55TXV0YWJseShba2V5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU1hbnlNdXRhYmx5KGtleXMsIHN0YXRlKSB7XG4gICAgbGV0IGRpZE11dGF0ZSA9IGZhbHNlO1xuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoa2V5IGluIHN0YXRlLmVudGl0aWVzKSB7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1trZXldO1xuICAgICAgICBkaWRNdXRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChkaWRNdXRhdGUpIHtcbiAgICAgIHN0YXRlLmlkcyA9IHN0YXRlLmlkcy5maWx0ZXIoKGlkKSA9PiBpZCBpbiBzdGF0ZS5lbnRpdGllcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZUFsbE11dGFibHkoc3RhdGUpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLCB7XG4gICAgICBpZHM6IFtdLFxuICAgICAgZW50aXRpZXM6IHt9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdGFrZU5ld0tleShrZXlzLCB1cGRhdGUsIHN0YXRlKSB7XG4gICAgY29uc3Qgb3JpZ2luYWwzID0gc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcbiAgICBpZiAob3JpZ2luYWwzID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlZCA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWdpbmFsMywgdXBkYXRlLmNoYW5nZXMpO1xuICAgIGNvbnN0IG5ld0tleSA9IHNlbGVjdElkVmFsdWUodXBkYXRlZCwgc2VsZWN0SWQpO1xuICAgIGNvbnN0IGhhc05ld0tleSA9IG5ld0tleSAhPT0gdXBkYXRlLmlkO1xuICAgIGlmIChoYXNOZXdLZXkpIHtcbiAgICAgIGtleXNbdXBkYXRlLmlkXSA9IG5ld0tleTtcbiAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xuICAgIH1cbiAgICA7XG4gICAgc3RhdGUuZW50aXRpZXNbbmV3S2V5XSA9IHVwZGF0ZWQ7XG4gICAgcmV0dXJuIGhhc05ld0tleTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVzLCBzdGF0ZSkge1xuICAgIGNvbnN0IG5ld0tleXMgPSB7fTtcbiAgICBjb25zdCB1cGRhdGVzUGVyRW50aXR5ID0ge307XG4gICAgdXBkYXRlcy5mb3JFYWNoKCh1cGRhdGUpID0+IHtcbiAgICAgIGlmICh1cGRhdGUuaWQgaW4gc3RhdGUuZW50aXRpZXMpIHtcbiAgICAgICAgdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdID0ge1xuICAgICAgICAgIGlkOiB1cGRhdGUuaWQsXG4gICAgICAgICAgLy8gU3ByZWFkcyBpZ25vcmUgZmFsc3kgdmFsdWVzLCBzbyB0aGlzIHdvcmtzIGV2ZW4gaWYgdGhlcmUgaXNuJ3RcbiAgICAgICAgICAvLyBhbiBleGlzdGluZyB1cGRhdGUgYWxyZWFkeSBhdCB0aGlzIGtleVxuICAgICAgICAgIGNoYW5nZXM6IHtcbiAgICAgICAgICAgIC4uLnVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXSA/IHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXS5jaGFuZ2VzIDogbnVsbCxcbiAgICAgICAgICAgIC4uLnVwZGF0ZS5jaGFuZ2VzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVwZGF0ZXMgPSBPYmplY3QudmFsdWVzKHVwZGF0ZXNQZXJFbnRpdHkpO1xuICAgIGNvbnN0IGRpZE11dGF0ZUVudGl0aWVzID0gdXBkYXRlcy5sZW5ndGggPiAwO1xuICAgIGlmIChkaWRNdXRhdGVFbnRpdGllcykge1xuICAgICAgY29uc3QgZGlkTXV0YXRlSWRzID0gdXBkYXRlcy5maWx0ZXIoKHVwZGF0ZSkgPT4gdGFrZU5ld0tleShuZXdLZXlzLCB1cGRhdGUsIHN0YXRlKSkubGVuZ3RoID4gMDtcbiAgICAgIGlmIChkaWRNdXRhdGVJZHMpIHtcbiAgICAgICAgc3RhdGUuaWRzID0gT2JqZWN0LnZhbHVlcyhzdGF0ZS5lbnRpdGllcykubWFwKChlKSA9PiBzZWxlY3RJZFZhbHVlKGUsIHNlbGVjdElkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIGNvbnN0IFthZGRlZCwgdXBkYXRlZF0gPSBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpO1xuICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcbiAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVtb3ZlQWxsOiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IocmVtb3ZlQWxsTXV0YWJseSksXG4gICAgYWRkT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE9uZU11dGFibHkpLFxuICAgIGFkZE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkTWFueU11dGFibHkpLFxuICAgIHNldE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRPbmVNdXRhYmx5KSxcbiAgICBzZXRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE1hbnlNdXRhYmx5KSxcbiAgICBzZXRBbGw6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0QWxsTXV0YWJseSksXG4gICAgdXBkYXRlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU9uZU11dGFibHkpLFxuICAgIHVwZGF0ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlTWFueU11dGFibHkpLFxuICAgIHVwc2VydE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRPbmVNdXRhYmx5KSxcbiAgICB1cHNlcnRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE1hbnlNdXRhYmx5KSxcbiAgICByZW1vdmVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IocmVtb3ZlT25lTXV0YWJseSksXG4gICAgcmVtb3ZlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihyZW1vdmVNYW55TXV0YWJseSlcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3NvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQsIHNvcnQpIHtcbiAgY29uc3Qge1xuICAgIHJlbW92ZU9uZSxcbiAgICByZW1vdmVNYW55LFxuICAgIHJlbW92ZUFsbFxuICB9ID0gY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpO1xuICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gYWRkTWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIGNvbnN0IG1vZGVscyA9IG5ld0VudGl0aWVzLmZpbHRlcigobW9kZWwpID0+ICEoc2VsZWN0SWRWYWx1ZShtb2RlbCwgc2VsZWN0SWQpIGluIHN0YXRlLmVudGl0aWVzKSk7XG4gICAgaWYgKG1vZGVscy5sZW5ndGggIT09IDApIHtcbiAgICAgIG1lcmdlKG1vZGVscywgc3RhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gc2V0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiBzZXRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIGlmIChuZXdFbnRpdGllcy5sZW5ndGggIT09IDApIHtcbiAgICAgIG1lcmdlKG5ld0VudGl0aWVzLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldEFsbE11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBzdGF0ZS5lbnRpdGllcyA9IHt9O1xuICAgIHN0YXRlLmlkcyA9IFtdO1xuICAgIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlT25lTXV0YWJseSh1cGRhdGUsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZU1hbnlNdXRhYmx5KFt1cGRhdGVdLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlTWFueU11dGFibHkodXBkYXRlcywgc3RhdGUpIHtcbiAgICBsZXQgYXBwbGllZFVwZGF0ZXMgPSBmYWxzZTtcbiAgICBmb3IgKGxldCB1cGRhdGUgb2YgdXBkYXRlcykge1xuICAgICAgY29uc3QgZW50aXR5ID0gc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcbiAgICAgIGlmICghZW50aXR5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYXBwbGllZFVwZGF0ZXMgPSB0cnVlO1xuICAgICAgT2JqZWN0LmFzc2lnbihlbnRpdHksIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgIGNvbnN0IG5ld0lkID0gc2VsZWN0SWQoZW50aXR5KTtcbiAgICAgIGlmICh1cGRhdGUuaWQgIT09IG5ld0lkKSB7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xuICAgICAgICBzdGF0ZS5lbnRpdGllc1tuZXdJZF0gPSBlbnRpdHk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhcHBsaWVkVXBkYXRlcykge1xuICAgICAgcmVzb3J0RW50aXRpZXMoc3RhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cHNlcnRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBzZXJ0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cHNlcnRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBjb25zdCBbYWRkZWQsIHVwZGF0ZWRdID0gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKTtcbiAgICB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVkLCBzdGF0ZSk7XG4gICAgYWRkTWFueU11dGFibHkoYWRkZWQsIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiBhcmVBcnJheXNFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoICYmIGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSA9PT0gYltpXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2UobW9kZWxzLCBzdGF0ZSkge1xuICAgIG1vZGVscy5mb3JFYWNoKChtb2RlbCkgPT4ge1xuICAgICAgO1xuICAgICAgc3RhdGUuZW50aXRpZXNbc2VsZWN0SWQobW9kZWwpXSA9IG1vZGVsO1xuICAgIH0pO1xuICAgIHJlc29ydEVudGl0aWVzKHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiByZXNvcnRFbnRpdGllcyhzdGF0ZSkge1xuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gT2JqZWN0LnZhbHVlcyhzdGF0ZS5lbnRpdGllcyk7XG4gICAgYWxsRW50aXRpZXMuc29ydChzb3J0KTtcbiAgICBjb25zdCBuZXdTb3J0ZWRJZHMgPSBhbGxFbnRpdGllcy5tYXAoc2VsZWN0SWQpO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkc1xuICAgIH0gPSBzdGF0ZTtcbiAgICBpZiAoIWFyZUFycmF5c0VxdWFsKGlkcywgbmV3U29ydGVkSWRzKSkge1xuICAgICAgc3RhdGUuaWRzID0gbmV3U29ydGVkSWRzO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHJlbW92ZU9uZSxcbiAgICByZW1vdmVNYW55LFxuICAgIHJlbW92ZUFsbCxcbiAgICBhZGRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkT25lTXV0YWJseSksXG4gICAgdXBkYXRlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU9uZU11dGFibHkpLFxuICAgIHVwc2VydE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRPbmVNdXRhYmx5KSxcbiAgICBzZXRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0T25lTXV0YWJseSksXG4gICAgc2V0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRNYW55TXV0YWJseSksXG4gICAgc2V0QWxsOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldEFsbE11dGFibHkpLFxuICAgIGFkZE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkTWFueU11dGFibHkpLFxuICAgIHVwZGF0ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlTWFueU11dGFibHkpLFxuICAgIHVwc2VydE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0TWFueU11dGFibHkpXG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy9jcmVhdGVfYWRhcHRlci50c1xuZnVuY3Rpb24gY3JlYXRlRW50aXR5QWRhcHRlcihvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHNlbGVjdElkLFxuICAgIHNvcnRDb21wYXJlclxuICB9ID0ge1xuICAgIHNvcnRDb21wYXJlcjogZmFsc2UsXG4gICAgc2VsZWN0SWQ6IChpbnN0YW5jZSkgPT4gaW5zdGFuY2UuaWQsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBzdGF0ZUFkYXB0ZXIgPSBzb3J0Q29tcGFyZXIgPyBjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQsIHNvcnRDb21wYXJlcikgOiBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCk7XG4gIGNvbnN0IHN0YXRlRmFjdG9yeSA9IGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3Rvcnkoc3RhdGVBZGFwdGVyKTtcbiAgY29uc3Qgc2VsZWN0b3JzRmFjdG9yeSA9IGNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkoKTtcbiAgcmV0dXJuIHtcbiAgICBzZWxlY3RJZCxcbiAgICBzb3J0Q29tcGFyZXIsXG4gICAgLi4uc3RhdGVGYWN0b3J5LFxuICAgIC4uLnNlbGVjdG9yc0ZhY3RvcnksXG4gICAgLi4uc3RhdGVBZGFwdGVyXG4gIH07XG59XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvaW5kZXgudHNcbmltcG9ydCB7IGlzQWN0aW9uIGFzIGlzQWN0aW9uMyB9IGZyb20gXCJyZWR1eFwiO1xuXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL2V4Y2VwdGlvbnMudHNcbnZhciB0YXNrID0gXCJ0YXNrXCI7XG52YXIgbGlzdGVuZXIgPSBcImxpc3RlbmVyXCI7XG52YXIgY29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcbnZhciBjYW5jZWxsZWQgPSBcImNhbmNlbGxlZFwiO1xudmFyIHRhc2tDYW5jZWxsZWQgPSBgdGFzay0ke2NhbmNlbGxlZH1gO1xudmFyIHRhc2tDb21wbGV0ZWQgPSBgdGFzay0ke2NvbXBsZXRlZH1gO1xudmFyIGxpc3RlbmVyQ2FuY2VsbGVkID0gYCR7bGlzdGVuZXJ9LSR7Y2FuY2VsbGVkfWA7XG52YXIgbGlzdGVuZXJDb21wbGV0ZWQgPSBgJHtsaXN0ZW5lcn0tJHtjb21wbGV0ZWR9YDtcbnZhciBUYXNrQWJvcnRFcnJvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29kZSkge1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5tZXNzYWdlID0gYCR7dGFza30gJHtjYW5jZWxsZWR9IChyZWFzb246ICR7Y29kZX0pYDtcbiAgfVxuICBuYW1lID0gXCJUYXNrQWJvcnRFcnJvclwiO1xuICBtZXNzYWdlO1xufTtcblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS91dGlscy50c1xudmFyIGFzc2VydEZ1bmN0aW9uID0gKGZ1bmMsIGV4cGVjdGVkKSA9PiB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzIpIDogYCR7ZXhwZWN0ZWR9IGlzIG5vdCBhIGZ1bmN0aW9uYCk7XG4gIH1cbn07XG52YXIgbm9vcDIgPSAoKSA9PiB7XG59O1xudmFyIGNhdGNoUmVqZWN0aW9uID0gKHByb21pc2UsIG9uRXJyb3IgPSBub29wMikgPT4ge1xuICBwcm9taXNlLmNhdGNoKG9uRXJyb3IpO1xuICByZXR1cm4gcHJvbWlzZTtcbn07XG52YXIgYWRkQWJvcnRTaWduYWxMaXN0ZW5lciA9IChhYm9ydFNpZ25hbCwgY2FsbGJhY2spID0+IHtcbiAgYWJvcnRTaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGNhbGxiYWNrLCB7XG4gICAgb25jZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuICgpID0+IGFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYWxsYmFjayk7XG59O1xudmFyIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24gPSAoYWJvcnRDb250cm9sbGVyLCByZWFzb24pID0+IHtcbiAgY29uc3Qgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKFwicmVhc29uXCIgaW4gc2lnbmFsKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaWduYWwsIFwicmVhc29uXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogcmVhc29uLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICA7XG4gIGFib3J0Q29udHJvbGxlci5hYm9ydChyZWFzb24pO1xufTtcblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS90YXNrLnRzXG52YXIgdmFsaWRhdGVBY3RpdmUgPSAoc2lnbmFsKSA9PiB7XG4gIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlYXNvblxuICAgIH0gPSBzaWduYWw7XG4gICAgdGhyb3cgbmV3IFRhc2tBYm9ydEVycm9yKHJlYXNvbik7XG4gIH1cbn07XG5mdW5jdGlvbiByYWNlV2l0aFNpZ25hbChzaWduYWwsIHByb21pc2UpIHtcbiAgbGV0IGNsZWFudXAgPSBub29wMjtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBub3RpZnlSZWplY3Rpb24gPSAoKSA9PiByZWplY3QobmV3IFRhc2tBYm9ydEVycm9yKHNpZ25hbC5yZWFzb24pKTtcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIG5vdGlmeVJlamVjdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhbnVwID0gYWRkQWJvcnRTaWduYWxMaXN0ZW5lcihzaWduYWwsIG5vdGlmeVJlamVjdGlvbik7XG4gICAgcHJvbWlzZS5maW5hbGx5KCgpID0+IGNsZWFudXAoKSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICBjbGVhbnVwID0gbm9vcDI7XG4gIH0pO1xufVxudmFyIHJ1blRhc2sgPSBhc3luYyAodGFzazIsIGNsZWFuVXApID0+IHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRhc2syKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogXCJva1wiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IGVycm9yIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IgPyBcImNhbmNlbGxlZFwiIDogXCJyZWplY3RlZFwiLFxuICAgICAgZXJyb3JcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIGNsZWFuVXA/LigpO1xuICB9XG59O1xudmFyIGNyZWF0ZVBhdXNlID0gKHNpZ25hbCkgPT4ge1xuICByZXR1cm4gKHByb21pc2UpID0+IHtcbiAgICByZXR1cm4gY2F0Y2hSZWplY3Rpb24ocmFjZVdpdGhTaWduYWwoc2lnbmFsLCBwcm9taXNlKS50aGVuKChvdXRwdXQpID0+IHtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pKTtcbiAgfTtcbn07XG52YXIgY3JlYXRlRGVsYXkgPSAoc2lnbmFsKSA9PiB7XG4gIGNvbnN0IHBhdXNlID0gY3JlYXRlUGF1c2Uoc2lnbmFsKTtcbiAgcmV0dXJuICh0aW1lb3V0TXMpID0+IHtcbiAgICByZXR1cm4gcGF1c2UobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dE1zKSkpO1xuICB9O1xufTtcblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS9pbmRleC50c1xudmFyIHtcbiAgYXNzaWduXG59ID0gT2JqZWN0O1xudmFyIElOVEVSTkFMX05JTF9UT0tFTiA9IHt9O1xudmFyIGFsbSA9IFwibGlzdGVuZXJNaWRkbGV3YXJlXCI7XG52YXIgY3JlYXRlRm9yayA9IChwYXJlbnRBYm9ydFNpZ25hbCwgcGFyZW50QmxvY2tpbmdQcm9taXNlcykgPT4ge1xuICBjb25zdCBsaW5rQ29udHJvbGxlcnMgPSAoY29udHJvbGxlcikgPT4gYWRkQWJvcnRTaWduYWxMaXN0ZW5lcihwYXJlbnRBYm9ydFNpZ25hbCwgKCkgPT4gYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBwYXJlbnRBYm9ydFNpZ25hbC5yZWFzb24pKTtcbiAgcmV0dXJuICh0YXNrRXhlY3V0b3IsIG9wdHMpID0+IHtcbiAgICBhc3NlcnRGdW5jdGlvbih0YXNrRXhlY3V0b3IsIFwidGFza0V4ZWN1dG9yXCIpO1xuICAgIGNvbnN0IGNoaWxkQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxpbmtDb250cm9sbGVycyhjaGlsZEFib3J0Q29udHJvbGxlcik7XG4gICAgY29uc3QgcmVzdWx0ID0gcnVuVGFzayhhc3luYyAoKSA9PiB7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShwYXJlbnRBYm9ydFNpZ25hbCk7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IHRhc2tFeGVjdXRvcih7XG4gICAgICAgIHBhdXNlOiBjcmVhdGVQYXVzZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICBkZWxheTogY3JlYXRlRGVsYXkoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgc2lnbmFsOiBjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICAgIH0pO1xuICAgICAgdmFsaWRhdGVBY3RpdmUoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH0sICgpID0+IGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY2hpbGRBYm9ydENvbnRyb2xsZXIsIHRhc2tDb21wbGV0ZWQpKTtcbiAgICBpZiAob3B0cz8uYXV0b0pvaW4pIHtcbiAgICAgIHBhcmVudEJsb2NraW5nUHJvbWlzZXMucHVzaChyZXN1bHQuY2F0Y2gobm9vcDIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogY3JlYXRlUGF1c2UocGFyZW50QWJvcnRTaWduYWwpKHJlc3VsdCksXG4gICAgICBjYW5jZWwoKSB7XG4gICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY2hpbGRBYm9ydENvbnRyb2xsZXIsIHRhc2tDYW5jZWxsZWQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59O1xudmFyIGNyZWF0ZVRha2VQYXR0ZXJuID0gKHN0YXJ0TGlzdGVuaW5nLCBzaWduYWwpID0+IHtcbiAgY29uc3QgdGFrZSA9IGFzeW5jIChwcmVkaWNhdGUsIHRpbWVvdXQpID0+IHtcbiAgICB2YWxpZGF0ZUFjdGl2ZShzaWduYWwpO1xuICAgIGxldCB1bnN1YnNjcmliZSA9ICgpID0+IHtcbiAgICB9O1xuICAgIGNvbnN0IHR1cGxlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBzdG9wTGlzdGVuaW5nID0gc3RhcnRMaXN0ZW5pbmcoe1xuICAgICAgICBwcmVkaWNhdGUsXG4gICAgICAgIGVmZmVjdDogKGFjdGlvbiwgbGlzdGVuZXJBcGkpID0+IHtcbiAgICAgICAgICBsaXN0ZW5lckFwaS51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHJlc29sdmUoW2FjdGlvbiwgbGlzdGVuZXJBcGkuZ2V0U3RhdGUoKSwgbGlzdGVuZXJBcGkuZ2V0T3JpZ2luYWxTdGF0ZSgpXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgICAgIHN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgICAgcmVqZWN0KCk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHByb21pc2VzID0gW3R1cGxlUHJvbWlzZV07XG4gICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0LCBudWxsKSkpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgcmFjZVdpdGhTaWduYWwoc2lnbmFsLCBQcm9taXNlLnJhY2UocHJvbWlzZXMpKTtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIChwcmVkaWNhdGUsIHRpbWVvdXQpID0+IGNhdGNoUmVqZWN0aW9uKHRha2UocHJlZGljYXRlLCB0aW1lb3V0KSk7XG59O1xudmFyIGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20gPSAob3B0aW9ucykgPT4ge1xuICBsZXQge1xuICAgIHR5cGUsXG4gICAgYWN0aW9uQ3JlYXRvcixcbiAgICBtYXRjaGVyLFxuICAgIHByZWRpY2F0ZSxcbiAgICBlZmZlY3RcbiAgfSA9IG9wdGlvbnM7XG4gIGlmICh0eXBlKSB7XG4gICAgcHJlZGljYXRlID0gY3JlYXRlQWN0aW9uKHR5cGUpLm1hdGNoO1xuICB9IGVsc2UgaWYgKGFjdGlvbkNyZWF0b3IpIHtcbiAgICB0eXBlID0gYWN0aW9uQ3JlYXRvci50eXBlO1xuICAgIHByZWRpY2F0ZSA9IGFjdGlvbkNyZWF0b3IubWF0Y2g7XG4gIH0gZWxzZSBpZiAobWF0Y2hlcikge1xuICAgIHByZWRpY2F0ZSA9IG1hdGNoZXI7XG4gIH0gZWxzZSBpZiAocHJlZGljYXRlKSB7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjEpIDogXCJDcmVhdGluZyBvciByZW1vdmluZyBhIGxpc3RlbmVyIHJlcXVpcmVzIG9uZSBvZiB0aGUga25vd24gZmllbGRzIGZvciBtYXRjaGluZyBhbiBhY3Rpb25cIik7XG4gIH1cbiAgYXNzZXJ0RnVuY3Rpb24oZWZmZWN0LCBcIm9wdGlvbnMubGlzdGVuZXJcIik7XG4gIHJldHVybiB7XG4gICAgcHJlZGljYXRlLFxuICAgIHR5cGUsXG4gICAgZWZmZWN0XG4gIH07XG59O1xudmFyIGNyZWF0ZUxpc3RlbmVyRW50cnkgPSBPYmplY3QuYXNzaWduKChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIHByZWRpY2F0ZSxcbiAgICBlZmZlY3RcbiAgfSA9IGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20ob3B0aW9ucyk7XG4gIGNvbnN0IGlkID0gbmFub2lkKCk7XG4gIGNvbnN0IGVudHJ5ID0ge1xuICAgIGlkLFxuICAgIGVmZmVjdCxcbiAgICB0eXBlLFxuICAgIHByZWRpY2F0ZSxcbiAgICBwZW5kaW5nOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyMikgOiBcIlVuc3Vic2NyaWJlIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBlbnRyeTtcbn0sIHtcbiAgd2l0aFR5cGVzOiAoKSA9PiBjcmVhdGVMaXN0ZW5lckVudHJ5XG59KTtcbnZhciBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMgPSAoZW50cnkpID0+IHtcbiAgZW50cnkucGVuZGluZy5mb3JFYWNoKChjb250cm9sbGVyKSA9PiB7XG4gICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XG4gIH0pO1xufTtcbnZhciBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZSA9IChsaXN0ZW5lck1hcCkgPT4ge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxpc3RlbmVyTWFwLmZvckVhY2goY2FuY2VsQWN0aXZlTGlzdGVuZXJzKTtcbiAgICBsaXN0ZW5lck1hcC5jbGVhcigpO1xuICB9O1xufTtcbnZhciBzYWZlbHlOb3RpZnlFcnJvciA9IChlcnJvckhhbmRsZXIsIGVycm9yVG9Ob3RpZnksIGVycm9ySW5mbykgPT4ge1xuICB0cnkge1xuICAgIGVycm9ySGFuZGxlcihlcnJvclRvTm90aWZ5LCBlcnJvckluZm8pO1xuICB9IGNhdGNoIChlcnJvckhhbmRsZXJFcnJvcikge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhyb3cgZXJyb3JIYW5kbGVyRXJyb3I7XG4gICAgfSwgMCk7XG4gIH1cbn07XG52YXIgYWRkTGlzdGVuZXIgPSBPYmplY3QuYXNzaWduKGNyZWF0ZUFjdGlvbihgJHthbG19L2FkZGApLCB7XG4gIHdpdGhUeXBlczogKCkgPT4gYWRkTGlzdGVuZXJcbn0pO1xudmFyIGNsZWFyQWxsTGlzdGVuZXJzID0gY3JlYXRlQWN0aW9uKGAke2FsbX0vcmVtb3ZlQWxsYCk7XG52YXIgcmVtb3ZlTGlzdGVuZXIgPSBPYmplY3QuYXNzaWduKGNyZWF0ZUFjdGlvbihgJHthbG19L3JlbW92ZWApLCB7XG4gIHdpdGhUeXBlczogKCkgPT4gcmVtb3ZlTGlzdGVuZXJcbn0pO1xudmFyIGRlZmF1bHRFcnJvckhhbmRsZXIgPSAoLi4uYXJncykgPT4ge1xuICBjb25zb2xlLmVycm9yKGAke2FsbX0vZXJyb3JgLCAuLi5hcmdzKTtcbn07XG52YXIgY3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlID0gKG1pZGRsZXdhcmVPcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgbGlzdGVuZXJNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCB7XG4gICAgZXh0cmEsXG4gICAgb25FcnJvciA9IGRlZmF1bHRFcnJvckhhbmRsZXJcbiAgfSA9IG1pZGRsZXdhcmVPcHRpb25zO1xuICBhc3NlcnRGdW5jdGlvbihvbkVycm9yLCBcIm9uRXJyb3JcIik7XG4gIGNvbnN0IGluc2VydEVudHJ5ID0gKGVudHJ5KSA9PiB7XG4gICAgZW50cnkudW5zdWJzY3JpYmUgPSAoKSA9PiBsaXN0ZW5lck1hcC5kZWxldGUoZW50cnkuaWQpO1xuICAgIGxpc3RlbmVyTWFwLnNldChlbnRyeS5pZCwgZW50cnkpO1xuICAgIHJldHVybiAoY2FuY2VsT3B0aW9ucykgPT4ge1xuICAgICAgZW50cnkudW5zdWJzY3JpYmUoKTtcbiAgICAgIGlmIChjYW5jZWxPcHRpb25zPy5jYW5jZWxBY3RpdmUpIHtcbiAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzKGVudHJ5KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBjb25zdCBzdGFydExpc3RlbmluZyA9IChvcHRpb25zKSA9PiB7XG4gICAgbGV0IGVudHJ5ID0gZmluZChBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKSwgKGV4aXN0aW5nRW50cnkpID0+IGV4aXN0aW5nRW50cnkuZWZmZWN0ID09PSBvcHRpb25zLmVmZmVjdCk7XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgZW50cnkgPSBjcmVhdGVMaXN0ZW5lckVudHJ5KG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zZXJ0RW50cnkoZW50cnkpO1xuICB9O1xuICBPYmplY3QuYXNzaWduKHN0YXJ0TGlzdGVuaW5nLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiBzdGFydExpc3RlbmluZ1xuICB9KTtcbiAgY29uc3Qgc3RvcExpc3RlbmluZyA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIGVmZmVjdCxcbiAgICAgIHByZWRpY2F0ZVxuICAgIH0gPSBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tKG9wdGlvbnMpO1xuICAgIGNvbnN0IGVudHJ5ID0gZmluZChBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKSwgKGVudHJ5MikgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hQcmVkaWNhdGVPclR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIiA/IGVudHJ5Mi50eXBlID09PSB0eXBlIDogZW50cnkyLnByZWRpY2F0ZSA9PT0gcHJlZGljYXRlO1xuICAgICAgcmV0dXJuIG1hdGNoUHJlZGljYXRlT3JUeXBlICYmIGVudHJ5Mi5lZmZlY3QgPT09IGVmZmVjdDtcbiAgICB9KTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnVuc3Vic2NyaWJlKCk7XG4gICAgICBpZiAob3B0aW9ucy5jYW5jZWxBY3RpdmUpIHtcbiAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzKGVudHJ5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICEhZW50cnk7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3RvcExpc3RlbmluZywge1xuICAgIHdpdGhUeXBlczogKCkgPT4gc3RvcExpc3RlbmluZ1xuICB9KTtcbiAgY29uc3Qgbm90aWZ5TGlzdGVuZXIgPSBhc3luYyAoZW50cnksIGFjdGlvbiwgYXBpLCBnZXRPcmlnaW5hbFN0YXRlKSA9PiB7XG4gICAgY29uc3QgaW50ZXJuYWxUYXNrQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCB0YWtlID0gY3JlYXRlVGFrZVBhdHRlcm4oc3RhcnRMaXN0ZW5pbmcsIGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICBjb25zdCBhdXRvSm9pblByb21pc2VzID0gW107XG4gICAgdHJ5IHtcbiAgICAgIGVudHJ5LnBlbmRpbmcuYWRkKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKGVudHJ5LmVmZmVjdChcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICAvLyBVc2UgYXNzaWduKCkgcmF0aGVyIHRoYW4gLi4uIHRvIGF2b2lkIGV4dHJhIGhlbHBlciBmdW5jdGlvbnMgYWRkZWQgdG8gYnVuZGxlXG4gICAgICAgIGFzc2lnbih7fSwgYXBpLCB7XG4gICAgICAgICAgZ2V0T3JpZ2luYWxTdGF0ZSxcbiAgICAgICAgICBjb25kaXRpb246IChwcmVkaWNhdGUsIHRpbWVvdXQpID0+IHRha2UocHJlZGljYXRlLCB0aW1lb3V0KS50aGVuKEJvb2xlYW4pLFxuICAgICAgICAgIHRha2UsXG4gICAgICAgICAgZGVsYXk6IGNyZWF0ZURlbGF5KGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgICBwYXVzZTogY3JlYXRlUGF1c2UoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICAgIGV4dHJhLFxuICAgICAgICAgIHNpZ25hbDogaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgZm9yazogY3JlYXRlRm9yayhpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCwgYXV0b0pvaW5Qcm9taXNlcyksXG4gICAgICAgICAgdW5zdWJzY3JpYmU6IGVudHJ5LnVuc3Vic2NyaWJlLFxuICAgICAgICAgIHN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXJNYXAuc2V0KGVudHJ5LmlkLCBlbnRyeSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnM6ICgpID0+IHtcbiAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZm9yRWFjaCgoY29udHJvbGxlciwgXywgc2V0KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChjb250cm9sbGVyICE9PSBpbnRlcm5hbFRhc2tDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XG4gICAgICAgICAgICAgICAgc2V0LmRlbGV0ZShjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oaW50ZXJuYWxUYXNrQ29udHJvbGxlciwgbGlzdGVuZXJDYW5jZWxsZWQpO1xuICAgICAgICAgICAgZW50cnkucGVuZGluZy5kZWxldGUoaW50ZXJuYWxUYXNrQ29udHJvbGxlcik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkOiAoKSA9PiB7XG4gICAgICAgICAgICB2YWxpZGF0ZUFjdGl2ZShpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKSk7XG4gICAgfSBjYXRjaCAobGlzdGVuZXJFcnJvcikge1xuICAgICAgaWYgKCEobGlzdGVuZXJFcnJvciBpbnN0YW5jZW9mIFRhc2tBYm9ydEVycm9yKSkge1xuICAgICAgICBzYWZlbHlOb3RpZnlFcnJvcihvbkVycm9yLCBsaXN0ZW5lckVycm9yLCB7XG4gICAgICAgICAgcmFpc2VkQnk6IFwiZWZmZWN0XCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGF1dG9Kb2luUHJvbWlzZXMpO1xuICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihpbnRlcm5hbFRhc2tDb250cm9sbGVyLCBsaXN0ZW5lckNvbXBsZXRlZCk7XG4gICAgICBlbnRyeS5wZW5kaW5nLmRlbGV0ZShpbnRlcm5hbFRhc2tDb250cm9sbGVyKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlID0gY3JlYXRlQ2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUobGlzdGVuZXJNYXApO1xuICBjb25zdCBtaWRkbGV3YXJlID0gKGFwaSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICBpZiAoIWlzQWN0aW9uMyhhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgIH1cbiAgICBpZiAoYWRkTGlzdGVuZXIubWF0Y2goYWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHN0YXJ0TGlzdGVuaW5nKGFjdGlvbi5wYXlsb2FkKTtcbiAgICB9XG4gICAgaWYgKGNsZWFyQWxsTGlzdGVuZXJzLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZW1vdmVMaXN0ZW5lci5tYXRjaChhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gc3RvcExpc3RlbmluZyhhY3Rpb24ucGF5bG9hZCk7XG4gICAgfVxuICAgIGxldCBvcmlnaW5hbFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgY29uc3QgZ2V0T3JpZ2luYWxTdGF0ZSA9ICgpID0+IHtcbiAgICAgIGlmIChvcmlnaW5hbFN0YXRlID09PSBJTlRFUk5BTF9OSUxfVE9LRU4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjMpIDogYCR7YWxtfTogZ2V0T3JpZ2luYWxTdGF0ZSBjYW4gb25seSBiZSBjYWxsZWQgc3luY2hyb25vdXNseWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsU3RhdGU7XG4gICAgfTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBuZXh0KGFjdGlvbik7XG4gICAgICBpZiAobGlzdGVuZXJNYXAuc2l6ZSA+IDApIHtcbiAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyRW50cmllcyA9IEFycmF5LmZyb20obGlzdGVuZXJNYXAudmFsdWVzKCkpO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGxpc3RlbmVyRW50cmllcykge1xuICAgICAgICAgIGxldCBydW5MaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBydW5MaXN0ZW5lciA9IGVudHJ5LnByZWRpY2F0ZShhY3Rpb24sIGN1cnJlbnRTdGF0ZSwgb3JpZ2luYWxTdGF0ZSk7XG4gICAgICAgICAgfSBjYXRjaCAocHJlZGljYXRlRXJyb3IpIHtcbiAgICAgICAgICAgIHJ1bkxpc3RlbmVyID0gZmFsc2U7XG4gICAgICAgICAgICBzYWZlbHlOb3RpZnlFcnJvcihvbkVycm9yLCBwcmVkaWNhdGVFcnJvciwge1xuICAgICAgICAgICAgICByYWlzZWRCeTogXCJwcmVkaWNhdGVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcnVuTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub3RpZnlMaXN0ZW5lcihlbnRyeSwgYWN0aW9uLCBhcGksIGdldE9yaWdpbmFsU3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIG9yaWdpbmFsU3RhdGUgPSBJTlRFUk5BTF9OSUxfVE9LRU47XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbWlkZGxld2FyZSxcbiAgICBzdGFydExpc3RlbmluZyxcbiAgICBzdG9wTGlzdGVuaW5nLFxuICAgIGNsZWFyTGlzdGVuZXJzOiBjbGVhckxpc3RlbmVyTWlkZGxld2FyZVxuICB9O1xufTtcblxuLy8gc3JjL2R5bmFtaWNNaWRkbGV3YXJlL2luZGV4LnRzXG5pbXBvcnQgeyBjb21wb3NlIGFzIGNvbXBvc2UzIH0gZnJvbSBcInJlZHV4XCI7XG52YXIgY3JlYXRlTWlkZGxld2FyZUVudHJ5ID0gKG1pZGRsZXdhcmUpID0+ICh7XG4gIGlkOiBuYW5vaWQoKSxcbiAgbWlkZGxld2FyZSxcbiAgYXBwbGllZDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxufSk7XG52YXIgbWF0Y2hJbnN0YW5jZSA9IChpbnN0YW5jZUlkKSA9PiAoYWN0aW9uKSA9PiBhY3Rpb24/Lm1ldGE/Lmluc3RhbmNlSWQgPT09IGluc3RhbmNlSWQ7XG52YXIgY3JlYXRlRHluYW1pY01pZGRsZXdhcmUgPSAoKSA9PiB7XG4gIGNvbnN0IGluc3RhbmNlSWQgPSBuYW5vaWQoKTtcbiAgY29uc3QgbWlkZGxld2FyZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHdpdGhNaWRkbGV3YXJlID0gT2JqZWN0LmFzc2lnbihjcmVhdGVBY3Rpb24oXCJkeW5hbWljTWlkZGxld2FyZS9hZGRcIiwgKC4uLm1pZGRsZXdhcmVzKSA9PiAoe1xuICAgIHBheWxvYWQ6IG1pZGRsZXdhcmVzLFxuICAgIG1ldGE6IHtcbiAgICAgIGluc3RhbmNlSWRcbiAgICB9XG4gIH0pKSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gd2l0aE1pZGRsZXdhcmVcbiAgfSk7XG4gIGNvbnN0IGFkZE1pZGRsZXdhcmUgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIGFkZE1pZGRsZXdhcmUyKC4uLm1pZGRsZXdhcmVzKSB7XG4gICAgbWlkZGxld2FyZXMuZm9yRWFjaCgobWlkZGxld2FyZTIpID0+IHtcbiAgICAgIGxldCBlbnRyeSA9IGZpbmQoQXJyYXkuZnJvbShtaWRkbGV3YXJlTWFwLnZhbHVlcygpKSwgKGVudHJ5MikgPT4gZW50cnkyLm1pZGRsZXdhcmUgPT09IG1pZGRsZXdhcmUyKTtcbiAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgZW50cnkgPSBjcmVhdGVNaWRkbGV3YXJlRW50cnkobWlkZGxld2FyZTIpO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZU1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcbiAgICB9KTtcbiAgfSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gYWRkTWlkZGxld2FyZVxuICB9KTtcbiAgY29uc3QgZ2V0RmluYWxNaWRkbGV3YXJlID0gKGFwaSkgPT4ge1xuICAgIGNvbnN0IGFwcGxpZWRNaWRkbGV3YXJlID0gQXJyYXkuZnJvbShtaWRkbGV3YXJlTWFwLnZhbHVlcygpKS5tYXAoKGVudHJ5KSA9PiBlbXBsYWNlKGVudHJ5LmFwcGxpZWQsIGFwaSwge1xuICAgICAgaW5zZXJ0OiAoKSA9PiBlbnRyeS5taWRkbGV3YXJlKGFwaSlcbiAgICB9KSk7XG4gICAgcmV0dXJuIGNvbXBvc2UzKC4uLmFwcGxpZWRNaWRkbGV3YXJlKTtcbiAgfTtcbiAgY29uc3QgaXNXaXRoTWlkZGxld2FyZSA9IGlzQWxsT2Yod2l0aE1pZGRsZXdhcmUsIG1hdGNoSW5zdGFuY2UoaW5zdGFuY2VJZCkpO1xuICBjb25zdCBtaWRkbGV3YXJlID0gKGFwaSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICBpZiAoaXNXaXRoTWlkZGxld2FyZShhY3Rpb24pKSB7XG4gICAgICBhZGRNaWRkbGV3YXJlKC4uLmFjdGlvbi5wYXlsb2FkKTtcbiAgICAgIHJldHVybiBhcGkuZGlzcGF0Y2g7XG4gICAgfVxuICAgIHJldHVybiBnZXRGaW5hbE1pZGRsZXdhcmUoYXBpKShuZXh0KShhY3Rpb24pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmUsXG4gICAgYWRkTWlkZGxld2FyZSxcbiAgICB3aXRoTWlkZGxld2FyZSxcbiAgICBpbnN0YW5jZUlkXG4gIH07XG59O1xuXG4vLyBzcmMvY29tYmluZVNsaWNlcy50c1xuaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIGFzIGNvbWJpbmVSZWR1Y2VyczIgfSBmcm9tIFwicmVkdXhcIjtcbnZhciBpc1NsaWNlTGlrZSA9IChtYXliZVNsaWNlTGlrZSkgPT4gXCJyZWR1Y2VyUGF0aFwiIGluIG1heWJlU2xpY2VMaWtlICYmIHR5cGVvZiBtYXliZVNsaWNlTGlrZS5yZWR1Y2VyUGF0aCA9PT0gXCJzdHJpbmdcIjtcbnZhciBnZXRSZWR1Y2VycyA9IChzbGljZXMpID0+IHNsaWNlcy5mbGF0TWFwKChzbGljZU9yTWFwKSA9PiBpc1NsaWNlTGlrZShzbGljZU9yTWFwKSA/IFtbc2xpY2VPck1hcC5yZWR1Y2VyUGF0aCwgc2xpY2VPck1hcC5yZWR1Y2VyXV0gOiBPYmplY3QuZW50cmllcyhzbGljZU9yTWFwKSk7XG52YXIgT1JJR0lOQUxfU1RBVEUgPSBTeW1ib2wuZm9yKFwicnRrLXN0YXRlLXByb3h5LW9yaWdpbmFsXCIpO1xudmFyIGlzU3RhdGVQcm94eSA9ICh2YWx1ZSkgPT4gISF2YWx1ZSAmJiAhIXZhbHVlW09SSUdJTkFMX1NUQVRFXTtcbnZhciBzdGF0ZVByb3h5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgY3JlYXRlU3RhdGVQcm94eSA9IChzdGF0ZSwgcmVkdWNlck1hcCkgPT4gZW1wbGFjZShzdGF0ZVByb3h5TWFwLCBzdGF0ZSwge1xuICBpbnNlcnQ6ICgpID0+IG5ldyBQcm94eShzdGF0ZSwge1xuICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgIGlmIChwcm9wID09PSBPUklHSU5BTF9TVEFURSlcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29uc3QgcmVkdWNlciA9IHJlZHVjZXJNYXBbcHJvcC50b1N0cmluZygpXTtcbiAgICAgICAgaWYgKHJlZHVjZXIpIHtcbiAgICAgICAgICBjb25zdCByZWR1Y2VyUmVzdWx0ID0gcmVkdWNlcih2b2lkIDAsIHtcbiAgICAgICAgICAgIHR5cGU6IG5hbm9pZCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZWR1Y2VyUmVzdWx0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNCkgOiBgVGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcIiR7cHJvcC50b1N0cmluZygpfVwiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIGNhbGxlZCBmb3Igc2VsZWN0b3IoKS4gSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgeW91IGNhbiB1c2UgbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlZHVjZXJSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9KVxufSk7XG52YXIgb3JpZ2luYWwgPSAoc3RhdGUpID0+IHtcbiAgaWYgKCFpc1N0YXRlUHJveHkoc3RhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjUpIDogXCJvcmlnaW5hbCBtdXN0IGJlIHVzZWQgb24gc3RhdGUgUHJveHlcIik7XG4gIH1cbiAgcmV0dXJuIHN0YXRlW09SSUdJTkFMX1NUQVRFXTtcbn07XG52YXIgbm9vcFJlZHVjZXIgPSAoc3RhdGUgPSB7fSkgPT4gc3RhdGU7XG5mdW5jdGlvbiBjb21iaW5lU2xpY2VzKC4uLnNsaWNlcykge1xuICBjb25zdCByZWR1Y2VyTWFwID0gT2JqZWN0LmZyb21FbnRyaWVzKGdldFJlZHVjZXJzKHNsaWNlcykpO1xuICBjb25zdCBnZXRSZWR1Y2VyID0gKCkgPT4gT2JqZWN0LmtleXMocmVkdWNlck1hcCkubGVuZ3RoID8gY29tYmluZVJlZHVjZXJzMihyZWR1Y2VyTWFwKSA6IG5vb3BSZWR1Y2VyO1xuICBsZXQgcmVkdWNlciA9IGdldFJlZHVjZXIoKTtcbiAgZnVuY3Rpb24gY29tYmluZWRSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICByZXR1cm4gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcbiAgfVxuICBjb21iaW5lZFJlZHVjZXIud2l0aExhenlMb2FkZWRTbGljZXMgPSAoKSA9PiBjb21iaW5lZFJlZHVjZXI7XG4gIGNvbnN0IGluamVjdCA9IChzbGljZSwgY29uZmlnID0ge30pID0+IHtcbiAgICBjb25zdCB7XG4gICAgICByZWR1Y2VyUGF0aCxcbiAgICAgIHJlZHVjZXI6IHJlZHVjZXJUb0luamVjdFxuICAgIH0gPSBzbGljZTtcbiAgICBjb25zdCBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXJNYXBbcmVkdWNlclBhdGhdO1xuICAgIGlmICghY29uZmlnLm92ZXJyaWRlRXhpc3RpbmcgJiYgY3VycmVudFJlZHVjZXIgJiYgY3VycmVudFJlZHVjZXIgIT09IHJlZHVjZXJUb0luamVjdCkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgY2FsbGVkIFxcYGluamVjdFxcYCB0byBvdmVycmlkZSBhbHJlYWR5LWV4aXN0aW5nIHJlZHVjZXIgJHtyZWR1Y2VyUGF0aH0gd2l0aG91dCBzcGVjaWZ5aW5nIFxcYG92ZXJyaWRlRXhpc3Rpbmc6IHRydWVcXGBgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21iaW5lZFJlZHVjZXI7XG4gICAgfVxuICAgIHJlZHVjZXJNYXBbcmVkdWNlclBhdGhdID0gcmVkdWNlclRvSW5qZWN0O1xuICAgIHJlZHVjZXIgPSBnZXRSZWR1Y2VyKCk7XG4gICAgcmV0dXJuIGNvbWJpbmVkUmVkdWNlcjtcbiAgfTtcbiAgY29uc3Qgc2VsZWN0b3IgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIG1ha2VTZWxlY3RvcihzZWxlY3RvckZuLCBzZWxlY3RTdGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBzZWxlY3RvcjIoc3RhdGUsIC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiBzZWxlY3RvckZuKGNyZWF0ZVN0YXRlUHJveHkoc2VsZWN0U3RhdGUgPyBzZWxlY3RTdGF0ZShzdGF0ZSwgLi4uYXJncykgOiBzdGF0ZSwgcmVkdWNlck1hcCksIC4uLmFyZ3MpO1xuICAgIH07XG4gIH0sIHtcbiAgICBvcmlnaW5hbFxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oY29tYmluZWRSZWR1Y2VyLCB7XG4gICAgaW5qZWN0LFxuICAgIHNlbGVjdG9yXG4gIH0pO1xufVxuXG4vLyBzcmMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZS50c1xuZnVuY3Rpb24gZm9ybWF0UHJvZEVycm9yTWVzc2FnZShjb2RlKSB7XG4gIHJldHVybiBgTWluaWZpZWQgUmVkdXggVG9vbGtpdCBlcnJvciAjJHtjb2RlfTsgdmlzaXQgaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9FcnJvcnM/Y29kZT0ke2NvZGV9IGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMuIGA7XG59XG5leHBvcnQge1xuICBSZWR1Y2VyVHlwZSxcbiAgU0hPVUxEX0FVVE9CQVRDSCxcbiAgVGFza0Fib3J0RXJyb3IsXG4gIFR1cGxlLFxuICBhZGRMaXN0ZW5lcixcbiAgYXN5bmNUaHVua0NyZWF0b3IsXG4gIGF1dG9CYXRjaEVuaGFuY2VyLFxuICBidWlsZENyZWF0ZVNsaWNlLFxuICBjbGVhckFsbExpc3RlbmVycyxcbiAgY29tYmluZVNsaWNlcyxcbiAgY29uZmlndXJlU3RvcmUsXG4gIGNyZWF0ZUFjdGlvbixcbiAgY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUsXG4gIGNyZWF0ZUFzeW5jVGh1bmssXG4gIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yLFxuICBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3IsXG4gIGNyZWF0ZUR5bmFtaWNNaWRkbGV3YXJlLFxuICBjcmVhdGVFbnRpdHlBZGFwdGVyLFxuICBjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUsXG4gIGNyZWF0ZUxpc3RlbmVyTWlkZGxld2FyZSxcbiAgcHJvZHVjZSBhcyBjcmVhdGVOZXh0U3RhdGUsXG4gIGNyZWF0ZVJlZHVjZXIsXG4gIGNyZWF0ZVNlbGVjdG9yLFxuICBjcmVhdGVTZWxlY3RvckNyZWF0b3IyIGFzIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcixcbiAgY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLFxuICBjcmVhdGVTbGljZSxcbiAgY3VycmVudDIgYXMgY3VycmVudCxcbiAgZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlLFxuICBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlLFxuICBmcmVlemUsXG4gIGlzQWN0aW9uQ3JlYXRvcixcbiAgaXNBbGxPZixcbiAgaXNBbnlPZixcbiAgaXNBc3luY1RodW5rQWN0aW9uLFxuICBpc0RyYWZ0NCBhcyBpc0RyYWZ0LFxuICBpc0ZTQSBhcyBpc0ZsdXhTdGFuZGFyZEFjdGlvbixcbiAgaXNGdWxmaWxsZWQsXG4gIGlzSW1tdXRhYmxlRGVmYXVsdCxcbiAgaXNQZW5kaW5nLFxuICBpc1BsYWluLFxuICBpc1JlamVjdGVkLFxuICBpc1JlamVjdGVkV2l0aFZhbHVlLFxuICBscnVNZW1vaXplLFxuICBtaW5pU2VyaWFsaXplRXJyb3IsXG4gIG5hbm9pZCxcbiAgb3JpZ2luYWwyIGFzIG9yaWdpbmFsLFxuICBwcmVwYXJlQXV0b0JhdGNoZWQsXG4gIHJlbW92ZUxpc3RlbmVyLFxuICB1bndyYXBSZXN1bHQsXG4gIHdlYWtNYXBNZW1vaXplMiBhcyB3ZWFrTWFwTWVtb2l6ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHV4LXRvb2xraXQubW9kZXJuLm1qcy5tYXAiXSwibmFtZXMiOlsicHJvZHVjZSIsImN1cnJlbnQiLCJjdXJyZW50MiIsImZyZWV6ZSIsIm9yaWdpbmFsIiwib3JpZ2luYWwyIiwiaXNEcmFmdCIsImlzRHJhZnQ0IiwiY3JlYXRlU2VsZWN0b3IiLCJjcmVhdGVTZWxlY3RvckNyZWF0b3IiLCJjcmVhdGVTZWxlY3RvckNyZWF0b3IyIiwibHJ1TWVtb2l6ZSIsIndlYWtNYXBNZW1vaXplIiwid2Vha01hcE1lbW9pemUyIiwiY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JDcmVhdG9yIiwiYXJncyIsImNyZWF0ZVNlbGVjdG9yMiIsImNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yMiIsIk9iamVjdCIsImFzc2lnbiIsImFyZ3MyIiwic2VsZWN0b3IiLCJ3cmFwcGVkU2VsZWN0b3IiLCJ2YWx1ZSIsInJlc3QiLCJ3aXRoVHlwZXMiLCJjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciIsImFwcGx5TWlkZGxld2FyZSIsImNyZWF0ZVN0b3JlIiwiY29tcG9zZSIsImNvbXBvc2UyIiwiY29tYmluZVJlZHVjZXJzIiwiaXNQbGFpbk9iamVjdCIsImlzUGxhaW5PYmplY3QyIiwiY29tcG9zZVdpdGhEZXZUb29scyIsIndpbmRvdyIsIl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFwcGx5IiwiZGV2VG9vbHNFbmhhbmNlciIsIl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18iLCJub29wMyIsInRodW5rIiwidGh1bmtNaWRkbGV3YXJlIiwid2l0aEV4dHJhQXJndW1lbnQiLCJpc0FjdGlvbiIsImhhc01hdGNoRnVuY3Rpb24iLCJ2IiwibWF0Y2giLCJjcmVhdGVBY3Rpb24iLCJ0eXBlIiwicHJlcGFyZUFjdGlvbiIsImFjdGlvbkNyZWF0b3IiLCJwcmVwYXJlZCIsIkVycm9yIiwicHJvY2VzcyIsImZvcm1hdFByb2RFcnJvck1lc3NhZ2UiLCJwYXlsb2FkIiwibWV0YSIsImVycm9yIiwidG9TdHJpbmciLCJhY3Rpb24iLCJpc0FjdGlvbkNyZWF0b3IiLCJpc0ZTQSIsImtleXMiLCJldmVyeSIsImlzVmFsaWRLZXkiLCJrZXkiLCJpbmRleE9mIiwiZ2V0TWVzc2FnZSIsInNwbGl0VHlwZSIsInNwbGl0IiwiYWN0aW9uTmFtZSIsImNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlIiwib3B0aW9ucyIsIm5leHQiLCJpc0FjdGlvbkNyZWF0b3IyIiwiY29uc29sZSIsIndhcm4iLCJjcmVhdGVOZXh0U3RhdGUiLCJpc0RyYWZ0YWJsZSIsImdldFRpbWVNZWFzdXJlVXRpbHMiLCJtYXhEZWxheSIsImZuTmFtZSIsImVsYXBzZWQiLCJtZWFzdXJlVGltZSIsImZuIiwic3RhcnRlZCIsIkRhdGUiLCJub3ciLCJmaW5pc2hlZCIsIndhcm5JZkV4Y2VlZGVkIiwiZmluZCIsIml0ZXJhYmxlIiwiY29tcGFyYXRvciIsImVudHJ5IiwiVHVwbGUiLCJfVHVwbGUiLCJBcnJheSIsImNvbnN0cnVjdG9yIiwiaXRlbXMiLCJzZXRQcm90b3R5cGVPZiIsInByb3RvdHlwZSIsIlN5bWJvbCIsInNwZWNpZXMiLCJjb25jYXQiLCJhcnIiLCJwcmVwZW5kIiwiaXNBcnJheSIsImZyZWV6ZURyYWZ0YWJsZSIsInZhbCIsImVtcGxhY2UiLCJtYXAiLCJoYW5kbGVyIiwiaGFzIiwiZ2V0IiwidXBkYXRlIiwic2V0IiwiaW5zZXJ0IiwiaW5zZXJ0ZWQiLCJpc0ltbXV0YWJsZURlZmF1bHQiLCJpc0Zyb3plbiIsInRyYWNrRm9yTXV0YXRpb25zIiwiaXNJbW11dGFibGUiLCJpZ25vcmVQYXRocyIsIm9iaiIsInRyYWNrZWRQcm9wZXJ0aWVzIiwidHJhY2tQcm9wZXJ0aWVzIiwiZGV0ZWN0TXV0YXRpb25zIiwicGF0aCIsImNoZWNrZWRPYmplY3RzIiwiU2V0IiwidHJhY2tlZCIsImFkZCIsImNoaWxkcmVuIiwiY2hpbGRQYXRoIiwiaWdub3JlZFBhdGhzIiwidHJhY2tlZFByb3BlcnR5Iiwic2FtZVBhcmVudFJlZiIsInByZXZPYmoiLCJzYW1lUmVmIiwiTnVtYmVyIiwiaXNOYU4iLCJ3YXNNdXRhdGVkIiwia2V5c1RvRGV0ZWN0IiwiaGFzSWdub3JlZFBhdGhzIiwibmVzdGVkUGF0aCIsImhhc01hdGNoZXMiLCJzb21lIiwiaWdub3JlZCIsIlJlZ0V4cCIsInRlc3QiLCJyZXN1bHQiLCJjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUiLCJzdHJpbmdpZnkyIiwic2VyaWFsaXplciIsImluZGVudCIsImRlY3ljbGVyIiwiSlNPTiIsInN0cmluZ2lmeSIsImdldFNlcmlhbGl6ZTIiLCJzdGFjayIsIl8iLCJzbGljZSIsImpvaW4iLCJ0aGlzUG9zIiwic3BsaWNlIiwicHVzaCIsIkluZmluaXR5IiwiY2FsbCIsImdldFNlcmlhbGl6ZSIsIndhcm5BZnRlciIsInRyYWNrIiwiYmluZCIsImdldFN0YXRlIiwic3RhdGUiLCJ0cmFja2VyIiwibWVhc3VyZVV0aWxzIiwiZGlzcGF0Y2hlZEFjdGlvbiIsImlzQWN0aW9uMiIsImlzUGxhaW4iLCJmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJpc1NlcmlhbGl6YWJsZSIsImdldEVudHJpZXMiLCJjYWNoZSIsImZvdW5kTmVzdGVkU2VyaWFsaXphYmxlIiwia2V5UGF0aCIsImVudHJpZXMiLCJuZXN0ZWRWYWx1ZSIsImlzTmVzdGVkRnJvemVuIiwidmFsdWVzIiwiY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlIiwiaWdub3JlZEFjdGlvbnMiLCJpZ25vcmVkQWN0aW9uUGF0aHMiLCJpZ25vcmVTdGF0ZSIsImlnbm9yZUFjdGlvbnMiLCJkaXNhYmxlQ2FjaGUiLCJXZWFrU2V0Iiwic3RvcmVBUEkiLCJmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlIiwiZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlIiwiaXNCb29sZWFuIiwieCIsImJ1aWxkR2V0RGVmYXVsdE1pZGRsZXdhcmUiLCJnZXREZWZhdWx0TWlkZGxld2FyZSIsImltbXV0YWJsZUNoZWNrIiwic2VyaWFsaXphYmxlQ2hlY2siLCJhY3Rpb25DcmVhdG9yQ2hlY2siLCJtaWRkbGV3YXJlQXJyYXkiLCJleHRyYUFyZ3VtZW50IiwiaW1tdXRhYmxlT3B0aW9ucyIsInVuc2hpZnQiLCJzZXJpYWxpemFibGVPcHRpb25zIiwiYWN0aW9uQ3JlYXRvck9wdGlvbnMiLCJTSE9VTERfQVVUT0JBVENIIiwicHJlcGFyZUF1dG9CYXRjaGVkIiwiY3JlYXRlUXVldWVXaXRoVGltZXIiLCJ0aW1lb3V0Iiwibm90aWZ5Iiwic2V0VGltZW91dCIsInJBRiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImF1dG9CYXRjaEVuaGFuY2VyIiwic3RvcmUiLCJub3RpZnlpbmciLCJzaG91bGROb3RpZnlBdEVuZE9mVGljayIsIm5vdGlmaWNhdGlvblF1ZXVlZCIsImxpc3RlbmVycyIsInF1ZXVlQ2FsbGJhY2siLCJxdWV1ZU1pY3JvdGFzayIsInF1ZXVlTm90aWZpY2F0aW9uIiwibm90aWZ5TGlzdGVuZXJzIiwiZm9yRWFjaCIsImwiLCJzdWJzY3JpYmUiLCJsaXN0ZW5lcjIiLCJ3cmFwcGVkTGlzdGVuZXIiLCJ1bnN1YnNjcmliZSIsImRlbGV0ZSIsImRpc3BhdGNoIiwiYnVpbGRHZXREZWZhdWx0RW5oYW5jZXJzIiwibWlkZGxld2FyZUVuaGFuY2VyIiwiZ2V0RGVmYXVsdEVuaGFuY2VycyIsImF1dG9CYXRjaCIsImVuaGFuY2VyQXJyYXkiLCJJU19QUk9EVUNUSU9OIiwiY29uZmlndXJlU3RvcmUiLCJyZWR1Y2VyIiwibWlkZGxld2FyZSIsImRldlRvb2xzIiwicHJlbG9hZGVkU3RhdGUiLCJlbmhhbmNlcnMiLCJyb290UmVkdWNlciIsImZpbmFsTWlkZGxld2FyZSIsIml0ZW0iLCJmaW5hbENvbXBvc2UiLCJ0cmFjZSIsInN0b3JlRW5oYW5jZXJzIiwiaW5jbHVkZXMiLCJjb21wb3NlZEVuaGFuY2VyIiwiY3JlYXRlTmV4dFN0YXRlMiIsImlzRHJhZnQyIiwiaXNEcmFmdGFibGUyIiwiZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2siLCJidWlsZGVyQ2FsbGJhY2siLCJhY3Rpb25zTWFwIiwiYWN0aW9uTWF0Y2hlcnMiLCJkZWZhdWx0Q2FzZVJlZHVjZXIiLCJidWlsZGVyIiwiYWRkQ2FzZSIsInR5cGVPckFjdGlvbkNyZWF0b3IiLCJhZGRNYXRjaGVyIiwibWF0Y2hlciIsImFkZERlZmF1bHRDYXNlIiwiaXNTdGF0ZUZ1bmN0aW9uIiwiY3JlYXRlUmVkdWNlciIsImluaXRpYWxTdGF0ZSIsIm1hcE9yQnVpbGRlckNhbGxiYWNrIiwiZmluYWxBY3Rpb25NYXRjaGVycyIsImZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyIiwiZ2V0SW5pdGlhbFN0YXRlIiwiZnJvemVuSW5pdGlhbFN0YXRlIiwiY2FzZVJlZHVjZXJzIiwiZmlsdGVyIiwicmVkdWNlcjIiLCJjciIsInJlZHVjZSIsInByZXZpb3VzU3RhdGUiLCJjYXNlUmVkdWNlciIsImRyYWZ0IiwidXJsQWxwaGFiZXQiLCJuYW5vaWQiLCJzaXplIiwiaWQiLCJpIiwiTWF0aCIsInJhbmRvbSIsIm1hdGNoZXMiLCJpc0FueU9mIiwibWF0Y2hlcnMiLCJpc0FsbE9mIiwiaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEiLCJ2YWxpZFN0YXR1cyIsImhhc1ZhbGlkUmVxdWVzdElkIiwicmVxdWVzdElkIiwiaGFzVmFsaWRSZXF1ZXN0U3RhdHVzIiwicmVxdWVzdFN0YXR1cyIsImlzQXN5bmNUaHVua0FycmF5IiwiYSIsImlzUGVuZGluZyIsImFzeW5jVGh1bmtzIiwiYXN5bmNUaHVuayIsInBlbmRpbmciLCJjb21iaW5lZE1hdGNoZXIiLCJpc1JlamVjdGVkIiwicmVqZWN0ZWQiLCJpc1JlamVjdGVkV2l0aFZhbHVlIiwiaGFzRmxhZyIsInJlamVjdGVkV2l0aFZhbHVlIiwiaXNGdWxmaWxsZWQiLCJmdWxmaWxsZWQiLCJpc0FzeW5jVGh1bmtBY3Rpb24iLCJjb21tb25Qcm9wZXJ0aWVzIiwiUmVqZWN0V2l0aFZhbHVlIiwiRnVsZmlsbFdpdGhNZXRhIiwibWluaVNlcmlhbGl6ZUVycm9yIiwic2ltcGxlRXJyb3IiLCJwcm9wZXJ0eSIsIm1lc3NhZ2UiLCJTdHJpbmciLCJjcmVhdGVBc3luY1RodW5rIiwiY3JlYXRlQXN5bmNUaHVuazIiLCJ0eXBlUHJlZml4IiwicGF5bG9hZENyZWF0b3IiLCJhcmciLCJzZXJpYWxpemVFcnJvciIsImFib3J0ZWQiLCJuYW1lIiwiY29uZGl0aW9uIiwiZXh0cmEiLCJpZEdlbmVyYXRvciIsImFib3J0Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsImFib3J0SGFuZGxlciIsImFib3J0UmVhc29uIiwiYWJvcnQiLCJyZWFzb24iLCJwcm9taXNlIiwiZmluYWxBY3Rpb24iLCJjb25kaXRpb25SZXN1bHQiLCJpc1RoZW5hYmxlIiwic2lnbmFsIiwiYWJvcnRlZFByb21pc2UiLCJQcm9taXNlIiwicmVqZWN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImdldFBlbmRpbmdNZXRhIiwicmFjZSIsInJlc29sdmUiLCJyZWplY3RXaXRoVmFsdWUiLCJmdWxmaWxsV2l0aFZhbHVlIiwidGhlbiIsImVyciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJza2lwRGlzcGF0Y2giLCJkaXNwYXRjaENvbmRpdGlvblJlamVjdGlvbiIsInVud3JhcCIsInVud3JhcFJlc3VsdCIsInNldHRsZWQiLCJhc3luY1RodW5rU3ltYm9sIiwiZm9yIiwiYXN5bmNUaHVua0NyZWF0b3IiLCJSZWR1Y2VyVHlwZSIsIlJlZHVjZXJUeXBlMiIsImdldFR5cGUiLCJhY3Rpb25LZXkiLCJidWlsZENyZWF0ZVNsaWNlIiwiY3JlYXRvcnMiLCJjQVQiLCJjcmVhdGVTbGljZTIiLCJyZWR1Y2VyUGF0aCIsInJlZHVjZXJzIiwiYnVpbGRSZWR1Y2VyQ3JlYXRvcnMiLCJyZWR1Y2VyTmFtZXMiLCJjb250ZXh0Iiwic2xpY2VDYXNlUmVkdWNlcnNCeU5hbWUiLCJzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZSIsImFjdGlvbkNyZWF0b3JzIiwic2xpY2VNYXRjaGVycyIsImNvbnRleHRNZXRob2RzIiwiZXhwb3NlQWN0aW9uIiwibmFtZTIiLCJleHBvc2VDYXNlUmVkdWNlciIsInJlZHVjZXJOYW1lIiwicmVkdWNlckRlZmluaXRpb24iLCJyZWR1Y2VyRGV0YWlscyIsImNyZWF0ZU5vdGF0aW9uIiwiaXNBc3luY1RodW5rU2xpY2VSZWR1Y2VyRGVmaW5pdGlvbiIsImhhbmRsZVRodW5rQ2FzZVJlZHVjZXJEZWZpbml0aW9uIiwiaGFuZGxlTm9ybWFsUmVkdWNlckRlZmluaXRpb24iLCJidWlsZFJlZHVjZXIiLCJleHRyYVJlZHVjZXJzIiwiZmluYWxDYXNlUmVkdWNlcnMiLCJzTSIsIm0iLCJzZWxlY3RTZWxmIiwiaW5qZWN0ZWRTZWxlY3RvckNhY2hlIiwiTWFwIiwiX3JlZHVjZXIiLCJtYWtlU2VsZWN0b3JQcm9wcyIsInJlZHVjZXJQYXRoMiIsImluamVjdGVkIiwic2VsZWN0U2xpY2UiLCJzbGljZVN0YXRlIiwiZ2V0U2VsZWN0b3JzIiwic2VsZWN0U3RhdGUiLCJzZWxlY3RvckNhY2hlIiwiV2Vha01hcCIsInNlbGVjdG9ycyIsIndyYXBTZWxlY3RvciIsImFjdGlvbnMiLCJpbmplY3RJbnRvIiwiaW5qZWN0YWJsZSIsInBhdGhPcHQiLCJjb25maWciLCJuZXdSZWR1Y2VyUGF0aCIsImluamVjdCIsIndyYXBwZXIiLCJyb290U3RhdGUiLCJ1bndyYXBwZWQiLCJjcmVhdGVTbGljZSIsIl9yZWR1Y2VyRGVmaW5pdGlvblR5cGUiLCJwcmVwYXJlZFJlZHVjZXIiLCJwcmVwYXJlIiwibWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUiLCJwcmVwYXJlQ2FsbGJhY2siLCJpc0Nhc2VSZWR1Y2VyV2l0aFByZXBhcmVEZWZpbml0aW9uIiwibm9vcCIsImdldEluaXRpYWxFbnRpdHlTdGF0ZSIsImlkcyIsImVudGl0aWVzIiwiY3JlYXRlSW5pdGlhbFN0YXRlRmFjdG9yeSIsInN0YXRlQWRhcHRlciIsImFkZGl0aW9uYWxTdGF0ZSIsInNldEFsbCIsImNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkiLCJzZWxlY3RJZHMiLCJzZWxlY3RFbnRpdGllcyIsInNlbGVjdEFsbCIsInNlbGVjdElkIiwic2VsZWN0QnlJZCIsInNlbGVjdFRvdGFsIiwic2VsZWN0R2xvYmFsaXplZEVudGl0aWVzIiwiY3JlYXRlTmV4dFN0YXRlMyIsImlzRHJhZnQzIiwiaXNEcmFmdFR5cGVkIiwiY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yIiwibXV0YXRvciIsIm9wZXJhdG9yIiwiY3JlYXRlU3RhdGVPcGVyYXRvciIsIm9wZXJhdGlvbiIsImlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50IiwiYXJnMiIsInJ1bk11dGF0b3IiLCJzZWxlY3RJZFZhbHVlIiwiZW50aXR5IiwiZW5zdXJlRW50aXRpZXNBcnJheSIsInNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMiLCJuZXdFbnRpdGllcyIsImFkZGVkIiwidXBkYXRlZCIsImNoYW5nZXMiLCJjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlciIsImFkZE9uZU11dGFibHkiLCJhZGRNYW55TXV0YWJseSIsInNldE9uZU11dGFibHkiLCJzZXRNYW55TXV0YWJseSIsInNldEFsbE11dGFibHkiLCJyZW1vdmVPbmVNdXRhYmx5IiwicmVtb3ZlTWFueU11dGFibHkiLCJkaWRNdXRhdGUiLCJyZW1vdmVBbGxNdXRhYmx5IiwidGFrZU5ld0tleSIsIm9yaWdpbmFsMyIsIm5ld0tleSIsImhhc05ld0tleSIsInVwZGF0ZU9uZU11dGFibHkiLCJ1cGRhdGVNYW55TXV0YWJseSIsInVwZGF0ZXMiLCJuZXdLZXlzIiwidXBkYXRlc1BlckVudGl0eSIsImRpZE11dGF0ZUVudGl0aWVzIiwiZGlkTXV0YXRlSWRzIiwiZSIsInVwc2VydE9uZU11dGFibHkiLCJ1cHNlcnRNYW55TXV0YWJseSIsInJlbW92ZUFsbCIsImFkZE9uZSIsImFkZE1hbnkiLCJzZXRPbmUiLCJzZXRNYW55IiwidXBkYXRlT25lIiwidXBkYXRlTWFueSIsInVwc2VydE9uZSIsInVwc2VydE1hbnkiLCJyZW1vdmVPbmUiLCJyZW1vdmVNYW55IiwiY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyIiwic29ydCIsIm1vZGVscyIsIm1vZGVsIiwibWVyZ2UiLCJhcHBsaWVkVXBkYXRlcyIsIm5ld0lkIiwicmVzb3J0RW50aXRpZXMiLCJhcmVBcnJheXNFcXVhbCIsImIiLCJhbGxFbnRpdGllcyIsIm5ld1NvcnRlZElkcyIsImNyZWF0ZUVudGl0eUFkYXB0ZXIiLCJzb3J0Q29tcGFyZXIiLCJpbnN0YW5jZSIsInN0YXRlRmFjdG9yeSIsInNlbGVjdG9yc0ZhY3RvcnkiLCJpc0FjdGlvbjMiLCJ0YXNrIiwibGlzdGVuZXIiLCJjb21wbGV0ZWQiLCJjYW5jZWxsZWQiLCJ0YXNrQ2FuY2VsbGVkIiwidGFza0NvbXBsZXRlZCIsImxpc3RlbmVyQ2FuY2VsbGVkIiwibGlzdGVuZXJDb21wbGV0ZWQiLCJUYXNrQWJvcnRFcnJvciIsImNvZGUiLCJhc3NlcnRGdW5jdGlvbiIsImZ1bmMiLCJleHBlY3RlZCIsIm5vb3AyIiwiY2F0Y2hSZWplY3Rpb24iLCJvbkVycm9yIiwiY2F0Y2giLCJhZGRBYm9ydFNpZ25hbExpc3RlbmVyIiwiYWJvcnRTaWduYWwiLCJjYWxsYmFjayIsIm9uY2UiLCJhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWxpZGF0ZUFjdGl2ZSIsInJhY2VXaXRoU2lnbmFsIiwiY2xlYW51cCIsIm5vdGlmeVJlamVjdGlvbiIsImZpbmFsbHkiLCJydW5UYXNrIiwidGFzazIiLCJjbGVhblVwIiwic3RhdHVzIiwiY3JlYXRlUGF1c2UiLCJvdXRwdXQiLCJjcmVhdGVEZWxheSIsInBhdXNlIiwidGltZW91dE1zIiwiSU5URVJOQUxfTklMX1RPS0VOIiwiYWxtIiwiY3JlYXRlRm9yayIsInBhcmVudEFib3J0U2lnbmFsIiwicGFyZW50QmxvY2tpbmdQcm9taXNlcyIsImxpbmtDb250cm9sbGVycyIsImNvbnRyb2xsZXIiLCJ0YXNrRXhlY3V0b3IiLCJvcHRzIiwiY2hpbGRBYm9ydENvbnRyb2xsZXIiLCJyZXN1bHQyIiwiZGVsYXkiLCJhdXRvSm9pbiIsImNhbmNlbCIsImNyZWF0ZVRha2VQYXR0ZXJuIiwic3RhcnRMaXN0ZW5pbmciLCJ0YWtlIiwicHJlZGljYXRlIiwidHVwbGVQcm9taXNlIiwic3RvcExpc3RlbmluZyIsImVmZmVjdCIsImxpc3RlbmVyQXBpIiwiZ2V0T3JpZ2luYWxTdGF0ZSIsInByb21pc2VzIiwiZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbSIsImNyZWF0ZUxpc3RlbmVyRW50cnkiLCJjYW5jZWxBY3RpdmVMaXN0ZW5lcnMiLCJjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZSIsImxpc3RlbmVyTWFwIiwiY2xlYXIiLCJzYWZlbHlOb3RpZnlFcnJvciIsImVycm9ySGFuZGxlciIsImVycm9yVG9Ob3RpZnkiLCJlcnJvckluZm8iLCJlcnJvckhhbmRsZXJFcnJvciIsImFkZExpc3RlbmVyIiwiY2xlYXJBbGxMaXN0ZW5lcnMiLCJyZW1vdmVMaXN0ZW5lciIsImRlZmF1bHRFcnJvckhhbmRsZXIiLCJjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUiLCJtaWRkbGV3YXJlT3B0aW9ucyIsImluc2VydEVudHJ5IiwiY2FuY2VsT3B0aW9ucyIsImNhbmNlbEFjdGl2ZSIsImZyb20iLCJleGlzdGluZ0VudHJ5IiwiZW50cnkyIiwibWF0Y2hQcmVkaWNhdGVPclR5cGUiLCJub3RpZnlMaXN0ZW5lciIsImFwaSIsImludGVybmFsVGFza0NvbnRyb2xsZXIiLCJhdXRvSm9pblByb21pc2VzIiwiQm9vbGVhbiIsImZvcmsiLCJ0aHJvd0lmQ2FuY2VsbGVkIiwibGlzdGVuZXJFcnJvciIsInJhaXNlZEJ5IiwiYWxsIiwiY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUiLCJvcmlnaW5hbFN0YXRlIiwiY3VycmVudFN0YXRlIiwibGlzdGVuZXJFbnRyaWVzIiwicnVuTGlzdGVuZXIiLCJwcmVkaWNhdGVFcnJvciIsImNsZWFyTGlzdGVuZXJzIiwiY29tcG9zZTMiLCJjcmVhdGVNaWRkbGV3YXJlRW50cnkiLCJhcHBsaWVkIiwibWF0Y2hJbnN0YW5jZSIsImluc3RhbmNlSWQiLCJjcmVhdGVEeW5hbWljTWlkZGxld2FyZSIsIm1pZGRsZXdhcmVNYXAiLCJ3aXRoTWlkZGxld2FyZSIsIm1pZGRsZXdhcmVzIiwiYWRkTWlkZGxld2FyZSIsImFkZE1pZGRsZXdhcmUyIiwibWlkZGxld2FyZTIiLCJnZXRGaW5hbE1pZGRsZXdhcmUiLCJhcHBsaWVkTWlkZGxld2FyZSIsImlzV2l0aE1pZGRsZXdhcmUiLCJjb21iaW5lUmVkdWNlcnMyIiwiaXNTbGljZUxpa2UiLCJtYXliZVNsaWNlTGlrZSIsImdldFJlZHVjZXJzIiwic2xpY2VzIiwiZmxhdE1hcCIsInNsaWNlT3JNYXAiLCJPUklHSU5BTF9TVEFURSIsImlzU3RhdGVQcm94eSIsInN0YXRlUHJveHlNYXAiLCJjcmVhdGVTdGF0ZVByb3h5IiwicmVkdWNlck1hcCIsIlByb3h5IiwidGFyZ2V0IiwicHJvcCIsInJlY2VpdmVyIiwiUmVmbGVjdCIsInJlZHVjZXJSZXN1bHQiLCJub29wUmVkdWNlciIsImNvbWJpbmVTbGljZXMiLCJmcm9tRW50cmllcyIsImdldFJlZHVjZXIiLCJjb21iaW5lZFJlZHVjZXIiLCJ3aXRoTGF6eUxvYWRlZFNsaWNlcyIsInJlZHVjZXJUb0luamVjdCIsImN1cnJlbnRSZWR1Y2VyIiwib3ZlcnJpZGVFeGlzdGluZyIsIm1ha2VTZWxlY3RvciIsInNlbGVjdG9yRm4iLCJzZWxlY3RvcjIiLCJpc0ZsdXhTdGFuZGFyZEFjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\n");

/***/ })

};
;